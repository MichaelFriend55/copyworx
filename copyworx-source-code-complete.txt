CopyWorx Studio - Complete Source Code
Generated on: 2026-02-04 2:12:54 PM
For U.S. Copyright Office Registration

========================================


=== FILE: app/(app)/layout.tsx ===

/**
 * @file app/(app)/layout.tsx
 * @description Layout for authenticated app pages
 * 
 * Includes:
 * - Sidebar navigation
 * - Header with user info and UserButton
 * - Main content area
 */

import { UserButton } from '@clerk/nextjs';
import { currentUser } from '@clerk/nextjs/server';
import { Sidebar } from '@/components/layout/sidebar';
import { Bell } from 'lucide-react';
import { Button } from '@/components/ui/button';

/**
 * App layout component
 * 
 * Wraps all authenticated pages with the app sidebar and header.
 * Protected by Clerk middleware - only accessible to authenticated users.
 */
export default async function AppLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const user = await currentUser();

  return (
    <div className="flex h-screen overflow-hidden bg-ink-50">
      {/* Sidebar */}
      <Sidebar />
      
      {/* Main Content */}
      <div className="flex-1 flex flex-col overflow-hidden">
        {/* Header */}
        <header className="h-16 border-b border-border bg-white flex items-center justify-between px-6">
          <div>
            {/* Breadcrumb or search could go here */}
          </div>
          
          {/* User Section */}
          <div className="flex items-center gap-4">
            {/* Notifications Button */}
            <Button variant="ghost" size="icon" className="relative">
              <Bell className="h-5 w-5 text-ink-600" />
              <span className="absolute top-1 right-1 h-2 w-2 bg-amber-500 rounded-full" />
            </Button>
            
            {/* User Info */}
            <div className="hidden sm:flex items-center gap-3 pr-2 border-r border-border">
              <div className="text-right">
                <p className="text-sm font-medium text-ink-900">
                  {user?.firstName} {user?.lastName}
                </p>
                <p className="text-xs text-ink-500">
                  {user?.emailAddresses?.[0]?.emailAddress}
                </p>
              </div>
            </div>
            
            {/* User Button */}
            <UserButton 
              afterSignOutUrl="/"
              appearance={{
                elements: {
                  avatarBox: 'h-9 w-9',
                  userButtonPopoverCard: 'shadow-xl border border-border/50',
                  userButtonPopoverActionButton: 'hover:bg-ink-50',
                  userButtonPopoverActionButtonText: 'text-ink-700',
                  userButtonPopoverActionButtonIcon: 'text-ink-500',
                  userButtonPopoverFooter: 'hidden',
                },
              }}
            />
          </div>
        </header>
        
        {/* Page Content */}
        <main className="flex-1 overflow-y-auto p-6">
          {children}
        </main>
      </div>
    </div>
  );
}


=== FILE: app/(app)/projects/[projectId]/page.tsx ===

/**
 * @file app/(app)/projects/[projectId]/page.tsx
 * @description Dynamic project route that redirects to worxspace with specific project loaded
 * 
 * Purpose:
 * - Handles navigation from project cards
 * - Redirects /projects/[id] ‚Üí /worxspace?projectId=[id]
 * - Enables direct project linking and bookmarking
 * 
 * Security:
 * - Server-side redirect (no client-side exposure)
 * - Project access validated by workspace component
 * - Uses Next.js native redirect() for proper HTTP status codes
 */

import { redirect } from 'next/navigation';

/**
 * Props type for dynamic route params
 */
interface ProjectPageProps {
  params: {
    projectId: string;
  };
}

/**
 * Project page component
 * 
 * This is a minimal redirect component that:
 * 1. Receives the projectId from the URL path
 * 2. Redirects to the worxspace with the project loaded
 * 3. Allows the worxspace to handle all project logic
 * 
 * @param params - Dynamic route parameters containing projectId
 * @returns Never returns - redirects immediately
 */
export default function ProjectPage({ params }: ProjectPageProps) {
  // Validate projectId exists
  if (!params.projectId) {
    // If no projectId, redirect to worxspace without project
    redirect('/worxspace');
  }

  // Redirect to worxspace with project ID as query parameter
  redirect(`/worxspace?projectId=${params.projectId}`);
}


=== FILE: app/(app)/projects/page.tsx ===

/**
 * @file app/(app)/projects/page.tsx
 * @description Projects page - manage copywriting projects
 * 
 * Features:
 * - Project list with status
 * - Create new project
 * - Search and filter
 */

import type { Metadata } from 'next';
import Link from 'next/link';
import { 
  Search, 
  Plus, 
  MoreHorizontal, 
  FileText,
  Calendar,
  FolderOpen
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

export const metadata: Metadata = {
  title: 'Projects',
  description: 'Manage your copywriting projects.',
};

/**
 * Project data (placeholder)
 */
const projects: Array<{
  id: string;
  name: string;
  description: string;
  template: string;
  status: string;
  wordCount: number;
  lastEdited: string;
  createdAt: string;
}> = [
  {
    id: '1',
    name: 'Q4 Email Campaign',
    description: 'Holiday season email marketing campaign for product launch',
    template: 'Email Sequence',
    status: 'In Progress',
    wordCount: 2450,
    lastEdited: '2 hours ago',
    createdAt: 'Dec 15, 2025',
  },
  {
    id: '2',
    name: 'Product Launch Landing Page',
    description: 'Main landing page for the new premium tier launch',
    template: 'Landing Page',
    status: 'Draft',
    wordCount: 850,
    lastEdited: '5 hours ago',
    createdAt: 'Dec 14, 2025',
  },
  {
    id: '3',
    name: 'Social Media Content Pack',
    description: 'January content calendar posts for all platforms',
    template: 'Social Posts',
    status: 'Completed',
    wordCount: 1200,
    lastEdited: '1 day ago',
    createdAt: 'Dec 10, 2025',
  },
  {
    id: '4',
    name: 'Blog Post Series',
    description: 'Educational content series about copywriting tips',
    template: 'Blog Post',
    status: 'In Progress',
    wordCount: 3400,
    lastEdited: '2 days ago',
    createdAt: 'Dec 8, 2025',
  },
  {
    id: '5',
    name: 'LinkedIn Outreach',
    description: 'Connection request and follow-up message templates',
    template: 'Cold Outreach',
    status: 'Completed',
    wordCount: 450,
    lastEdited: '3 days ago',
    createdAt: 'Dec 5, 2025',
  },
  {
    id: '6',
    name: 'Google Ads Campaign',
    description: 'PPC ad copy for Q1 marketing campaign',
    template: 'Google Ads',
    status: 'Draft',
    wordCount: 320,
    lastEdited: '4 days ago',
    createdAt: 'Dec 3, 2025',
  },
] as const;

/**
 * Get status badge variant
 */
function getStatusVariant(status: string): 'amber' | 'secondary' | 'outline' {
  switch (status) {
    case 'Completed':
      return 'amber';
    case 'In Progress':
      return 'secondary';
    default:
      return 'outline';
  }
}

/**
 * Projects page component
 */
export default function ProjectsPage() {
  return (
    <div className="space-y-8">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="font-sans text-3xl font-bold text-ink-900">
            Projects
          </h1>
          <p className="text-ink-600 mt-1">
            Manage and organize your copywriting projects.
          </p>
        </div>
        <Button variant="amber" asChild>
          <Link href="/projects/new">
            <Plus className="h-4 w-4 mr-2" />
            New Project
          </Link>
        </Button>
      </div>

      {/* Search and Filters */}
      <div className="flex flex-col sm:flex-row gap-4">
        <div className="relative flex-1">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-ink-400" />
          <Input 
            placeholder="Search projects..." 
            className="pl-10"
          />
        </div>
        <div className="flex gap-2">
          <Button variant="outline" size="default">
            All Status
          </Button>
          <Button variant="outline" size="default">
            Sort by: Recent
          </Button>
        </div>
      </div>

      {/* Projects List */}
      <div className="space-y-4">
        {projects.map((project) => (
          <Card 
            key={project.id} 
            className="border-border/50 hover:shadow-md transition-shadow"
          >
            <CardContent className="p-6">
              <div className="flex flex-col lg:flex-row lg:items-center justify-between gap-4">
                {/* Project Info */}
                <div className="flex items-start gap-4 flex-1">
                  <div className="h-12 w-12 rounded-xl bg-ink-100 flex items-center justify-center shrink-0">
                    <FolderOpen className="h-6 w-6 text-ink-600" />
                  </div>
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2 mb-1">
                      <Link 
                        href={`/projects/${project.id}`}
                        className="font-semibold text-ink-900 hover:text-amber-600 transition-colors truncate"
                      >
                        {project.name}
                      </Link>
                      <Badge variant={getStatusVariant(project.status)}>
                        {project.status}
                      </Badge>
                    </div>
                    <p className="text-sm text-ink-500 line-clamp-1 mb-2">
                      {project.description}
                    </p>
                    <div className="flex flex-wrap items-center gap-x-4 gap-y-1 text-xs text-ink-400">
                      <span className="flex items-center gap-1">
                        <FileText className="h-3.5 w-3.5" />
                        {project.template}
                      </span>
                      <span className="flex items-center gap-1">
                        <Calendar className="h-3.5 w-3.5" />
                        {project.createdAt}
                      </span>
                      <span>
                        {project.wordCount.toLocaleString()} words
                      </span>
                    </div>
                  </div>
                </div>

                {/* Actions */}
                <div className="flex items-center gap-2 lg:gap-4">
                  <span className="text-sm text-ink-500 whitespace-nowrap">
                    Edited {project.lastEdited}
                  </span>
                  <Button variant="ghost" size="sm" asChild>
                    <Link href={`/projects/${project.id}`}>
                      Open
                    </Link>
                  </Button>
                  <Button variant="ghost" size="icon" className="h-8 w-8">
                    <MoreHorizontal className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>

      {/* Empty State (hidden when projects exist) */}
      {projects.length === 0 && (
        <Card className="border-dashed border-2 border-border">
          <CardContent className="py-12 text-center">
            <div className="h-16 w-16 rounded-full bg-ink-100 flex items-center justify-center mx-auto mb-4">
              <FolderOpen className="h-8 w-8 text-ink-400" />
            </div>
            <h3 className="font-sans text-lg font-semibold text-ink-900 mb-2">
              No projects yet
            </h3>
            <p className="text-ink-500 mb-6 max-w-sm mx-auto">
              Get started by creating your first copywriting project.
            </p>
            <Button variant="amber" asChild>
              <Link href="/projects/new">
                <Plus className="h-4 w-4 mr-2" />
                Create Project
              </Link>
            </Button>
          </CardContent>
        </Card>
      )}
    </div>
  );
}



=== FILE: app/(app)/templates/page.tsx ===

/**
 * @file app/(app)/templates/page.tsx
 * @description Templates page - browse and select copywriting templates
 * 
 * Features:
 * - Template categories
 * - Search and filter
 * - Template cards with previews
 */

import type { Metadata } from 'next';
import Link from 'next/link';
import { Search, Filter, ArrowRight } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';

export const metadata: Metadata = {
  title: 'Templates',
  description: 'Browse our collection of AI-powered copywriting templates.',
};

/**
 * Template categories
 */
const categories = [
  { id: 'all', name: 'All Templates', count: 50 },
  { id: 'email', name: 'Email', count: 12 },
  { id: 'landing', name: 'Landing Pages', count: 8 },
  { id: 'social', name: 'Social Media', count: 15 },
  { id: 'ads', name: 'Advertising', count: 10 },
  { id: 'website', name: 'Website Copy', count: 5 },
] as const;

/**
 * Template data (placeholder)
 */
const templates = [
  {
    id: '1',
    name: 'Email Welcome Sequence',
    description: 'A 5-part welcome email series to onboard new subscribers and build trust.',
    category: 'Email',
    popular: true,
    icon: '‚úâÔ∏è',
  },
  {
    id: '2',
    name: 'SaaS Landing Page',
    description: 'High-converting landing page copy for software products with benefit-driven headlines.',
    category: 'Landing Pages',
    popular: true,
    icon: 'üöÄ',
  },
  {
    id: '3',
    name: 'Facebook Ad Copy',
    description: 'Scroll-stopping Facebook ad copy with multiple hook variations.',
    category: 'Advertising',
    popular: false,
    icon: 'üì¢',
  },
  {
    id: '4',
    name: 'LinkedIn Post Series',
    description: 'Thought leadership posts optimized for LinkedIn engagement.',
    category: 'Social Media',
    popular: true,
    icon: 'üíº',
  },
  {
    id: '5',
    name: 'Product Description',
    description: 'Compelling product descriptions that highlight benefits and drive purchases.',
    category: 'Website Copy',
    popular: false,
    icon: 'üè∑Ô∏è',
  },
  {
    id: '6',
    name: 'Cold Email Outreach',
    description: 'Personalized cold email templates with proven open rate optimization.',
    category: 'Email',
    popular: true,
    icon: 'üéØ',
  },
  {
    id: '7',
    name: 'Twitter/X Thread',
    description: 'Viral-worthy Twitter threads that educate and engage your audience.',
    category: 'Social Media',
    popular: false,
    icon: 'üê¶',
  },
  {
    id: '8',
    name: 'Google Ads Copy',
    description: 'High-CTR Google Ads copy with keyword optimization.',
    category: 'Advertising',
    popular: false,
    icon: 'üîç',
  },
  {
    id: '9',
    name: 'About Page',
    description: 'Tell your brand story with compelling about page copy.',
    category: 'Website Copy',
    popular: false,
    icon: 'üìñ',
  },
] as const;

/**
 * Templates page component
 */
export default function TemplatesPage() {
  return (
    <div className="space-y-8">
      {/* Header */}
      <div>
        <h1 className="font-sans text-3xl font-bold text-ink-900">
          Templates
        </h1>
        <p className="text-ink-600 mt-1">
          Choose from 50+ AI-powered copywriting templates.
        </p>
      </div>

      {/* Search and Filter */}
      <div className="flex flex-col sm:flex-row gap-4">
        <div className="relative flex-1">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-ink-400" />
          <Input 
            placeholder="Search templates..." 
            className="pl-10"
          />
        </div>
        <Button variant="outline">
          <Filter className="h-4 w-4 mr-2" />
          Filter
        </Button>
      </div>

      {/* Categories */}
      <div className="flex flex-wrap gap-2">
        {categories.map((category) => (
          <button
            key={category.id}
            className={`
              px-4 py-2 rounded-full text-sm font-medium transition-colors
              ${category.id === 'all' 
                ? 'bg-ink-900 text-white' 
                : 'bg-white border border-border hover:bg-ink-50 text-ink-700'
              }
            `}
          >
            {category.name}
            <span className="ml-2 text-xs opacity-60">
              {category.count}
            </span>
          </button>
        ))}
      </div>

      {/* Templates Grid */}
      <div className="grid sm:grid-cols-2 lg:grid-cols-3 gap-6">
        {templates.map((template) => (
          <Card 
            key={template.id} 
            className="border-border/50 hover:shadow-lg hover:-translate-y-1 transition-all duration-300 group"
          >
            <CardHeader>
              <div className="flex items-start justify-between">
                <div className="h-12 w-12 rounded-xl bg-amber-100 flex items-center justify-center text-2xl">
                  {template.icon}
                </div>
                {template.popular && (
                  <Badge variant="amber">Popular</Badge>
                )}
              </div>
              <CardTitle className="text-lg mt-4">{template.name}</CardTitle>
              <CardDescription className="line-clamp-2">
                {template.description}
              </CardDescription>
            </CardHeader>
            <CardContent>
              <Badge variant="secondary">{template.category}</Badge>
            </CardContent>
            <CardFooter>
              <Button 
                variant="ghost" 
                className="w-full group-hover:bg-amber-50 group-hover:text-amber-700"
                asChild
              >
                <Link href={`/templates/${template.id}`}>
                  Use Template
                  <ArrowRight className="h-4 w-4 ml-2" />
                </Link>
              </Button>
            </CardFooter>
          </Card>
        ))}
      </div>
    </div>
  );
}



=== FILE: app/(marketing)/about/page.tsx ===

/**
 * @file app/(marketing)/about/page.tsx
 * @description About page for CopyWorx
 * 
 * Sections:
 * - Hero with mission statement
 * - Company story
 * - Team values
 * - Stats section
 */

import type { Metadata } from 'next';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent } from '@/components/ui/card';
import { 
  Heart, 
  Lightbulb, 
  Users, 
  Rocket,
  Target,
  Shield
} from 'lucide-react';

export const metadata: Metadata = {
  title: 'About',
  description: 'Learn about CopyWorx and our mission to help copywriters create better content faster.',
};

/**
 * Company values data
 */
const values = [
  {
    icon: Heart,
    title: 'Customer First',
    description: 'Everything we build starts with understanding and solving real problems for copywriters.',
  },
  {
    icon: Lightbulb,
    title: 'Innovation',
    description: 'We constantly push the boundaries of what AI can do for creative writing.',
  },
  {
    icon: Users,
    title: 'Community',
    description: 'We believe in the power of collaboration and learning from each other.',
  },
  {
    icon: Rocket,
    title: 'Excellence',
    description: 'We hold ourselves to the highest standards in everything we create.',
  },
  {
    icon: Target,
    title: 'Results-Driven',
    description: 'We measure success by the outcomes our users achieve with our tools.',
  },
  {
    icon: Shield,
    title: 'Trust & Privacy',
    description: 'Your content is yours. We never use your data to train our models.',
  },
] as const;

/**
 * Company stats data
 */
const stats = [
  { value: '10,000+', label: 'Active Users' },
  { value: '2M+', label: 'Words Generated' },
  { value: '50+', label: 'Templates' },
  { value: '98%', label: 'Customer Satisfaction' },
] as const;

/**
 * About page component
 */
export default function AboutPage() {
  return (
    <>
      {/* Hero Section */}
      <section className="relative overflow-hidden py-24 md:py-32">
        {/* Background */}
        <div className="absolute inset-0 bg-gradient-to-b from-ink-50/50 via-transparent to-transparent" />
        <div className="absolute inset-0 bg-dots opacity-30" />
        
        <div className="container mx-auto px-4 sm:px-6 lg:px-8 relative">
          <div className="max-w-3xl mx-auto text-center">
            <Badge variant="secondary" className="mb-6">About Us</Badge>
            <h1 className="font-sans text-4xl md:text-5xl lg:text-6xl font-bold text-ink-900 mb-6">
              Empowering writers to create their best work
            </h1>
            <p className="text-lg md:text-xl text-ink-600 leading-relaxed">
              CopyWorx was founded with a simple mission: help copywriters and marketers 
              create compelling content that drives results, without the blank page anxiety.
            </p>
          </div>
        </div>
      </section>

      {/* Story Section */}
      <section className="py-24 md:py-32 bg-white">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          <div className="grid lg:grid-cols-2 gap-12 lg:gap-16 items-center">
            {/* Image Placeholder */}
            <div className="relative">
              <div className="aspect-square rounded-2xl bg-gradient-to-br from-amber-100 via-amber-50 to-ink-50 flex items-center justify-center">
                <div className="w-3/4 h-3/4 rounded-xl bg-white shadow-2xl flex items-center justify-center">
                  <span className="font-sans text-6xl text-ink-200">‚úçÔ∏è</span>
                </div>
              </div>
              {/* Decorative element */}
              <div className="absolute -bottom-6 -right-6 w-32 h-32 bg-amber-400 rounded-2xl -z-10" />
            </div>
            
            {/* Content */}
            <div>
              <Badge variant="amber" className="mb-4">Our Story</Badge>
              <h2 className="font-sans text-3xl md:text-4xl font-bold text-ink-900 mb-6">
                Built by copywriters, for copywriters
              </h2>
              <div className="space-y-4 text-ink-600 leading-relaxed">
                <p>
                  CopyWorx started in 2023 when our founders‚Äîexperienced copywriters 
                  themselves‚Äîrecognized a gap in the market. While AI writing tools existed, 
                  none truly understood the craft of copywriting.
                </p>
                <p>
                  We set out to build something different: an AI assistant that understands 
                  proven copywriting frameworks, conversion psychology, and brand voice. 
                  Not a replacement for human creativity, but a powerful amplifier of it.
                </p>
                <p>
                  Today, CopyWorx helps thousands of marketers and copywriters create 
                  better content faster. From startups to Fortune 500 companies, our users 
                  trust us to help them craft messages that resonate and convert.
                </p>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Stats Section */}
      <section className="py-16 bg-ink-950">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          <div className="grid grid-cols-2 md:grid-cols-4 gap-8">
            {stats.map((stat) => (
              <div key={stat.label} className="text-center">
                <div className="font-sans text-4xl md:text-5xl font-bold text-amber-400 mb-2">
                  {stat.value}
                </div>
                <div className="text-ink-400 text-sm">
                  {stat.label}
                </div>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* Values Section */}
      <section className="py-24 md:py-32 bg-gradient-to-b from-white to-ink-50/50">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          {/* Section Header */}
          <div className="max-w-3xl mx-auto text-center mb-16">
            <Badge variant="secondary" className="mb-4">Our Values</Badge>
            <h2 className="font-sans text-3xl md:text-4xl font-bold text-ink-900 mb-6">
              What we stand for
            </h2>
            <p className="text-lg text-ink-600">
              These core values guide everything we do at CopyWorx.
            </p>
          </div>
          
          {/* Values Grid */}
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6 lg:gap-8">
            {values.map((value) => (
              <Card 
                key={value.title}
                className="border-border/50 bg-white"
              >
                <CardContent className="p-6">
                  <div className="flex h-12 w-12 items-center justify-center rounded-xl bg-ink-100 text-ink-700 mb-4">
                    <value.icon className="h-6 w-6" />
                  </div>
                  <h3 className="font-sans text-xl font-semibold text-ink-900 mb-2">
                    {value.title}
                  </h3>
                  <p className="text-ink-600 leading-relaxed">
                    {value.description}
                  </p>
                </CardContent>
              </Card>
            ))}
          </div>
        </div>
      </section>
    </>
  );
}



=== FILE: app/(marketing)/layout.tsx ===

/**
 * @file app/(marketing)/layout.tsx
 * @description Layout for marketing pages (public-facing)
 * 
 * Includes:
 * - Minimal auth header (Clerk only, no navigation)
 * - Footer
 * - No navbar - hero starts at top
 */

'use client';

import { SignedIn, SignedOut, UserButton } from '@clerk/nextjs';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { MarketingFooter } from '@/components/layout/marketing-footer';

/**
 * Marketing layout component
 * 
 * Wraps all public-facing pages with minimal auth header and footer.
 * No navigation bar - just Clerk auth components.
 */
export default function MarketingLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="flex min-h-screen flex-col">
      {/* Minimal Auth Header - Fixed top right */}
      <div className="fixed top-0 right-0 z-50 p-4">
        <div className="flex items-center gap-4">
          {/* Show when user IS signed in */}
          <SignedIn>
            <Button variant="ghost" className="bg-gradient-to-r from-[#006EE6] to-[#A755F7] text-white hover:opacity-90" asChild>
              <Link href="/worxspace">Worxspace</Link>
            </Button>
            <UserButton 
              afterSignOutUrl="/home"
              appearance={{
                elements: {
                  avatarBox: 'h-9 w-9 shadow-lg',
                  userButtonPopoverCard: 'shadow-xl border border-border/50',
                  userButtonPopoverActionButton: 'hover:bg-ink-50',
                  userButtonPopoverActionButtonText: 'text-ink-700',
                  userButtonPopoverActionButtonIcon: 'text-ink-500',
                  userButtonPopoverFooter: 'hidden',
                },
              }}
            />
          </SignedIn>

          {/* Show when user is NOT signed in */}
          <SignedOut>
            <Button variant="ghost" className="bg-white/80 backdrop-blur-sm hover:bg-white" asChild>
              <Link href="/sign-in">Sign In</Link>
            </Button>
          </SignedOut>
        </div>
      </div>

      <main className="flex-1">
        {children}
      </main>
      <MarketingFooter />
    </div>
  );
}


=== FILE: app/(marketing)/page.tsx ===

/**
 * @file app/(marketing)/page.tsx
 * @description CopyWorx‚Ñ¢ Studio landing page - professional marketing homepage
 * 
 * Sections:
 * - Hero with solid gray background and primary CTA
 * - The Challenge - problem statement
 * - The Story - founder narrative with gradient background
 * - Features - 2x2 grid of key capabilities
 * - How It Works - 4-step process
 * - Beta Access - final CTA section
 */

import Image from 'next/image';
import { 
  Sparkles, 
  Palette, 
  FileText, 
  FolderOpen,
  ArrowRight
} from 'lucide-react';
import { Button } from '@/components/ui/button';

/**
 * Features data for the features section
 */
const features = [
  {
    icon: Sparkles,
    title: 'Copy Optimizer Suite',
    description: 'Refine your copy in real time. Shift tone, expand ideas, tighten language, or completely rewrite for different channels ‚Äì all while maintaining your unique voice.',
  },
  {
    icon: FileText,
    title: 'AI@Worx Templates',
    description: "Strategic templates that ask the right questions to put you in the right direction fast. No more staring at a blank page. Answer a few prompts and get professional copy that's ready to refine.",
  },
  {
    icon: Palette,
    title: 'Brand Voice System',
    description: 'Define your brand voice once, and CopyWorx‚Ñ¢ Studio ensures everything you write stays on brand. Create detailed personas, set approved phrases and forbidden words, and maintain consistency across every piece of content.',
  },
  {
    icon: FolderOpen,
    title: 'Smart Document Management',
    description: 'Organize projects by client, track versions, and manage your entire copywriting workflow in one intuitive worxspace. No more scattered Google Docs or lost revisions.',
  },
] as const;

/**
 * How it works steps
 */
const steps = [
  {
    number: '01',
    title: 'Define Your Brand',
    description: 'Define your brand voice and create customer personas (or skip this and start writing)',
  },
  {
    number: '02',
    title: 'Choose Your Starting Point',
    description: 'Choose a template or start from scratch in the editor',
  },
  {
    number: '03',
    title: 'Write & Optimize',
    description: 'Write, optimize, and refine with AI-powered tools ‚Äì use as much or as little help as you need',
  },
  {
    number: '04',
    title: 'Export & Deliver',
    description: 'Export professional, on-brand copy in minutes',
  },
] as const;

/**
 * Homepage component - CopyWorx‚Ñ¢ Studio landing page
 */
export default function HomePage() {
  return (
    <div className="scroll-smooth">
      {/* ========================================================================
          HERO SECTION
          Full viewport height with solid gray background
          ======================================================================== */}
      <section className="relative min-h-screen flex items-center justify-center overflow-hidden bg-[#F5F5F7]">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8 relative z-10">
          <div className="max-w-4xl mx-auto text-center">
            {/* Logo - Large (reduced 10% from previous) */}
            <div className="flex justify-center mb-14 animate-fade-in">
              <Image
                src="/copyworx-studio-logo.png"
                alt="CopyWorx‚Ñ¢ Studio"
                width={720}
                height={200}
                className="h-44 sm:h-56 md:h-[17rem] w-auto"
                priority
              />
            </div>
            
            {/* Headline */}
            <h1 className="font-sans text-4xl sm:text-5xl md:text-6xl lg:text-7xl font-bold text-ink-900 leading-[1.1] tracking-tight mb-6 animate-fade-in animation-delay-100">
              Write To Win With
              <br />
              <span className="bg-gradient-to-r from-[#006EE6] to-[#A755F7] bg-clip-text text-transparent">CopyWorx‚Ñ¢ Studio</span>
            </h1>
            
            {/* Subheadline */}
            <p className="text-lg sm:text-xl md:text-2xl text-ink-600 max-w-3xl mx-auto leading-relaxed mb-10 animate-fade-in animation-delay-200">
              The first AI-powered platform built by a professional copywriter, for copywriters and marketers.
            </p>
            
            {/* Primary CTA */}
            <div className="animate-fade-in animation-delay-300">
              <Button 
                size="xl" 
                className="bg-gradient-to-r from-[#006EE6] to-[#A755F7] text-white hover:opacity-90 font-semibold text-lg px-10 py-6 h-auto shadow-2xl transition-all duration-300"
                asChild
              >
                <a href="https://tally.so/r/Xx4yxV">
                  Request Beta Access
                  <ArrowRight className="ml-2 h-5 w-5" />
                </a>
              </Button>
            </div>
          </div>
        </div>
        
        {/* Scroll Indicator */}
        <div className="absolute bottom-8 left-1/2 -translate-x-1/2 animate-bounce">
          <div className="w-6 h-10 rounded-full border-2 border-ink-400/50 flex items-start justify-center p-2">
            <div className="w-1.5 h-3 bg-ink-400/70 rounded-full" />
          </div>
        </div>
      </section>

      {/* ========================================================================
          THE CHALLENGE SECTION
          Problem statement with clean typography
          ======================================================================== */}
      <section className="py-24 md:py-32 bg-white">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          <div className="max-w-4xl mx-auto">
            <h2 className="font-sans text-3xl sm:text-4xl md:text-5xl font-bold text-ink-900 mb-8 text-center">
              Writing Great Copy Shouldn&apos;t Be So Hard
            </h2>
            
            <div className="prose prose-lg md:prose-xl max-w-none text-ink-600 leading-relaxed space-y-6">
              <p>
                Whether you&apos;re a seasoned copywriter juggling multiple clients or a marketing team trying to maintain brand consistency across campaigns, the challenge is the same: How do you write professional, strategic copy quickly without sacrificing quality?
              </p>
              
              <p>
                Traditional writing tools aren&apos;t built for copywriters. AI tools promise speed but deliver generic fluff. And hiring out? Expensive and slow.
              </p>
              
              <p className="text-ink-900 font-semibold text-xl md:text-2xl">
                CopyWorx‚Ñ¢ Studio changes that.
              </p>
            </div>
          </div>
        </div>
      </section>

      {/* ========================================================================
          THE STORY SECTION
          Founder narrative with gradient background and white text
          ======================================================================== */}
      <section className="py-24 md:py-32 bg-gradient-to-br from-[#006EE6] via-[#4B3F99] to-[#A755F7] relative overflow-hidden">
        {/* Subtle Pattern Overlay */}
        <div className="absolute inset-0 opacity-10">
          <div className="absolute inset-0" style={{
            backgroundImage: 'radial-gradient(circle at 1px 1px, white 1px, transparent 1px)',
            backgroundSize: '40px 40px'
          }} />
        </div>
        
        {/* Decorative Glow Elements */}
        <div className="absolute top-0 left-0 w-72 h-72 bg-[#EFBF04]/10 rounded-full blur-3xl" />
        <div className="absolute bottom-0 right-0 w-96 h-96 bg-white/5 rounded-full blur-3xl" />
        
        <div className="container mx-auto px-4 sm:px-6 lg:px-8 relative z-10">
          <div className="max-w-4xl mx-auto">
            <h2 className="font-sans text-3xl sm:text-4xl md:text-5xl font-bold text-white mb-8 text-center">
              Built By A Copywriter Who Gets It
            </h2>
            
            <div className="prose prose-lg md:prose-xl max-w-none text-white/90 leading-relaxed space-y-6">
              <p>
                CopyWorx‚Ñ¢ Studio leverages proven, time-tested copywriting tools and combines them with the power of AI to create a platform any marketing professional can use ‚Äî regardless of writing experience ‚Äî to create professional, high-converting copy in minutes.
              </p>
              
              <p>
                CopyWorx‚Ñ¢ Studio was created by a professional copywriter, creative director, and branding expert with over 40 years of experience. He and his team have packed CopyWorx‚Ñ¢ Studio with all of the features and functions a copywriter needs in one, clean, intuitive worxspace.
              </p>
              
              <p>
                CopyWorx‚Ñ¢ Studio utilizes AI in all the ways that are important to writers ‚Äì inspiring ideas, finessing copy, offering strategic suggestions, checking and changing tone and style, and always reviewing copy through the lens of brand standards and customer personas. And of course, just being a solid writing app with the features, functions and worxflows you expect in today&apos;s writing tools.
              </p>
              
              {/* Highlighted sentence */}
              <p className="bg-white/10 border-l-4 border-[#EFBF04] pl-6 py-4 rounded-r-lg backdrop-blur-sm">
                <strong className="text-white text-xl md:text-2xl">
                  With CopyWorx‚Ñ¢ Studio, you can use as much or as little AI as you like.
                </strong>
              </p>
              
              <p>
                Start with a template, start with a brand voice, start on your own. The point is, it&apos;s easy to get started with real workflow-aware functionality.
              </p>
            </div>
          </div>
        </div>
      </section>

      {/* ========================================================================
          FEATURES SECTION
          2x2 grid of key capabilities
          ======================================================================== */}
      <section className="py-24 md:py-32 bg-white">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          {/* Section Header */}
          <div className="max-w-3xl mx-auto text-center mb-16">
            <h2 className="font-sans text-3xl sm:text-4xl md:text-5xl font-bold text-ink-900 mb-6">
              What Makes CopyWorx‚Ñ¢ Studio Different
            </h2>
          </div>
          
          {/* Features Grid - 2x2 */}
          <div className="max-w-5xl mx-auto grid md:grid-cols-2 gap-8">
            {features.map((feature, index) => (
              <div 
                key={feature.title}
                className="group relative bg-white rounded-2xl border border-ink-200 p-8 shadow-sm hover:shadow-xl hover:border-[#006EE6]/30 transition-all duration-300"
                style={{ animationDelay: `${index * 100}ms` }}
              >
                {/* Icon */}
                <div className="flex h-14 w-14 items-center justify-center rounded-xl bg-gradient-to-br from-[#006EE6] to-[#A755F7] text-white mb-6 group-hover:scale-110 transition-transform duration-300">
                  <feature.icon className="h-7 w-7" />
                </div>
                
                {/* Content */}
                <h3 className="font-sans text-xl md:text-2xl font-semibold text-ink-900 mb-3">
                  {feature.title}
                </h3>
                <p className="text-ink-600 leading-relaxed">
                  {feature.description}
                </p>
              </div>
            ))}
          </div>
        </div>
      </section>

      {/* ========================================================================
          HOW IT WORKS SECTION
          4-step process with numbered steps
          ======================================================================== */}
      <section className="py-24 md:py-32 bg-ink-950 text-white">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          {/* Section Header */}
          <div className="max-w-3xl mx-auto text-center mb-16">
            <h2 className="font-sans text-3xl sm:text-4xl md:text-5xl font-bold text-white mb-6">
              How It Works
            </h2>
          </div>
          
          {/* Steps */}
          <div className="max-w-4xl mx-auto">
            <div className="grid md:grid-cols-2 gap-8 md:gap-12">
              {steps.map((step, index) => (
                <div 
                  key={step.number}
                  className="relative flex gap-6"
                  style={{ animationDelay: `${index * 100}ms` }}
                >
                  {/* Step Number */}
                  <div className="flex-shrink-0">
                    <div className="flex h-16 w-16 items-center justify-center rounded-full bg-gradient-to-br from-[#006EE6] to-[#A755F7] text-white font-bold text-xl">
                      {step.number}
                    </div>
                  </div>
                  
                  {/* Step Content */}
                  <div className="pt-2">
                    <h3 className="font-sans text-xl font-semibold text-white mb-2">
                      {step.title}
                    </h3>
                    <p className="text-ink-300 leading-relaxed">
                      {step.description}
                    </p>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      </section>

      {/* ========================================================================
          BETA ACCESS SECTION
          Final CTA with gradient background
          ======================================================================== */}
      <section className="py-24 md:py-32 bg-[#F5F5F7] relative overflow-hidden">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8 relative z-10">
          <div className="max-w-3xl mx-auto text-center">
            <h2 className="font-sans text-3xl sm:text-4xl md:text-5xl font-bold text-ink-900 mb-6">
              Ready To Write To Win?
            </h2>
            
            <div className="text-lg md:text-xl text-ink-600 leading-relaxed space-y-6 mb-10">
              <p>
                CopyWorx‚Ñ¢ Studio is currently in closed beta. We&apos;re carefully selecting marketing professionals and copywriters to test the platform and help shape its future.
              </p>
              
              <p>
                Request access below and tell us why you want in. We review every application and send invites to approved beta testers.
              </p>
              
              <p className="bg-gradient-to-r from-[#006EE6] to-[#A755F7] bg-clip-text text-transparent font-semibold text-xl md:text-2xl">
                Now let&apos;s get to worx!
              </p>
            </div>
            
            {/* CTA Button */}
            <Button 
              size="xl" 
              className="bg-gradient-to-r from-[#006EE6] to-[#A755F7] text-white hover:opacity-90 font-semibold text-lg px-10 py-6 h-auto shadow-2xl transition-all duration-300"
              asChild
            >
              <a href="https://tally.so/r/Xx4yxV">
                Request Beta Access
                <ArrowRight className="ml-2 h-5 w-5" />
              </a>
            </Button>
          </div>
        </div>
      </section>

    </div>
  );
}


=== FILE: app/(marketing)/pricing/page.tsx ===

/**
 * @file app/(marketing)/pricing/page.tsx
 * @description Pricing page for CopyWorx
 * 
 * Sections:
 * - Pricing tiers
 * - Feature comparison
 * - FAQ section
 */

import type { Metadata } from 'next';
import Link from 'next/link';
import { Check, X, HelpCircle } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from '@/components/ui/card';
import { cn } from '@/lib/utils';

export const metadata: Metadata = {
  title: 'Pricing',
  description: 'Simple, transparent pricing for teams of all sizes. Start free and scale as you grow.',
};

/**
 * Pricing tiers configuration
 */
const pricingTiers = [
  {
    name: 'Free',
    description: 'Perfect for trying out CopyWorx',
    price: '$0',
    period: 'forever',
    cta: 'Get Started',
    ctaVariant: 'outline' as const,
    highlighted: false,
    features: [
      { name: '1,000 words per month', included: true },
      { name: '5 templates', included: true },
      { name: 'Basic analytics', included: true },
      { name: 'Community support', included: true },
      { name: 'Team collaboration', included: false },
      { name: 'Custom brand voice', included: false },
      { name: 'API access', included: false },
      { name: 'Priority support', included: false },
    ],
  },
  {
    name: 'Pro',
    description: 'For professional copywriters',
    price: '$29',
    period: 'per month',
    cta: 'Start Free Trial',
    ctaVariant: 'amber' as const,
    highlighted: true,
    features: [
      { name: 'Unlimited words', included: true },
      { name: '50+ templates', included: true },
      { name: 'Advanced analytics', included: true },
      { name: 'Email support', included: true },
      { name: 'Team collaboration (3 seats)', included: true },
      { name: 'Custom brand voice', included: true },
      { name: 'API access', included: false },
      { name: 'Priority support', included: false },
    ],
  },
  {
    name: 'Team',
    description: 'For growing teams',
    price: '$79',
    period: 'per month',
    cta: 'Start Free Trial',
    ctaVariant: 'ink' as const,
    highlighted: false,
    features: [
      { name: 'Unlimited words', included: true },
      { name: '50+ templates', included: true },
      { name: 'Advanced analytics', included: true },
      { name: 'Priority email support', included: true },
      { name: 'Team collaboration (10 seats)', included: true },
      { name: 'Custom brand voice', included: true },
      { name: 'API access', included: true },
      { name: 'Dedicated account manager', included: true },
    ],
  },
] as const;

/**
 * FAQ items
 */
const faqItems = [
  {
    question: 'What counts as a word?',
    answer: 'Every word generated by our AI counts toward your monthly limit. Edited or manually typed content does not count.',
  },
  {
    question: 'Can I change plans anytime?',
    answer: 'Yes! You can upgrade or downgrade your plan at any time. Changes take effect at the start of your next billing cycle.',
  },
  {
    question: 'Is there a free trial?',
    answer: 'Yes, all paid plans come with a 14-day free trial. No credit card required to start.',
  },
  {
    question: 'What happens if I exceed my word limit?',
    answer: 'On the Free plan, you\'ll need to wait until next month or upgrade. On paid plans, you can purchase additional words as needed.',
  },
  {
    question: 'Do you offer discounts for annual billing?',
    answer: 'Yes! Save 20% when you choose annual billing on any paid plan.',
  },
  {
    question: 'Can I get a refund?',
    answer: 'We offer a 30-day money-back guarantee on all paid plans. If you\'re not satisfied, contact us for a full refund.',
  },
] as const;

/**
 * Pricing page component
 */
export default function PricingPage() {
  return (
    <>
      {/* Hero Section */}
      <section className="relative overflow-hidden py-24 md:py-32">
        {/* Background */}
        <div className="absolute inset-0 bg-gradient-to-b from-amber-50/50 via-transparent to-transparent" />
        
        <div className="container mx-auto px-4 sm:px-6 lg:px-8 relative">
          <div className="max-w-3xl mx-auto text-center">
            <Badge variant="amber" className="mb-6">Pricing</Badge>
            <h1 className="font-sans text-4xl md:text-5xl lg:text-6xl font-bold text-ink-900 mb-6">
              Simple, transparent pricing
            </h1>
            <p className="text-lg md:text-xl text-ink-600 leading-relaxed">
              Start free and scale as you grow. No hidden fees, no surprises.
            </p>
          </div>
        </div>
      </section>

      {/* Pricing Cards */}
      <section className="py-16 md:py-24">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          <div className="grid md:grid-cols-3 gap-8 max-w-6xl mx-auto">
            {pricingTiers.map((tier) => (
              <Card 
                key={tier.name}
                className={cn(
                  'relative flex flex-col',
                  tier.highlighted 
                    ? 'border-amber-400 shadow-xl scale-105 z-10' 
                    : 'border-border/50'
                )}
              >
                {tier.highlighted && (
                  <div className="absolute -top-4 left-1/2 -translate-x-1/2">
                    <Badge variant="amber" className="shadow-lg">
                      Most Popular
                    </Badge>
                  </div>
                )}
                
                <CardHeader className="pb-4">
                  <CardTitle className="font-sans text-2xl">{tier.name}</CardTitle>
                  <CardDescription>{tier.description}</CardDescription>
                </CardHeader>
                
                <CardContent className="flex-1">
                  {/* Price */}
                  <div className="mb-6">
                    <span className="font-sans text-5xl font-bold text-ink-900">
                      {tier.price}
                    </span>
                    <span className="text-ink-500 ml-2">
                      {tier.period}
                    </span>
                  </div>
                  
                  {/* Features */}
                  <ul className="space-y-3">
                    {tier.features.map((feature) => (
                      <li 
                        key={feature.name}
                        className="flex items-start gap-3"
                      >
                        {feature.included ? (
                          <Check className="h-5 w-5 text-green-500 shrink-0 mt-0.5" />
                        ) : (
                          <X className="h-5 w-5 text-ink-300 shrink-0 mt-0.5" />
                        )}
                        <span className={cn(
                          'text-sm',
                          feature.included ? 'text-ink-700' : 'text-ink-400'
                        )}>
                          {feature.name}
                        </span>
                      </li>
                    ))}
                  </ul>
                </CardContent>
                
                <CardFooter className="pt-4">
                  <Button 
                    variant={tier.ctaVariant} 
                    className="w-full" 
                    size="lg"
                    asChild
                  >
                    <Link href="/sign-up">{tier.cta}</Link>
                  </Button>
                </CardFooter>
              </Card>
            ))}
          </div>
        </div>
      </section>

      {/* Enterprise Section */}
      <section className="py-16 bg-ink-950 text-white">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          <div className="max-w-4xl mx-auto text-center">
            <Badge variant="outline" className="mb-4 border-amber-500/30 text-amber-400">
              Enterprise
            </Badge>
            <h2 className="font-sans text-3xl md:text-4xl font-bold mb-4">
              Need more? Let&apos;s talk.
            </h2>
            <p className="text-ink-300 mb-8 max-w-2xl mx-auto">
              For larger teams with custom requirements, we offer tailored solutions 
              with dedicated support, custom integrations, and volume discounts.
            </p>
            <Button variant="amber" size="lg" asChild>
              <Link href="mailto:sales@copyworx.app">Contact Sales</Link>
            </Button>
          </div>
        </div>
      </section>

      {/* FAQ Section */}
      <section className="py-24 md:py-32 bg-gradient-to-b from-white to-ink-50/50">
        <div className="container mx-auto px-4 sm:px-6 lg:px-8">
          <div className="max-w-3xl mx-auto">
            {/* Section Header */}
            <div className="text-center mb-12">
              <Badge variant="secondary" className="mb-4">FAQ</Badge>
              <h2 className="font-sans text-3xl md:text-4xl font-bold text-ink-900 mb-4">
                Frequently asked questions
              </h2>
              <p className="text-ink-600">
                Can&apos;t find what you&apos;re looking for?{' '}
                <Link href="mailto:support@copyworx.app" className="text-amber-600 hover:underline">
                  Contact our support team
                </Link>
              </p>
            </div>
            
            {/* FAQ Items */}
            <div className="space-y-4">
              {faqItems.map((item) => (
                <Card key={item.question} className="border-border/50">
                  <CardContent className="p-6">
                    <div className="flex gap-4">
                      <HelpCircle className="h-5 w-5 text-amber-500 shrink-0 mt-0.5" />
                      <div>
                        <h3 className="font-semibold text-ink-900 mb-2">
                          {item.question}
                        </h3>
                        <p className="text-ink-600 text-sm leading-relaxed">
                          {item.answer}
                        </p>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          </div>
        </div>
      </section>
    </>
  );
}



=== FILE: app/admin/usage/page.tsx ===

/**
 * @file app/admin/usage/page.tsx
 * @description Admin dashboard for viewing all users' API usage
 * 
 * Features:
 * - Protected by admin email check
 * - Displays all users' usage in a sortable table
 * - Summary statistics at top
 * - Search/filter functionality
 * - Export to CSV
 * - Mobile responsive
 * 
 * @route /admin/usage
 * @access Admin only (michaelfriend55@gmail.com)
 */

'use client';

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { useUser } from '@clerk/nextjs';
import { 
  RefreshCw, 
  Download, 
  Search, 
  AlertTriangle, 
  Users, 
  DollarSign, 
  TrendingUp,
  Shield,
  ArrowUpDown,
  ChevronUp,
  ChevronDown,
} from 'lucide-react';
import { cn } from '@/lib/utils';

// ============================================================================
// Constants
// ============================================================================

/** Admin email addresses */
const ADMIN_EMAILS = ['michaelfriend55@gmail.com'];

/** Beta usage limit */
const BETA_LIMIT = 5.00;

// ============================================================================
// Types
// ============================================================================

interface UserUsageRecord {
  userId: string;
  totalApiCalls: number;
  totalInputTokens: number;
  totalOutputTokens: number;
  totalTokens: number;
  totalCost: number;
  lastApiCall: string | null;
  percentOfLimit: number;
  isOverLimit: boolean;
}

interface UsageSummary {
  totalUsers: number;
  totalCost: number;
  averageCostPerUser: number;
  usersOverLimit: number;
}

interface AdminUsageData {
  users: UserUsageRecord[];
  summary: UsageSummary;
  fetchedAt: string;
}

type SortField = 'userId' | 'totalApiCalls' | 'totalTokens' | 'totalCost' | 'lastApiCall' | 'percentOfLimit';
type SortDirection = 'asc' | 'desc';

// ============================================================================
// Helper Components
// ============================================================================

/**
 * Access Denied component for non-admin users
 */
function AccessDenied() {
  return (
    <div className="min-h-screen bg-ink-50 flex items-center justify-center p-4">
      <div className="bg-white rounded-xl shadow-lg p-8 max-w-md text-center">
        <div className="w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4">
          <Shield className="w-8 h-8 text-red-600" />
        </div>
        <h1 className="text-2xl font-bold text-ink-900 mb-2">Access Denied</h1>
        <p className="text-ink-600 mb-4">
          You don&apos;t have permission to view this page. This area is restricted to administrators only.
        </p>
        <a 
          href="/home" 
          className="inline-flex items-center px-4 py-2 bg-ink-900 text-white rounded-lg hover:bg-ink-800 transition-colors"
        >
          Return to App Home
        </a>
      </div>
    </div>
  );
}

/**
 * Loading skeleton for the table
 */
function LoadingSkeleton() {
  return (
    <div className="animate-pulse space-y-4">
      {/* Summary cards skeleton */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
        {[...Array(4)].map((_, i) => (
          <div key={i} className="bg-white rounded-xl p-6 shadow-sm">
            <div className="h-4 w-20 bg-ink-200 rounded mb-2" />
            <div className="h-8 w-24 bg-ink-200 rounded" />
          </div>
        ))}
      </div>
      
      {/* Table skeleton */}
      <div className="bg-white rounded-xl shadow-sm overflow-hidden">
        <div className="h-12 bg-ink-100" />
        {[...Array(5)].map((_, i) => (
          <div key={i} className="h-16 border-t border-ink-100 flex items-center px-6 gap-4">
            <div className="h-4 w-24 bg-ink-200 rounded" />
            <div className="h-4 w-16 bg-ink-200 rounded" />
            <div className="h-4 w-20 bg-ink-200 rounded" />
            <div className="h-4 w-16 bg-ink-200 rounded" />
          </div>
        ))}
      </div>
    </div>
  );
}

/**
 * Summary card component
 */
function SummaryCard({ 
  title, 
  value, 
  icon: Icon, 
  color = 'blue',
  subtitle,
}: { 
  title: string; 
  value: string | number; 
  icon: React.ElementType;
  color?: 'blue' | 'green' | 'amber' | 'red';
  subtitle?: string;
}) {
  const colorClasses = {
    blue: 'bg-blue-50 text-blue-600',
    green: 'bg-emerald-50 text-emerald-600',
    amber: 'bg-amber-50 text-amber-600',
    red: 'bg-red-50 text-red-600',
  };

  return (
    <div className="bg-white rounded-xl p-6 shadow-sm border border-ink-100">
      <div className="flex items-center gap-3 mb-2">
        <div className={cn('w-10 h-10 rounded-lg flex items-center justify-center', colorClasses[color])}>
          <Icon className="w-5 h-5" />
        </div>
        <span className="text-sm font-medium text-ink-500 uppercase tracking-wide">{title}</span>
      </div>
      <p className="text-2xl font-bold text-ink-900">{value}</p>
      {subtitle && <p className="text-sm text-ink-500 mt-1">{subtitle}</p>}
    </div>
  );
}

/**
 * Status badge component
 */
function StatusBadge({ isOverLimit }: { isOverLimit: boolean }) {
  return (
    <span className={cn(
      'inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-semibold',
      isOverLimit 
        ? 'bg-red-100 text-red-800' 
        : 'bg-emerald-100 text-emerald-800'
    )}>
      {isOverLimit ? 'Limited' : 'Active'}
    </span>
  );
}

/**
 * Sortable column header
 */
function SortHeader({ 
  label, 
  field, 
  currentSort, 
  currentDirection, 
  onSort,
}: { 
  label: string; 
  field: SortField;
  currentSort: SortField;
  currentDirection: SortDirection;
  onSort: (field: SortField) => void;
}) {
  const isActive = currentSort === field;
  
  return (
    <button
      onClick={() => onSort(field)}
      className={cn(
        'flex items-center gap-1 text-left font-semibold text-xs uppercase tracking-wide transition-colors',
        isActive ? 'text-ink-900' : 'text-ink-500 hover:text-ink-700'
      )}
    >
      {label}
      <span className="flex flex-col">
        <ChevronUp className={cn(
          'w-3 h-3 -mb-1',
          isActive && currentDirection === 'asc' ? 'text-ink-900' : 'text-ink-300'
        )} />
        <ChevronDown className={cn(
          'w-3 h-3 -mt-1',
          isActive && currentDirection === 'desc' ? 'text-ink-900' : 'text-ink-300'
        )} />
      </span>
    </button>
  );
}

// ============================================================================
// Main Component
// ============================================================================

/**
 * Admin Usage Dashboard Page
 */
export default function AdminUsagePage() {
  // Auth state
  const { user, isLoaded: isUserLoaded } = useUser();
  
  // Data state
  const [data, setData] = useState<AdminUsageData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  // UI state
  const [searchQuery, setSearchQuery] = useState('');
  const [sortField, setSortField] = useState<SortField>('totalCost');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');

  // ============================================================================
  // Auth Check
  // ============================================================================
  
  const isAdmin = useMemo(() => {
    if (!user) return false;
    const email = user.emailAddresses?.[0]?.emailAddress?.toLowerCase();
    return email ? ADMIN_EMAILS.includes(email) : false;
  }, [user]);

  // ============================================================================
  // Data Fetching
  // ============================================================================
  
  const fetchUsageData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const response = await fetch('/api/admin/usage');
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.details || errorData.error || 'Failed to fetch data');
      }
      
      const result: AdminUsageData = await response.json();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Fetch on mount (if admin)
  useEffect(() => {
    if (isUserLoaded && isAdmin) {
      fetchUsageData();
    } else if (isUserLoaded && !isAdmin) {
      setIsLoading(false);
    }
  }, [isUserLoaded, isAdmin, fetchUsageData]);

  // ============================================================================
  // Sorting & Filtering
  // ============================================================================
  
  const handleSort = useCallback((field: SortField) => {
    if (sortField === field) {
      setSortDirection(prev => prev === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('desc');
    }
  }, [sortField]);

  const filteredAndSortedUsers = useMemo(() => {
    if (!data?.users) return [];
    
    let result = [...data.users];
    
    // Filter by search query
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      result = result.filter(user => 
        user.userId.toLowerCase().includes(query)
      );
    }
    
    // Sort
    result.sort((a, b) => {
      let aVal: any = a[sortField];
      let bVal: any = b[sortField];
      
      // Handle null dates
      if (sortField === 'lastApiCall') {
        aVal = aVal ? new Date(aVal).getTime() : 0;
        bVal = bVal ? new Date(bVal).getTime() : 0;
      }
      
      if (sortDirection === 'asc') {
        return aVal > bVal ? 1 : -1;
      }
      return aVal < bVal ? 1 : -1;
    });
    
    return result;
  }, [data?.users, searchQuery, sortField, sortDirection]);

  // ============================================================================
  // Export to CSV
  // ============================================================================
  
  const exportToCsv = useCallback(() => {
    if (!data?.users) return;
    
    const headers = [
      'User ID',
      'Total API Calls',
      'Total Tokens',
      'Total Cost (USD)',
      '% of Limit',
      'Last Used',
      'Status',
    ];
    
    const rows = data.users.map(user => [
      user.userId,
      user.totalApiCalls.toString(),
      user.totalTokens.toString(),
      user.totalCost.toFixed(4),
      user.percentOfLimit.toFixed(1),
      user.lastApiCall ? new Date(user.lastApiCall).toISOString() : 'Never',
      user.isOverLimit ? 'Limited' : 'Active',
    ]);
    
    const csvContent = [
      headers.join(','),
      ...rows.map(row => row.join(',')),
    ].join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `copyworx-usage-${new Date().toISOString().split('T')[0]}.csv`;
    link.click();
    URL.revokeObjectURL(url);
  }, [data?.users]);

  // ============================================================================
  // Format Helpers
  // ============================================================================
  
  const formatCurrency = (amount: number): string => {
    return `$${amount.toFixed(2)}`;
  };

  const formatDate = (dateStr: string | null): string => {
    if (!dateStr) return 'Never';
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const truncateUserId = (userId: string): string => {
    return userId.length > 12 ? `${userId.substring(0, 8)}...` : userId;
  };

  // ============================================================================
  // Render
  // ============================================================================
  
  // Show loading while checking auth
  if (!isUserLoaded) {
    return (
      <div className="min-h-screen bg-ink-50 flex items-center justify-center">
        <div className="w-8 h-8 border-2 border-ink-900 border-t-transparent rounded-full animate-spin" />
      </div>
    );
  }

  // Show access denied for non-admins
  if (!isAdmin) {
    return <AccessDenied />;
  }

  return (
    <div className="min-h-screen bg-ink-50">
      {/* Header */}
      <header className="bg-white border-b border-ink-200 sticky top-0 z-10">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
            <div>
              <h1 className="text-2xl font-bold text-ink-900">API Usage Dashboard</h1>
              <p className="text-sm text-ink-500 mt-1">
                Monitor beta user API consumption
                {data?.fetchedAt && (
                  <span className="ml-2">
                    ‚Ä¢ Last updated: {formatDate(data.fetchedAt)}
                  </span>
                )}
              </p>
            </div>
            
            <div className="flex items-center gap-3">
              <button
                onClick={exportToCsv}
                disabled={!data?.users?.length}
                className={cn(
                  'inline-flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-colors',
                  'border border-ink-200 bg-white text-ink-700 hover:bg-ink-50',
                  'disabled:opacity-50 disabled:cursor-not-allowed'
                )}
              >
                <Download className="w-4 h-4" />
                Export CSV
              </button>
              
              <button
                onClick={fetchUsageData}
                disabled={isLoading}
                className={cn(
                  'inline-flex items-center gap-2 px-4 py-2 rounded-lg text-sm font-medium transition-colors',
                  'bg-ink-900 text-white hover:bg-ink-800',
                  'disabled:opacity-50 disabled:cursor-not-allowed'
                )}
              >
                <RefreshCw className={cn('w-4 h-4', isLoading && 'animate-spin')} />
                Refresh
              </button>
            </div>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {isLoading ? (
          <LoadingSkeleton />
        ) : error ? (
          <div className="bg-red-50 border border-red-200 rounded-xl p-6 text-center">
            <AlertTriangle className="w-12 h-12 text-red-500 mx-auto mb-4" />
            <h2 className="text-lg font-semibold text-red-800 mb-2">Error Loading Data</h2>
            <p className="text-red-600 mb-4">{error}</p>
            <button
              onClick={fetchUsageData}
              className="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors"
            >
              Try Again
            </button>
          </div>
        ) : data ? (
          <>
            {/* Summary Cards */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
              <SummaryCard
                title="Total Users"
                value={data.summary.totalUsers}
                icon={Users}
                color="blue"
              />
              <SummaryCard
                title="Total Cost"
                value={formatCurrency(data.summary.totalCost)}
                icon={DollarSign}
                color="green"
              />
              <SummaryCard
                title="Avg per User"
                value={formatCurrency(data.summary.averageCostPerUser)}
                icon={TrendingUp}
                color="amber"
              />
              <SummaryCard
                title="Over Limit"
                value={data.summary.usersOverLimit}
                icon={AlertTriangle}
                color="red"
                subtitle={`of ${data.summary.totalUsers} users`}
              />
            </div>

            {/* Search & Filter */}
            <div className="bg-white rounded-xl shadow-sm border border-ink-100 mb-6">
              <div className="p-4 border-b border-ink-100">
                <div className="relative max-w-md">
                  <Search className="absolute left-3 top-1/2 -translate-y-1/2 w-5 h-5 text-ink-400" />
                  <input
                    type="text"
                    placeholder="Search by User ID..."
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    className={cn(
                      'w-full pl-10 pr-4 py-2 rounded-lg border border-ink-200',
                      'text-sm text-ink-900 placeholder:text-ink-400',
                      'focus:outline-none focus:ring-2 focus:ring-ink-900 focus:border-transparent'
                    )}
                  />
                </div>
              </div>

              {/* Table */}
              <div className="overflow-x-auto">
                <table className="w-full">
                  <thead>
                    <tr className="bg-ink-50 border-b border-ink-100">
                      <th className="px-6 py-3 text-left">
                        <SortHeader
                          label="User ID"
                          field="userId"
                          currentSort={sortField}
                          currentDirection={sortDirection}
                          onSort={handleSort}
                        />
                      </th>
                      <th className="px-6 py-3 text-left">
                        <SortHeader
                          label="API Calls"
                          field="totalApiCalls"
                          currentSort={sortField}
                          currentDirection={sortDirection}
                          onSort={handleSort}
                        />
                      </th>
                      <th className="px-6 py-3 text-left">
                        <SortHeader
                          label="Tokens"
                          field="totalTokens"
                          currentSort={sortField}
                          currentDirection={sortDirection}
                          onSort={handleSort}
                        />
                      </th>
                      <th className="px-6 py-3 text-left">
                        <SortHeader
                          label="Cost"
                          field="totalCost"
                          currentSort={sortField}
                          currentDirection={sortDirection}
                          onSort={handleSort}
                        />
                      </th>
                      <th className="px-6 py-3 text-left">
                        <SortHeader
                          label="% of Limit"
                          field="percentOfLimit"
                          currentSort={sortField}
                          currentDirection={sortDirection}
                          onSort={handleSort}
                        />
                      </th>
                      <th className="px-6 py-3 text-left">
                        <SortHeader
                          label="Last Used"
                          field="lastApiCall"
                          currentSort={sortField}
                          currentDirection={sortDirection}
                          onSort={handleSort}
                        />
                      </th>
                      <th className="px-6 py-3 text-left">
                        <span className="font-semibold text-xs uppercase tracking-wide text-ink-500">
                          Status
                        </span>
                      </th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-ink-100">
                    {filteredAndSortedUsers.length === 0 ? (
                      <tr>
                        <td colSpan={7} className="px-6 py-12 text-center text-ink-500">
                          {searchQuery ? 'No users match your search' : 'No usage data yet'}
                        </td>
                      </tr>
                    ) : (
                      filteredAndSortedUsers.map((user) => (
                        <tr 
                          key={user.userId} 
                          className={cn(
                            'hover:bg-ink-50 transition-colors',
                            user.isOverLimit && 'bg-red-50/50'
                          )}
                        >
                          <td className="px-6 py-4">
                            <span 
                              className="font-mono text-sm text-ink-700"
                              title={user.userId}
                            >
                              {truncateUserId(user.userId)}
                            </span>
                          </td>
                          <td className="px-6 py-4 text-sm text-ink-600">
                            {user.totalApiCalls.toLocaleString()}
                          </td>
                          <td className="px-6 py-4 text-sm text-ink-600">
                            {user.totalTokens.toLocaleString()}
                          </td>
                          <td className="px-6 py-4">
                            <span className={cn(
                              'text-sm font-medium',
                              user.isOverLimit ? 'text-red-600' : 'text-ink-900'
                            )}>
                              {formatCurrency(user.totalCost)}
                            </span>
                          </td>
                          <td className="px-6 py-4">
                            <div className="flex items-center gap-2">
                              <div className="w-16 h-2 bg-ink-200 rounded-full overflow-hidden">
                                <div
                                  className={cn(
                                    'h-full rounded-full transition-all',
                                    user.percentOfLimit >= 100 ? 'bg-red-500' :
                                    user.percentOfLimit >= 80 ? 'bg-amber-500' :
                                    user.percentOfLimit >= 50 ? 'bg-yellow-500' :
                                    'bg-emerald-500'
                                  )}
                                  style={{ width: `${Math.min(user.percentOfLimit, 100)}%` }}
                                />
                              </div>
                              <span className={cn(
                                'text-xs font-medium',
                                user.percentOfLimit >= 100 ? 'text-red-600' : 'text-ink-500'
                              )}>
                                {user.percentOfLimit.toFixed(0)}%
                              </span>
                            </div>
                          </td>
                          <td className="px-6 py-4 text-sm text-ink-500">
                            {formatDate(user.lastApiCall)}
                          </td>
                          <td className="px-6 py-4">
                            <StatusBadge isOverLimit={user.isOverLimit} />
                          </td>
                        </tr>
                      ))
                    )}
                  </tbody>
                </table>
              </div>

              {/* Table Footer */}
              {filteredAndSortedUsers.length > 0 && (
                <div className="px-6 py-3 bg-ink-50 border-t border-ink-100 text-sm text-ink-500">
                  Showing {filteredAndSortedUsers.length} of {data.users.length} users
                </div>
              )}
            </div>
          </>
        ) : null}
      </main>
    </div>
  );
}


=== FILE: app/api/admin/usage/route.ts ===

/**
 * @file app/api/admin/usage/route.ts
 * @description Admin API route to fetch all users' API usage statistics
 * 
 * Protected endpoint - only accessible to admin users.
 * Returns aggregated usage data for all users from api_usage_logs.
 * 
 * @endpoint GET /api/admin/usage
 * @auth Required (Admin only)
 */

import { NextResponse } from 'next/server';
import { auth, currentUser } from '@clerk/nextjs/server';
import { supabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { logger } from '@/lib/utils/logger';

// ============================================================================
// Constants
// ============================================================================

/** Admin email addresses that can access this endpoint */
const ADMIN_EMAILS = ['michaelfriend55@gmail.com'];

// ============================================================================
// Types
// ============================================================================

/**
 * User usage record structure
 */
interface UserUsageRecord {
  userId: string;
  totalApiCalls: number;
  totalInputTokens: number;
  totalOutputTokens: number;
  totalTokens: number;
  totalCost: number;
  lastApiCall: string | null;
  percentOfLimit: number;
  isOverLimit: boolean;
}

/**
 * Success response structure
 */
interface AdminUsageResponse {
  users: UserUsageRecord[];
  summary: {
    totalUsers: number;
    totalCost: number;
    averageCostPerUser: number;
    usersOverLimit: number;
  };
  fetchedAt: string;
}

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * GET /api/admin/usage
 * 
 * Fetches all users' API usage statistics for admin dashboard.
 * Only accessible to admin users defined in ADMIN_EMAILS.
 */
export async function GET(): Promise<NextResponse<AdminUsageResponse | ErrorResponse>> {
  try {
    // ------------------------------------------------------------------------
    // 1. Verify admin access
    // ------------------------------------------------------------------------
    
    const { userId } = await auth();
    
    if (!userId) {
      return NextResponse.json<ErrorResponse>(
        { error: 'Unauthorized', details: 'You must be logged in' },
        { status: 401 }
      );
    }

    // Get current user's email
    const user = await currentUser();
    const userEmail = user?.emailAddresses?.[0]?.emailAddress;

    if (!userEmail || !ADMIN_EMAILS.includes(userEmail.toLowerCase())) {
      logger.log('üö´ Non-admin user attempted to access admin usage:', {
        userId: userId.substring(0, 8) + '...',
        email: userEmail || 'unknown',
      });
      
      return NextResponse.json<ErrorResponse>(
        { error: 'Forbidden', details: 'Admin access required' },
        { status: 403 }
      );
    }

    logger.log('‚úÖ Admin access granted:', userEmail);

    // ------------------------------------------------------------------------
    // 2. Check Supabase configuration
    // ------------------------------------------------------------------------
    
    if (!isSupabaseConfigured() || !supabaseAdmin) {
      return NextResponse.json<ErrorResponse>(
        { error: 'Service unavailable', details: 'Database not configured' },
        { status: 503 }
      );
    }

    // ------------------------------------------------------------------------
    // 3. Fetch all users' usage from user_usage_summary view
    // ------------------------------------------------------------------------
    
    const { data, error } = await (supabaseAdmin
      .from('user_usage_summary') as any)
      .select('*')
      .order('total_cost_usd', { ascending: false });

    if (error) {
      logger.error('‚ùå Failed to fetch admin usage data:', error);
      return NextResponse.json<ErrorResponse>(
        { error: 'Database error', details: 'Failed to fetch usage data' },
        { status: 500 }
      );
    }

    // ------------------------------------------------------------------------
    // 4. Transform data and calculate summary
    // ------------------------------------------------------------------------
    
    const BETA_LIMIT = 5.00;
    
    const users: UserUsageRecord[] = (data || []).map((row: any) => ({
      userId: row.user_id,
      totalApiCalls: row.total_api_calls || 0,
      totalInputTokens: row.total_input_tokens || 0,
      totalOutputTokens: row.total_output_tokens || 0,
      totalTokens: row.total_tokens_used || 0,
      totalCost: row.total_cost_usd || 0,
      lastApiCall: row.last_api_call || null,
      percentOfLimit: ((row.total_cost_usd || 0) / BETA_LIMIT) * 100,
      isOverLimit: (row.total_cost_usd || 0) >= BETA_LIMIT,
    }));

    const totalCost = users.reduce((sum, u) => sum + u.totalCost, 0);
    const usersOverLimit = users.filter(u => u.isOverLimit).length;

    const summary = {
      totalUsers: users.length,
      totalCost,
      averageCostPerUser: users.length > 0 ? totalCost / users.length : 0,
      usersOverLimit,
    };

    logger.log('üìä Admin usage data fetched:', {
      totalUsers: summary.totalUsers,
      totalCost: `$${summary.totalCost.toFixed(4)}`,
    });

    // ------------------------------------------------------------------------
    // 5. Return response
    // ------------------------------------------------------------------------
    
    return NextResponse.json<AdminUsageResponse>({
      users,
      summary,
      fetchedAt: new Date().toISOString(),
    });

  } catch (error) {
    logger.error('‚ùå Unexpected error in admin usage API:', error);
    
    return NextResponse.json<ErrorResponse>(
      {
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}


=== FILE: app/api/brand-alignment/route.ts ===

/**
 * @file app/api/brand-alignment/route.ts
 * @description API route for checking copy alignment with brand voice using Claude AI
 * 
 * This endpoint accepts text and brand voice configuration, then uses Claude to analyze
 * how well the copy aligns with the defined brand voice guidelines.
 */

import { NextRequest, NextResponse } from 'next/server';
import Anthropic from '@anthropic-ai/sdk';
import type { BrandVoice, BrandAlignmentResult, BrandAlignmentRequest, BrandAlignmentResponse } from '@/lib/types/brand';
import { validateTextLength, validateNotEmpty, logError } from '@/lib/utils/error-handling';
import { logger } from '@/lib/utils/logger';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

// ============================================================================
// Constants
// ============================================================================

/**
 * System prompt that establishes Claude's role as a brand voice analyst
 */
const SYSTEM_PROMPT = `You are an expert brand voice analyst with 40 years of experience. Your job is to analyze copy and assess how well it aligns with a given brand voice.

When analyzing:
- Check for tone consistency with brand guidelines
- Identify usage of approved phrases
- Flag any forbidden words or phrases
- Assess alignment with brand values
- Consider mission statement alignment
- Provide specific, actionable recommendations

Be thorough, objective, and provide constructive feedback.`;

/**
 * Generates a user prompt with the text and brand voice to analyze
 */
function buildUserPrompt(text: string, brandVoice: BrandVoice): string {
  return `Analyze the following copy for brand voice alignment.

BRAND VOICE GUIDELINES:
Brand Name: ${brandVoice.brandName}
Tone: ${brandVoice.brandTone || 'Not specified'}
Mission: ${brandVoice.missionStatement || 'Not specified'}

${brandVoice.brandValues.length > 0 ? `Brand Values:\n${brandVoice.brandValues.map(v => `- ${v}`).join('\n')}` : ''}

${brandVoice.approvedPhrases.length > 0 ? `Approved Phrases:\n${brandVoice.approvedPhrases.map(p => `- ${p}`).join('\n')}` : ''}

${brandVoice.forbiddenWords.length > 0 ? `Forbidden Words/Phrases:\n${brandVoice.forbiddenWords.map(w => `- ${w}`).join('\n')}` : ''}

COPY TO ANALYZE:
${text}

Please provide your analysis in the following JSON format:
{
  "score": [0-100 numeric score],
  "assessment": "[overall assessment in 1-2 sentences]",
  "matches": ["list", "of", "things", "that", "match", "brand", "voice"],
  "violations": ["list", "of", "things", "that", "violate", "brand", "voice"],
  "recommendations": ["specific", "actionable", "recommendations"]
}

Return ONLY the JSON object, no other text.`;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * POST /api/brand-alignment
 * 
 * Checks copy alignment with brand voice using Claude AI
 * 
 * @param request - Next.js request object containing text and brandVoice
 * @returns JSON response with alignment analysis or error
 */
export async function POST(request: NextRequest): Promise<NextResponse<BrandAlignmentResponse | ErrorResponse>> {
  try {
    // ------------------------------------------------------------------------
    // 1. Parse and validate request body
    // ------------------------------------------------------------------------
    
    let body: Partial<BrandAlignmentRequest>;
    
    try {
      body = await request.json();
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid JSON in request body',
          details: 'Please send valid JSON with "text" and "brandVoice" fields'
        },
        { status: 400 }
      );
    }

    const { text, brandVoice } = body;

    // Validate required fields
    if (!text || typeof text !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "text" field',
          details: 'Please provide the copy to analyze as a string in the "text" field'
        },
        { status: 400 }
      );
    }

    if (!brandVoice || typeof brandVoice !== 'object') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "brandVoice" field',
          details: 'Please provide brand voice configuration'
        },
        { status: 400 }
      );
    }

    // Validate brand voice has required fields
    if (!brandVoice.brandName) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid brand voice',
          details: 'Brand voice must include brandName'
        },
        { status: 400 }
      );
    }

    // Validate text
    try {
      validateNotEmpty(text, 'Text');
      validateTextLength(text, 'Text');
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid text',
          details: error instanceof Error ? error.message : 'Please provide valid text to analyze'
        },
        { status: 400 }
      );
    }

    // ------------------------------------------------------------------------
    // 2. Initialize Anthropic client
    // ------------------------------------------------------------------------
    
    // Read API key from environment variables
    const apiKey = process.env.ANTHROPIC_API_KEY;
    
    if (!apiKey) {
      logger.error('‚ùå ANTHROPIC_API_KEY not found in environment variables');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Server configuration error',
          details: 'API key not configured. Please contact support.'
        },
        { status: 500 }
      );
    }

    // Create Anthropic client instance
    const anthropic = new Anthropic({
      apiKey: apiKey,
    });

    // ------------------------------------------------------------------------
    // 3. Call Claude API to analyze the text
    // ------------------------------------------------------------------------
    
    logger.log('üìù Brand alignment request:', {
      textLength: text.length,
      brandName: brandVoice.brandName,
      preview: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
    });

    // Build the user prompt with the text and brand voice
    const userPrompt = buildUserPrompt(text, brandVoice as BrandVoice);

    // Call Claude's Messages API with timeout
    const message = await Promise.race([
      anthropic.messages.create({
        model: 'claude-sonnet-4-20250514', // Latest Claude Sonnet model
        max_tokens: 4000, // Maximum length of response
        system: SYSTEM_PROMPT, // System prompt defining Claude's role
        messages: [
          {
            role: 'user',
            content: userPrompt, // The actual analysis request
          },
        ],
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Request timed out after 30 seconds')), 30000)
      ),
    ]);

    // ------------------------------------------------------------------------
    // 4. Extract and process the response
    // ------------------------------------------------------------------------
    
    // Claude returns an array of content blocks; we want the text from the first one
    const responseText = message.content[0].type === 'text' 
      ? message.content[0].text.trim()
      : '';

    if (!responseText) {
      logger.error('‚ùå Claude returned empty response');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'Claude returned an empty response. Please try again.'
        },
        { status: 500 }
      );
    }

    // Parse the JSON response from Claude
    let result: BrandAlignmentResult;
    try {
      // Remove any markdown code blocks if present
      const cleanedResponse = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '');
      result = JSON.parse(cleanedResponse);
      
      // Validate result structure
      if (typeof result.score !== 'number' || !result.assessment) {
        throw new Error('Invalid result format');
      }
      
      // Ensure arrays exist
      result.matches = result.matches || [];
      result.violations = result.violations || [];
      result.recommendations = result.recommendations || [];
      
    } catch (error) {
      logger.error('‚ùå Failed to parse Claude response:', error);
      logger.error('Raw response:', responseText);
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'Failed to parse AI response. Please try again.'
        },
        { status: 500 }
      );
    }

    logger.log('‚úÖ Brand alignment analysis complete:', {
      score: result.score,
      matchesCount: result.matches.length,
      violationsCount: result.violations.length,
      recommendationsCount: result.recommendations.length,
    });

    // ------------------------------------------------------------------------
    // 5. Return the analysis result
    // ------------------------------------------------------------------------
    
    return NextResponse.json<BrandAlignmentResponse>(
      {
        result,
        textLength: text.length,
        brandName: brandVoice.brandName,
      },
      { status: 200 }
    );

  } catch (error) {
    // ------------------------------------------------------------------------
    // Error Handling
    // ------------------------------------------------------------------------
    
    logError(error, 'Brand alignment API');

    // Handle timeout errors
    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Request timeout',
          details: 'The analysis took too long. Please try again with shorter text.'
        },
        { status: 408 }
      );
    }

    // Handle Anthropic-specific errors
    if (error instanceof Anthropic.APIError) {
      let userMessage = 'AI service error. Please try again.';
      
      if (error.status === 429) {
        userMessage = 'Rate limit exceeded. Please wait a moment and try again.';
      } else if (error.status === 500 || error.status === 503) {
        userMessage = 'AI service temporarily unavailable. Please try again in a moment.';
      }

      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI service error',
          details: userMessage
        },
        { status: error.status || 500 }
      );
    }

    // Handle generic errors
    return NextResponse.json<ErrorResponse>(
      { 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'An unexpected error occurred. Please try again.'
      },
      { status: 500 }
    );
  }
}


=== FILE: app/api/claude/route.ts ===

/**
 * @file app/api/claude/route.ts
 * @description Centralized API route for Claude AI calls with usage tracking
 * 
 * This endpoint provides a single entry point for all Claude API interactions,
 * handling authentication, rate limiting (future), and automatic token usage logging.
 * 
 * Features:
 * - Automatic token usage logging to Supabase
 * - Cost calculation based on model pricing
 * - Feature-based tracking for analytics
 * - Graceful error handling (logging failures don't block responses)
 */

import { NextRequest, NextResponse } from 'next/server';
import Anthropic from '@anthropic-ai/sdk';
import { requireUserId, getUserId, unauthorizedResponse } from '@/lib/utils/api-auth';
import { supabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { logger } from '@/lib/utils/logger';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Supported Claude models with their pricing
 */
type ClaudeModel = 
  | 'claude-sonnet-4-20250514'
  | 'claude-sonnet-4-5-20250929'
  | 'claude-3-5-sonnet-20241022'
  | 'claude-3-opus-20240229'
  | 'claude-3-haiku-20240307';

/**
 * Message role for Claude API
 */
type MessageRole = 'user' | 'assistant';

/**
 * Single message in conversation
 */
export interface ClaudeMessage {
  role: MessageRole;
  content: string;
}

// Alias for internal use
type Message = ClaudeMessage;

/**
 * Valid feature identifiers for usage tracking
 * Add new features here as they're implemented
 */
export type ClaudeFeature =
  | 'tone_shifter'
  | 'expand'
  | 'shorten'
  | 'rewrite_channel'
  | 'brand_alignment'
  | 'persona_alignment'
  | 'analyze_document'
  | 'generate_template'
  | 'landing_page_hero'
  | 'sales_email'
  | 'brochure_section'
  | 'general';

/**
 * Request body structure
 */
export interface ClaudeRequest {
  /** Array of conversation messages */
  messages: Message[];
  /** System prompt for Claude */
  system?: string;
  /** Claude model to use (defaults to claude-sonnet-4-20250514) */
  model?: ClaudeModel;
  /** Maximum tokens in response */
  maxTokens?: number;
  /** Feature identifier for usage tracking (REQUIRED for analytics) */
  feature: ClaudeFeature;
  /** Temperature for response randomness (0-1) */
  temperature?: number;
}

/**
 * Validate that feature is a known type
 */
function isValidFeature(feature: string): feature is ClaudeFeature {
  const validFeatures: ClaudeFeature[] = [
    'tone_shifter', 'expand', 'shorten', 'rewrite_channel',
    'brand_alignment', 'persona_alignment', 'analyze_document',
    'generate_template', 'landing_page_hero', 'sales_email',
    'brochure_section', 'general'
  ];
  return validFeatures.includes(feature as ClaudeFeature);
}

/**
 * Response body structure
 */
export interface ClaudeResponse {
  /** Generated text content */
  text: string;
  /** Model used for generation */
  model: string;
  /** Token usage statistics */
  usage: {
    inputTokens: number;
    outputTokens: number;
    totalTokens: number;
  };
  /** Stop reason from Claude */
  stopReason: string | null;
}

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

/**
 * Model pricing configuration (USD per 1M tokens)
 */
interface ModelPricing {
  inputPerMillion: number;
  outputPerMillion: number;
}

// ============================================================================
// Constants
// ============================================================================

/**
 * Pricing for Claude models (USD per 1 million tokens)
 * Updated: January 2025
 * 
 * @see https://www.anthropic.com/pricing
 */
const MODEL_PRICING: Record<ClaudeModel, ModelPricing> = {
  'claude-sonnet-4-20250514': {
    inputPerMillion: 3.00,
    outputPerMillion: 15.00,
  },
  'claude-sonnet-4-5-20250929': {
    inputPerMillion: 3.00,
    outputPerMillion: 15.00,
  },
  'claude-3-5-sonnet-20241022': {
    inputPerMillion: 3.00,
    outputPerMillion: 15.00,
  },
  'claude-3-opus-20240229': {
    inputPerMillion: 15.00,
    outputPerMillion: 75.00,
  },
  'claude-3-haiku-20240307': {
    inputPerMillion: 0.25,
    outputPerMillion: 1.25,
  },
};

/** Default model to use if not specified */
const DEFAULT_MODEL: ClaudeModel = 'claude-sonnet-4-20250514';

/** Default max tokens if not specified */
const DEFAULT_MAX_TOKENS = 4096;

/** Request timeout in milliseconds */
const REQUEST_TIMEOUT_MS = 60000; // 60 seconds

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Calculate cost in USD for a Claude API call
 * 
 * @param model - The Claude model used
 * @param inputTokens - Number of input tokens
 * @param outputTokens - Number of output tokens
 * @returns Cost in USD (up to 6 decimal places)
 */
function calculateCost(
  model: ClaudeModel,
  inputTokens: number,
  outputTokens: number
): number {
  const pricing = MODEL_PRICING[model] || MODEL_PRICING[DEFAULT_MODEL];
  
  const inputCost = (inputTokens / 1_000_000) * pricing.inputPerMillion;
  const outputCost = (outputTokens / 1_000_000) * pricing.outputPerMillion;
  
  // Round to 6 decimal places to match DECIMAL(10,6) in database
  return Math.round((inputCost + outputCost) * 1_000_000) / 1_000_000;
}

/**
 * Log API usage to Supabase
 * 
 * This function is fire-and-forget - it logs errors but doesn't throw.
 * API responses should not fail due to logging issues.
 * 
 * @param userId - Clerk user ID
 * @param model - Claude model used
 * @param inputTokens - Number of input tokens
 * @param outputTokens - Number of output tokens
 * @param feature - Feature identifier
 * @param costUsd - Calculated cost in USD
 */
async function logUsageToSupabase(
  userId: string,
  model: string,
  inputTokens: number,
  outputTokens: number,
  feature: string,
  costUsd: number
): Promise<void> {
  // Skip logging if Supabase is not configured
  if (!isSupabaseConfigured() || !supabaseAdmin) {
    logger.log('‚ö†Ô∏è Supabase not configured, skipping usage logging');
    return;
  }

  try {
    const { error } = await (supabaseAdmin
      .from('api_usage_logs') as any)
      .insert({
        user_id: userId,
        model,
        input_tokens: inputTokens,
        output_tokens: outputTokens,
        feature,
        cost_usd: costUsd,
        // timestamp is auto-generated by database default
      });

    if (error) {
      logger.error('‚ùå Failed to log API usage:', error);
    } else {
      logger.log('üìä API usage logged:', {
        userId: userId.substring(0, 8) + '...',
        model,
        tokens: inputTokens + outputTokens,
        cost: `$${costUsd.toFixed(6)}`,
        feature,
      });
    }
  } catch (err) {
    // Log error but don't throw - this is fire-and-forget
    logger.error('‚ùå Exception logging API usage:', err);
  }
}

/**
 * Validate the Claude model is supported
 */
function isValidModel(model: string): model is ClaudeModel {
  return model in MODEL_PRICING;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * POST /api/claude
 * 
 * Centralized Claude API endpoint with automatic usage tracking
 * 
 * @param request - Next.js request object
 * @returns JSON response with generated text and usage stats
 * 
 * @example
 * ```typescript
 * const response = await fetch('/api/claude', {
 *   method: 'POST',
 *   headers: { 'Content-Type': 'application/json' },
 *   body: JSON.stringify({
 *     messages: [{ role: 'user', content: 'Hello!' }],
 *     system: 'You are a helpful assistant.',
 *     feature: 'chat',
 *   }),
 * });
 * ```
 */
export async function POST(
  request: NextRequest
): Promise<NextResponse<ClaudeResponse | ErrorResponse>> {
  // Track start time for logging
  const startTime = Date.now();
  
  try {
    // ------------------------------------------------------------------------
    // 1. Authenticate user
    // ------------------------------------------------------------------------
    
    let userId: string;
    
    try {
      userId = await requireUserId();
    } catch (error) {
      return unauthorizedResponse();
    }

    // ------------------------------------------------------------------------
    // 2. Parse and validate request body
    // ------------------------------------------------------------------------
    
    let body: Partial<ClaudeRequest>;
    
    try {
      body = await request.json();
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid JSON in request body',
          details: 'Please send valid JSON with a "messages" array'
        },
        { status: 400 }
      );
    }

    const { 
      messages, 
      system, 
      model = DEFAULT_MODEL,
      maxTokens = DEFAULT_MAX_TOKENS,
      feature,
      temperature,
    } = body;

    // Validate feature (required for analytics tracking)
    if (!feature || typeof feature !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing "feature" field',
          details: 'Please provide a feature identifier (e.g., "tone_shifter", "expand", "general")'
        },
        { status: 400 }
      );
    }

    // Validate feature is a known type (warn but don't block for unknown features)
    const validatedFeature = isValidFeature(feature) ? feature : 'general';
    if (!isValidFeature(feature)) {
      logger.log(`‚ö†Ô∏è Unknown feature "${feature}", logging as "general"`);
    }

    // Validate messages array
    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "messages" field',
          details: 'Please provide an array of messages with role and content'
        },
        { status: 400 }
      );
    }

    // Validate each message
    for (let i = 0; i < messages.length; i++) {
      const msg = messages[i];
      if (!msg.role || !msg.content) {
        return NextResponse.json<ErrorResponse>(
          { 
            error: `Invalid message at index ${i}`,
            details: 'Each message must have "role" and "content" fields'
          },
          { status: 400 }
        );
      }
      if (msg.role !== 'user' && msg.role !== 'assistant') {
        return NextResponse.json<ErrorResponse>(
          { 
            error: `Invalid role at index ${i}`,
            details: 'Message role must be "user" or "assistant"'
          },
          { status: 400 }
        );
      }
    }

    // Validate model
    const selectedModel: ClaudeModel = isValidModel(model) ? model : DEFAULT_MODEL;

    // ------------------------------------------------------------------------
    // 3. Initialize Anthropic client
    // ------------------------------------------------------------------------
    
    const apiKey = process.env.ANTHROPIC_API_KEY;
    
    if (!apiKey) {
      logger.error('‚ùå ANTHROPIC_API_KEY not found in environment variables');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Server configuration error',
          details: 'API key not configured. Please contact support.'
        },
        { status: 500 }
      );
    }

    const anthropic = new Anthropic({ apiKey });

    // ------------------------------------------------------------------------
    // 4. Call Claude API
    // ------------------------------------------------------------------------
    
    logger.log('ü§ñ Claude API request:', {
      userId: userId.substring(0, 8) + '...',
      model: selectedModel,
      messageCount: messages.length,
      feature: validatedFeature,
      hasSystemPrompt: !!system,
    });

    // Build request options
    const requestOptions: Anthropic.MessageCreateParams = {
      model: selectedModel,
      max_tokens: maxTokens,
      messages: messages.map(m => ({
        role: m.role,
        content: m.content,
      })),
    };

    // Add optional parameters
    if (system) {
      requestOptions.system = system;
    }
    if (temperature !== undefined) {
      requestOptions.temperature = temperature;
    }

    // Call with timeout
    const response = await Promise.race([
      anthropic.messages.create(requestOptions),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error(`Request timed out after ${REQUEST_TIMEOUT_MS / 1000} seconds`)),
          REQUEST_TIMEOUT_MS
        )
      ),
    ]);

    // ------------------------------------------------------------------------
    // 5. Extract response data
    // ------------------------------------------------------------------------
    
    const textContent = response.content.find(block => block.type === 'text');
    const text = textContent?.type === 'text' ? textContent.text.trim() : '';

    if (!text) {
      logger.error('‚ùå Claude returned empty response');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'Claude returned an empty response. Please try again.'
        },
        { status: 500 }
      );
    }

    // Extract usage statistics
    const inputTokens = response.usage.input_tokens;
    const outputTokens = response.usage.output_tokens;
    const totalTokens = inputTokens + outputTokens;

    // Calculate cost
    const costUsd = calculateCost(selectedModel, inputTokens, outputTokens);

    // ------------------------------------------------------------------------
    // 6. Log usage to Supabase (fire-and-forget)
    // ------------------------------------------------------------------------
    
    // Don't await - let it run in background
    logUsageToSupabase(
      userId,
      selectedModel,
      inputTokens,
      outputTokens,
      validatedFeature,
      costUsd
    ).catch(err => {
      // Extra safety net - should never throw but just in case
      logger.error('‚ùå Unexpected error in usage logging:', err);
    });

    // ------------------------------------------------------------------------
    // 7. Return response
    // ------------------------------------------------------------------------
    
    const duration = Date.now() - startTime;
    
    logger.log('‚úÖ Claude API success:', {
      duration: `${duration}ms`,
      inputTokens,
      outputTokens,
      cost: `$${costUsd.toFixed(6)}`,
      responseLength: text.length,
    });

    return NextResponse.json<ClaudeResponse>(
      {
        text,
        model: selectedModel,
        usage: {
          inputTokens,
          outputTokens,
          totalTokens,
        },
        stopReason: response.stop_reason,
      },
      { status: 200 }
    );

  } catch (error) {
    // ------------------------------------------------------------------------
    // Error Handling
    // ------------------------------------------------------------------------
    
    const duration = Date.now() - startTime;
    
    logger.error('‚ùå Claude API error:', {
      error: error instanceof Error ? error.message : 'Unknown error',
      duration: `${duration}ms`,
    });

    // Handle timeout errors
    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Request timeout',
          details: 'The request took too long to complete. Please try again with shorter content.'
        },
        { status: 408 }
      );
    }

    // Handle Anthropic-specific errors
    if (error instanceof Anthropic.APIError) {
      logger.error('Anthropic API Error:', {
        status: error.status,
        message: error.message,
      });

      let userMessage = 'AI service error. Please try again.';
      let statusCode = error.status || 500;
      
      switch (error.status) {
        case 400:
          userMessage = 'Invalid request. Please check your input and try again.';
          break;
        case 401:
        case 403:
          userMessage = 'Authentication error. Please contact support.';
          break;
        case 429:
          userMessage = 'Rate limit exceeded. Please wait a moment and try again.';
          break;
        case 500:
        case 503:
          userMessage = 'AI service temporarily unavailable. Please try again in a moment.';
          break;
        case 529:
          userMessage = 'AI service is overloaded. Please try again in a few minutes.';
          break;
      }

      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI service error',
          details: userMessage
        },
        { status: statusCode }
      );
    }

    // Handle generic errors
    return NextResponse.json<ErrorResponse>(
      { 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'An unexpected error occurred.'
      },
      { status: 500 }
    );
  }
}

// ============================================================================
// GET Handler - Usage Statistics
// ============================================================================

/**
 * GET /api/claude
 * 
 * Returns the current user's API usage statistics
 * 
 * @param request - Next.js request object
 * @returns JSON response with usage statistics
 */
export async function GET(
  request: NextRequest
): Promise<NextResponse> {
  try {
    // Authenticate user
    const userId = await getUserId();
    
    if (!userId) {
      return unauthorizedResponse();
    }

    // Check if Supabase is configured
    if (!isSupabaseConfigured() || !supabaseAdmin) {
      return NextResponse.json(
        { 
          error: 'Usage tracking not available',
          details: 'Database is not configured'
        },
        { status: 503 }
      );
    }

    // Get usage summary
    const { data: summary, error: summaryError } = await (supabaseAdmin
      .from('user_usage_summary') as any)
      .select('*')
      .eq('user_id', userId)
      .single();

    // Get current month usage
    const { data: monthlyUsage, error: monthlyError } = await (supabaseAdmin
      .from('user_usage_current_month') as any)
      .select('*')
      .eq('user_id', userId)
      .single();

    // Get today's usage
    const { data: dailyUsage, error: dailyError } = await (supabaseAdmin
      .from('user_usage_today') as any)
      .select('*')
      .eq('user_id', userId)
      .single();

    // Return statistics (with defaults for new users)
    return NextResponse.json({
      allTime: summary || {
        total_api_calls: 0,
        total_input_tokens: 0,
        total_output_tokens: 0,
        total_tokens_used: 0,
        total_cost_usd: 0,
        last_api_call: null,
      },
      currentMonth: monthlyUsage || {
        api_calls_this_month: 0,
        input_tokens_this_month: 0,
        output_tokens_this_month: 0,
        total_tokens_this_month: 0,
        cost_this_month: 0,
        last_api_call: null,
      },
      today: dailyUsage || {
        api_calls_today: 0,
        tokens_today: 0,
        cost_today: 0,
      },
    });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }

    logger.error('‚ùå Error fetching usage stats:', error);
    
    return NextResponse.json(
      { 
        error: 'Failed to fetch usage statistics',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}


=== FILE: app/api/db/all-brand-voices/route.ts ===

/**
 * @file app/api/db/all-brand-voices/route.ts
 * @description API route for fetching ALL brand voices for a user (across all projects)
 * 
 * Used by the MY INSIGHTS section to populate the brand voice selector dropdown.
 * Returns all brand voices the user has created, regardless of which project they belong to.
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse, 
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Brand voice with project context for display in selectors
 */
interface BrandVoiceWithProject {
  id: string;
  projectId: string | null;
  projectName: string | null;
  brandName: string;
  brandTone: string;
  approvedPhrases: string[];
  forbiddenWords: string[];
  brandValues: string[];
  missionStatement: string;
  createdAt: string;
  updatedAt: string;
}

// ============================================================================
// GET - Fetch all brand voices for a user
// ============================================================================

export async function GET(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    // Fetch all brand voices for this user
    // Use LEFT JOIN (projects) to include brand voices without project_id
    const { data: brandVoices, error } = await (supabase
      .from('brand_voices') as any)
      .select(`
        id,
        project_id,
        brand_name,
        brand_tone,
        approved_phrases,
        forbidden_words,
        brand_values,
        mission_statement,
        created_at,
        updated_at,
        projects(name)
      `)
      .eq('user_id', userId)
      .order('brand_name', { ascending: true });

    if (error) {
      console.error('Supabase error fetching brand voices:', error);
      return internalErrorResponse(error);
    }

    // Transform the data to match our expected format
    const transformedBrandVoices: BrandVoiceWithProject[] = (brandVoices || []).map((bv: any) => ({
      id: bv.id,
      projectId: bv.project_id || null,
      projectName: bv.projects?.name || null,
      brandName: bv.brand_name,
      brandTone: bv.brand_tone || '',
      approvedPhrases: bv.approved_phrases || [],
      forbiddenWords: bv.forbidden_words || [],
      brandValues: bv.brand_values || [],
      missionStatement: bv.mission_statement || '',
      createdAt: bv.created_at,
      updatedAt: bv.updated_at,
    }));

    return NextResponse.json(transformedBrandVoices);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/db/all-personas/route.ts ===

/**
 * @file app/api/db/all-personas/route.ts
 * @description API route for fetching ALL personas for a user (across all projects)
 * 
 * Used by the MY INSIGHTS section to populate the persona selector dropdown.
 * Returns all personas the user has created, regardless of which project they belong to.
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse, 
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Persona with project context for display in selectors
 */
interface PersonaWithProject {
  id: string;
  projectId: string | null;
  projectName: string | null;
  name: string;
  photoUrl?: string;
  demographics: string;
  psychographics: string;
  painPoints: string;
  languagePatterns: string;
  goals: string;
  createdAt: string;
  updatedAt: string;
}

// ============================================================================
// GET - Fetch all personas for a user
// ============================================================================

export async function GET(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    // Fetch all personas for this user
    // Use LEFT JOIN (projects) to include personas without project_id (if any)
    const { data: personas, error } = await (supabase
      .from('personas') as any)
      .select(`
        id,
        project_id,
        name,
        photo_url,
        demographics,
        psychographics,
        pain_points,
        language_patterns,
        goals,
        created_at,
        updated_at,
        projects(name)
      `)
      .eq('user_id', userId)
      .order('name', { ascending: true });

    if (error) {
      console.error('Supabase error fetching personas:', error);
      return internalErrorResponse(error);
    }

    // Transform the data to match our expected format
    const transformedPersonas: PersonaWithProject[] = (personas || []).map((p: any) => ({
      id: p.id,
      projectId: p.project_id || null,
      projectName: p.projects?.name || null,
      name: p.name,
      photoUrl: p.photo_url,
      demographics: p.demographics || '',
      psychographics: p.psychographics || '',
      painPoints: p.pain_points || '',
      languagePatterns: p.language_patterns || '',
      goals: p.goals || '',
      createdAt: p.created_at,
      updatedAt: p.updated_at,
    }));

    return NextResponse.json(transformedPersonas);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/db/brand-voices/route.ts ===

/**
 * @file app/api/db/brand-voices/route.ts
 * @description API route for brand voice CRUD operations
 * 
 * Endpoints:
 * - GET: Fetch brand voice by ID or for a project
 * - POST: Create a new brand voice (project_id is optional)
 * - PUT: Update an existing brand voice
 * - DELETE: Delete brand voice by ID or project_id
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse, 
  badRequestResponse, 
  notFoundResponse,
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// GET - Fetch brand voice by ID or for a project
// ============================================================================

export async function GET(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    const projectId = searchParams.get('project_id');

    // Fetch by ID takes precedence
    if (id) {
      const { data: brandVoice, error } = await (supabase
        .from('brand_voices') as any)
        .select('*')
        .eq('id', id)
        .eq('user_id', userId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return notFoundResponse('Brand voice');
        }
        return internalErrorResponse(error);
      }

      return NextResponse.json(brandVoice);
    }

    // Fetch by project_id (legacy support)
    if (projectId) {
      const { data: brandVoice, error } = await (supabase
        .from('brand_voices') as any)
        .select('*')
        .eq('project_id', projectId)
        .eq('user_id', userId)
        .single();

      if (error) {
        // No brand voice found is not an error - return null
        if (error.code === 'PGRST116') {
          return NextResponse.json(null);
        }
        return internalErrorResponse(error);
      }

      return NextResponse.json(brandVoice);
    }

    return badRequestResponse('Either ID or Project ID is required');

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// POST - Create a new brand voice (project_id is now optional)
// ============================================================================

export async function POST(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body = await request.json();
    const { 
      project_id, // Optional - brand voices can exist independently
      brand_name,
      brand_tone,
      approved_phrases,
      forbidden_words,
      brand_values,
      mission_statement
    } = body;

    // Validate required fields
    if (!brand_name || typeof brand_name !== 'string' || brand_name.trim().length === 0) {
      return badRequestResponse('Brand name is required');
    }

    // Create new brand voice (project_id is optional)
    const insertData: Record<string, unknown> = {
      user_id: userId,
      brand_name: brand_name.trim(),
      brand_tone: typeof brand_tone === 'string' ? brand_tone : '',
      approved_phrases: Array.isArray(approved_phrases) ? approved_phrases : [],
      forbidden_words: Array.isArray(forbidden_words) ? forbidden_words : [],
      brand_values: Array.isArray(brand_values) ? brand_values : [],
      mission_statement: typeof mission_statement === 'string' ? mission_statement : '',
    };

    // Only add project_id if provided
    if (project_id) {
      insertData.project_id = project_id;
    }

    const { data, error } = await (supabase
      .from('brand_voices') as any)
      .insert(insertData)
      .select()
      .single();

    if (error) {
      console.error('Supabase error creating brand voice:', error);
      
      // Check for unique constraint violation
      if (error.code === '23505' || error.message?.includes('unique') || error.message?.includes('duplicate')) {
        return NextResponse.json(
          { 
            error: 'Brand voice already exists',
            details: 'A brand voice already exists for this project. To enable multiple brand voices, please run the database migration: supabase/migrations/001_multiple_brand_voices.sql'
          },
          { status: 409 }
        );
      }
      
      // Check for NOT NULL violation (project_id required)
      if (error.code === '23502' || error.message?.includes('not-null') || error.message?.includes('null value')) {
        return NextResponse.json(
          { 
            error: 'Project ID required',
            details: 'The database requires a project_id. To create brand voices without a project, please run the database migration: supabase/migrations/001_multiple_brand_voices.sql'
          },
          { status: 400 }
        );
      }
      
      return internalErrorResponse(error);
    }

    return NextResponse.json(data, { status: 201 });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// PUT - Update an existing brand voice
// ============================================================================

export async function PUT(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body = await request.json();
    const { id, ...updates } = body;

    if (!id) {
      return badRequestResponse('Brand voice ID is required');
    }

    // Filter allowed update fields
    const allowedFields = [
      'brand_name', 'brand_tone', 'approved_phrases',
      'forbidden_words', 'brand_values', 'mission_statement', 'project_id'
    ];
    
    const filteredUpdates: Record<string, unknown> = {};
    for (const field of allowedFields) {
      if (updates[field] !== undefined) {
        filteredUpdates[field] = updates[field];
      }
    }

    // Validate brand_name if being updated
    if (filteredUpdates.brand_name !== undefined) {
      const brandName = filteredUpdates.brand_name as string;
      if (typeof brandName !== 'string' || brandName.trim().length === 0) {
        return badRequestResponse('Brand name cannot be empty');
      }
      filteredUpdates.brand_name = brandName.trim();
    }

    if (Object.keys(filteredUpdates).length === 0) {
      return badRequestResponse('No valid updates provided');
    }

    // Update the brand voice
    const { data, error } = await (supabase
      .from('brand_voices') as any)
      .update(filteredUpdates)
      .eq('id', id)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return notFoundResponse('Brand voice');
      }
      console.error('Supabase error updating brand voice:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(data);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// DELETE - Delete brand voice by ID or project_id
// ============================================================================

export async function DELETE(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    const projectId = searchParams.get('project_id');

    // Delete by ID takes precedence
    if (id) {
      const { error } = await (supabase
        .from('brand_voices') as any)
        .delete()
        .eq('id', id)
        .eq('user_id', userId);

      if (error) {
        console.error('Supabase error deleting brand voice:', error);
        return internalErrorResponse(error);
      }

      return NextResponse.json({ success: true, id });
    }

    // Delete by project_id (legacy support)
    if (projectId) {
      const { error } = await (supabase
        .from('brand_voices') as any)
        .delete()
        .eq('project_id', projectId)
        .eq('user_id', userId);

      if (error) {
        console.error('Supabase error deleting brand voice:', error);
        return internalErrorResponse(error);
      }

      return NextResponse.json({ success: true, project_id: projectId });
    }

    return badRequestResponse('Either ID or Project ID is required');

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/db/documents/route.ts ===

/**
 * @file app/api/db/documents/route.ts
 * @description API route for document CRUD operations
 * 
 * Endpoints:
 * - GET: Fetch documents (all for project or single by ID)
 * - POST: Create a new document
 * - PUT: Update an existing document
 * - DELETE: Delete a document
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse, 
  badRequestResponse, 
  notFoundResponse,
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// GET - Fetch documents
// ============================================================================

export async function GET(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { searchParams } = new URL(request.url);
    const projectId = searchParams.get('project_id');
    const documentId = searchParams.get('id');
    const baseTitle = searchParams.get('base_title');

    // Fetch single document by ID
    if (documentId) {
      const { data: document, error } = await (supabase
        .from('documents') as any)
        .select('*')
        .eq('id', documentId)
        .eq('user_id', userId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return notFoundResponse('Document');
        }
        return internalErrorResponse(error);
      }

      return NextResponse.json(document);
    }

    // Fetch all documents for a project
    if (!projectId) {
      return badRequestResponse('Project ID is required');
    }

    // Fetch document versions by base_title (if provided)
    if (baseTitle) {
      const { data: documents, error } = await (supabase
        .from('documents') as any)
        .select('*')
        .eq('project_id', projectId)
        .eq('user_id', userId)
        .eq('base_title', baseTitle)
        .order('version', { ascending: true });

      if (error) {
        return internalErrorResponse(error);
      }

      return NextResponse.json(documents || []);
    }

    // Fetch all documents for a project (no base_title filter)
    const { data: documents, error } = await (supabase
      .from('documents') as any)
      .select('*')
      .eq('project_id', projectId)
      .eq('user_id', userId)
      .order('modified_at', { ascending: false });

    if (error) {
      return internalErrorResponse(error);
    }

    return NextResponse.json(documents || []);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// POST - Create a new document
// ============================================================================

export async function POST(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body = await request.json();
    const { 
      project_id, 
      base_title, 
      title, 
      content = '', 
      version = 1,
      parent_version_id,
      folder_id,
      metadata,
      template_progress
    } = body;

    // Validate required fields
    if (!project_id) {
      return badRequestResponse('Project ID is required');
    }

    if (!base_title || typeof base_title !== 'string' || base_title.trim().length === 0) {
      return badRequestResponse('Document title is required');
    }

    if (base_title.trim().length > 200) {
      return badRequestResponse('Document title cannot exceed 200 characters');
    }

    // Create the document
    const insertData = {
      project_id,
      user_id: userId,
      base_title: base_title.trim(),
      title: title || base_title.trim(),
      content,
      version,
      parent_version_id,
      folder_id,
      metadata: metadata || {},
      template_progress,
    };

    const { data: document, error } = await (supabase
      .from('documents') as any)
      .insert(insertData)
      .select()
      .single();

    if (error) {
      console.error('Supabase error creating document:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(document, { status: 201 });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// PUT - Update an existing document
// ============================================================================

export async function PUT(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body = await request.json();
    const { id, ...updates } = body;

    if (!id) {
      return badRequestResponse('Document ID is required');
    }

    // Filter allowed update fields
    const allowedFields = [
      'base_title', 'title', 'content', 'folder_id', 
      'metadata', 'template_progress'
    ];
    
    const filteredUpdates: Record<string, unknown> = {};
    for (const field of allowedFields) {
      if (updates[field] !== undefined) {
        filteredUpdates[field] = updates[field];
      }
    }

    // Validate title if being updated
    if (filteredUpdates.base_title !== undefined) {
      const baseTitle = filteredUpdates.base_title;
      if (typeof baseTitle !== 'string' || baseTitle.trim().length === 0) {
        return badRequestResponse('Document title cannot be empty');
      }
      if (baseTitle.trim().length > 200) {
        return badRequestResponse('Document title cannot exceed 200 characters');
      }
      filteredUpdates.base_title = baseTitle.trim();
    }

    if (Object.keys(filteredUpdates).length === 0) {
      return badRequestResponse('No valid updates provided');
    }

    // Update the document
    const { data: document, error } = await (supabase
      .from('documents') as any)
      .update(filteredUpdates)
      .eq('id', id)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return notFoundResponse('Document');
      }
      console.error('Supabase error updating document:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(document);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// DELETE - Delete a document
// ============================================================================

export async function DELETE(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
      return badRequestResponse('Document ID is required');
    }

    const { error } = await (supabase
      .from('documents') as any)
      .delete()
      .eq('id', id)
      .eq('user_id', userId);

    if (error) {
      console.error('Supabase error deleting document:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json({ success: true, id });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/db/folders/route.ts ===

/**
 * @file app/api/db/folders/route.ts
 * @description API route for folder CRUD operations
 * 
 * Endpoints:
 * - GET: Fetch folders for a project
 * - POST: Create a new folder
 * - PUT: Update an existing folder (name or parent)
 * - DELETE: Delete a folder
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse, 
  badRequestResponse, 
  notFoundResponse,
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// GET - Fetch folders
// ============================================================================

export async function GET(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { searchParams } = new URL(request.url);
    const projectId = searchParams.get('project_id');
    const folderId = searchParams.get('id');

    // Fetch single folder by ID
    if (folderId) {
      const { data: folder, error } = await (supabase
        .from('folders') as any)
        .select('*')
        .eq('id', folderId)
        .eq('user_id', userId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return notFoundResponse('Folder');
        }
        return internalErrorResponse(error);
      }

      return NextResponse.json(folder);
    }

    // Fetch all folders for a project
    if (!projectId) {
      return badRequestResponse('Project ID is required');
    }

    const { data: folders, error } = await (supabase
      .from('folders') as any)
      .select('*')
      .eq('project_id', projectId)
      .eq('user_id', userId)
      .order('name', { ascending: true });

    if (error) {
      return internalErrorResponse(error);
    }

    return NextResponse.json(folders || []);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// POST - Create a new folder
// ============================================================================

export async function POST(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body = await request.json();
    const { project_id, name, parent_folder_id } = body;

    // Validate required fields
    if (!project_id) {
      return badRequestResponse('Project ID is required');
    }

    if (!name || typeof name !== 'string' || name.trim().length === 0) {
      return badRequestResponse('Folder name is required');
    }

    if (name.trim().length > 100) {
      return badRequestResponse('Folder name cannot exceed 100 characters');
    }

    // If parent_folder_id provided, verify it exists and belongs to user
    if (parent_folder_id) {
      const { data: parentFolder, error: parentError } = await (supabase
        .from('folders') as any)
        .select('id')
        .eq('id', parent_folder_id)
        .eq('user_id', userId)
        .single();

      if (parentError || !parentFolder) {
        return badRequestResponse('Parent folder not found');
      }
    }

    // Create the folder
    const insertData = {
      project_id,
      user_id: userId,
      name: name.trim(),
      parent_folder_id: parent_folder_id || null,
    };

    const { data: folder, error } = await (supabase
      .from('folders') as any)
      .insert(insertData)
      .select()
      .single();

    if (error) {
      console.error('Supabase error creating folder:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(folder, { status: 201 });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// PUT - Update an existing folder
// ============================================================================

export async function PUT(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body = await request.json();
    const { id, name, parent_folder_id } = body;

    if (!id) {
      return badRequestResponse('Folder ID is required');
    }

    const updates: Record<string, unknown> = {};

    // Validate and add name update
    if (name !== undefined) {
      if (typeof name !== 'string' || name.trim().length === 0) {
        return badRequestResponse('Folder name cannot be empty');
      }
      if (name.trim().length > 100) {
        return badRequestResponse('Folder name cannot exceed 100 characters');
      }
      updates.name = name.trim();
    }

    // Handle parent_folder_id update (for moving folders)
    if (parent_folder_id !== undefined) {
      // Check for circular reference
      if (parent_folder_id === id) {
        return badRequestResponse('Cannot move folder into itself');
      }

      if (parent_folder_id !== null) {
        // Verify new parent exists and belongs to user
        const { data: parentFolder, error: parentError } = await (supabase
          .from('folders') as any)
          .select('id')
          .eq('id', parent_folder_id)
          .eq('user_id', userId)
          .single();

        if (parentError || !parentFolder) {
          return badRequestResponse('Parent folder not found');
        }

        // TODO: Check for circular reference by walking up the parent chain
      }

      updates.parent_folder_id = parent_folder_id;
    }

    if (Object.keys(updates).length === 0) {
      return badRequestResponse('No valid updates provided');
    }

    // Update the folder
    const { data: folder, error } = await (supabase
      .from('folders') as any)
      .update(updates)
      .eq('id', id)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return notFoundResponse('Folder');
      }
      console.error('Supabase error updating folder:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(folder);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// DELETE - Delete a folder
// ============================================================================

export async function DELETE(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');
    const force = searchParams.get('force') === 'true';

    if (!id) {
      return badRequestResponse('Folder ID is required');
    }

    // Check for subfolders
    const { data: subfolders } = await (supabase
      .from('folders') as any)
      .select('id')
      .eq('parent_folder_id', id)
      .eq('user_id', userId);

    if (subfolders && subfolders.length > 0 && !force) {
      return badRequestResponse(
        'Cannot delete folder with subfolders. Delete or move subfolders first, or use force=true.'
      );
    }

    // Check for documents in folder
    const { data: documents } = await (supabase
      .from('documents') as any)
      .select('id')
      .eq('folder_id', id)
      .eq('user_id', userId);

    if (documents && documents.length > 0 && !force) {
      return badRequestResponse(
        'Cannot delete folder with documents. Delete or move documents first, or use force=true.'
      );
    }

    // If force=true, delete everything (cascading deletes handle subfolders)
    const { error } = await (supabase
      .from('folders') as any)
      .delete()
      .eq('id', id)
      .eq('user_id', userId);

    if (error) {
      console.error('Supabase error deleting folder:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json({ success: true, id });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/db/migrate/route.ts ===

/**
 * @file app/api/db/migrate/route.ts
 * @description API route for migrating localStorage data to Supabase
 * 
 * This endpoint handles the one-time migration of existing user data
 * from localStorage to the Supabase database.
 * 
 * Endpoint:
 * - POST: Migrate localStorage data to Supabase
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse, 
  badRequestResponse,
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// Types for migration data
// ============================================================================

interface MigrationProject {
  id: string;
  name: string;
  brandVoice?: {
    brandName: string;
    brandTone: string;
    approvedPhrases: string[];
    forbiddenWords: string[];
    brandValues: string[];
    missionStatement: string;
  } | null;
  personas: Array<{
    id: string;
    name: string;
    photoUrl?: string;
    demographics: string;
    psychographics: string;
    painPoints: string;
    languagePatterns: string;
    goals: string;
    createdAt: string;
    updatedAt: string;
  }>;
  folders: Array<{
    id: string;
    name: string;
    parentFolderId?: string;
    createdAt: string;
    updatedAt: string;
  }>;
  documents: Array<{
    id: string;
    baseTitle: string;
    title: string;
    version: number;
    parentVersionId?: string;
    folderId?: string;
    content: string;
    createdAt: string;
    modifiedAt: string;
    metadata?: Record<string, unknown>;
    templateProgress?: Record<string, unknown>;
  }>;
  snippets: Array<{
    id: string;
    name: string;
    content: string;
    description?: string;
    tags?: string[];
    usageCount: number;
    createdAt: string;
    modifiedAt: string;
  }>;
  createdAt: string;
  updatedAt: string;
}

interface MigrationRequest {
  projects: MigrationProject[];
  activeProjectId?: string;
}

interface MigrationResult {
  success: boolean;
  migrated: {
    projects: number;
    brandVoices: number;
    personas: number;
    folders: number;
    documents: number;
    snippets: number;
  };
  errors: string[];
  idMapping: Record<string, string>; // old ID -> new ID
}

// ============================================================================
// POST - Migrate localStorage data to Supabase
// ============================================================================

export async function POST(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body: MigrationRequest = await request.json();
    const { projects, activeProjectId } = body;

    if (!projects || !Array.isArray(projects)) {
      return badRequestResponse('Projects array is required');
    }

    const result: MigrationResult = {
      success: true,
      migrated: {
        projects: 0,
        brandVoices: 0,
        personas: 0,
        folders: 0,
        documents: 0,
        snippets: 0,
      },
      errors: [],
      idMapping: {},
    };

    // Process each project
    for (const project of projects) {
      try {
        // Create project
        const { data: newProject, error: projectError } = await (supabase
          .from('projects') as any)
          .insert({
            user_id: userId,
            name: project.name,
            created_at: project.createdAt || new Date().toISOString(),
            updated_at: project.updatedAt || new Date().toISOString(),
          })
          .select()
          .single();

        if (projectError || !newProject) {
          result.errors.push(`Failed to create project "${project.name}": ${projectError?.message}`);
          continue;
        }

        result.idMapping[project.id] = newProject.id;
        result.migrated.projects++;

        const projectId = newProject.id;

        // Migrate brand voice
        if (project.brandVoice && project.brandVoice.brandName) {
          try {
            const { error: bvError } = await (supabase
              .from('brand_voices') as any)
              .insert({
                project_id: projectId,
                user_id: userId,
                brand_name: project.brandVoice.brandName,
                brand_tone: project.brandVoice.brandTone || '',
                approved_phrases: project.brandVoice.approvedPhrases || [],
                forbidden_words: project.brandVoice.forbiddenWords || [],
                brand_values: project.brandVoice.brandValues || [],
                mission_statement: project.brandVoice.missionStatement || '',
              });

            if (bvError) {
              result.errors.push(`Brand voice for "${project.name}": ${bvError.message}`);
            } else {
              result.migrated.brandVoices++;
            }
          } catch (e) {
            result.errors.push(`Brand voice error: ${e instanceof Error ? e.message : 'Unknown'}`);
          }
        }

        // Migrate folders (need to handle parent relationships)
        const folderIdMapping: Record<string, string> = {};
        
        // First pass: create all folders without parents
        for (const folder of project.folders || []) {
          try {
            const { data: newFolder, error: folderError } = await (supabase
              .from('folders') as any)
              .insert({
                project_id: projectId,
                user_id: userId,
                name: folder.name,
                parent_folder_id: null, // Will update in second pass
                created_at: folder.createdAt || new Date().toISOString(),
                updated_at: folder.updatedAt || new Date().toISOString(),
              })
              .select()
              .single();

            if (folderError || !newFolder) {
              result.errors.push(`Folder "${folder.name}": ${folderError?.message}`);
            } else {
              folderIdMapping[folder.id] = newFolder.id;
              result.migrated.folders++;
            }
          } catch (e) {
            result.errors.push(`Folder error: ${e instanceof Error ? e.message : 'Unknown'}`);
          }
        }

        // Second pass: update parent relationships
        for (const folder of project.folders || []) {
          if (folder.parentFolderId && folderIdMapping[folder.id]) {
            const newParentId = folderIdMapping[folder.parentFolderId];
            if (newParentId) {
              await (supabase
                .from('folders') as any)
                .update({ parent_folder_id: newParentId })
                .eq('id', folderIdMapping[folder.id]);
            }
          }
        }

        // Migrate personas
        for (const persona of project.personas || []) {
          try {
            const { error: personaError } = await (supabase
              .from('personas') as any)
              .insert({
                project_id: projectId,
                user_id: userId,
                name: persona.name,
                photo_url: persona.photoUrl || null,
                demographics: persona.demographics || '',
                psychographics: persona.psychographics || '',
                pain_points: persona.painPoints || '',
                language_patterns: persona.languagePatterns || '',
                goals: persona.goals || '',
                created_at: persona.createdAt || new Date().toISOString(),
                updated_at: persona.updatedAt || new Date().toISOString(),
              });

            if (personaError) {
              result.errors.push(`Persona "${persona.name}": ${personaError.message}`);
            } else {
              result.migrated.personas++;
            }
          } catch (e) {
            result.errors.push(`Persona error: ${e instanceof Error ? e.message : 'Unknown'}`);
          }
        }

        // Migrate documents (need to handle version relationships)
        const documentIdMapping: Record<string, string> = {};

        // First pass: create all documents without parent versions
        for (const doc of project.documents || []) {
          try {
            const { data: newDoc, error: docError } = await (supabase
              .from('documents') as any)
              .insert({
                project_id: projectId,
                user_id: userId,
                base_title: doc.baseTitle,
                title: doc.title,
                version: doc.version || 1,
                parent_version_id: null, // Will update in second pass
                folder_id: doc.folderId ? folderIdMapping[doc.folderId] : null,
                content: doc.content || '',
                metadata: doc.metadata || {},
                template_progress: doc.templateProgress || null,
                created_at: doc.createdAt || new Date().toISOString(),
                modified_at: doc.modifiedAt || new Date().toISOString(),
              })
              .select()
              .single();

            if (docError || !newDoc) {
              result.errors.push(`Document "${doc.title}": ${docError?.message}`);
            } else {
              documentIdMapping[doc.id] = newDoc.id;
              result.migrated.documents++;
            }
          } catch (e) {
            result.errors.push(`Document error: ${e instanceof Error ? e.message : 'Unknown'}`);
          }
        }

        // Second pass: update parent version relationships
        for (const doc of project.documents || []) {
          if (doc.parentVersionId && documentIdMapping[doc.id]) {
            const newParentId = documentIdMapping[doc.parentVersionId];
            if (newParentId) {
              await (supabase
                .from('documents') as any)
                .update({ parent_version_id: newParentId })
                .eq('id', documentIdMapping[doc.id]);
            }
          }
        }

        // Migrate snippets
        for (const snippet of project.snippets || []) {
          try {
            const { error: snippetError } = await (supabase
              .from('snippets') as any)
              .insert({
                project_id: projectId,
                user_id: userId,
                name: snippet.name,
                content: snippet.content,
                description: snippet.description || null,
                tags: snippet.tags || [],
                usage_count: snippet.usageCount || 0,
                created_at: snippet.createdAt || new Date().toISOString(),
                modified_at: snippet.modifiedAt || new Date().toISOString(),
              });

            if (snippetError) {
              result.errors.push(`Snippet "${snippet.name}": ${snippetError.message}`);
            } else {
              result.migrated.snippets++;
            }
          } catch (e) {
            result.errors.push(`Snippet error: ${e instanceof Error ? e.message : 'Unknown'}`);
          }
        }

      } catch (projectError) {
        result.errors.push(`Project "${project.name}" error: ${projectError instanceof Error ? projectError.message : 'Unknown'}`);
      }
    }

    // Update active project if provided
    if (activeProjectId && result.idMapping[activeProjectId]) {
      await (supabase
        .from('user_settings') as any)
        .upsert({
          user_id: userId,
          active_project_id: result.idMapping[activeProjectId],
          settings: {},
        }, {
          onConflict: 'user_id'
        });
    }

    // Determine overall success
    result.success = result.errors.length === 0;

    return NextResponse.json(result, { 
      status: result.success ? 200 : 207 // 207 Multi-Status for partial success
    });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    console.error('Migration error:', error);
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/db/personas/route.ts ===

/**
 * @file app/api/db/personas/route.ts
 * @description API route for persona CRUD operations
 * 
 * Endpoints:
 * - GET: Fetch personas (all for project or single by ID)
 * - POST: Create a new persona
 * - PUT: Update an existing persona
 * - DELETE: Delete a persona
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse, 
  badRequestResponse, 
  notFoundResponse,
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// GET - Fetch personas
// ============================================================================

export async function GET(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { searchParams } = new URL(request.url);
    const projectId = searchParams.get('project_id');
    const personaId = searchParams.get('id');

    // Fetch single persona by ID
    if (personaId) {
      const { data: persona, error } = await (supabase
        .from('personas') as any)
        .select('*')
        .eq('id', personaId)
        .eq('user_id', userId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return notFoundResponse('Persona');
        }
        return internalErrorResponse(error);
      }

      return NextResponse.json(persona);
    }

    // Fetch all personas for a project
    if (!projectId) {
      return badRequestResponse('Project ID is required');
    }

    const { data: personas, error } = await (supabase
      .from('personas') as any)
      .select('*')
      .eq('project_id', projectId)
      .eq('user_id', userId)
      .order('created_at', { ascending: true });

    if (error) {
      return internalErrorResponse(error);
    }

    return NextResponse.json(personas || []);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// POST - Create a new persona
// ============================================================================

export async function POST(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body = await request.json();
    const { 
      project_id,
      name,
      photo_url,
      demographics = '',
      psychographics = '',
      pain_points = '',
      language_patterns = '',
      goals = ''
    } = body;

    // Validate required fields
    if (!project_id) {
      return badRequestResponse('Project ID is required');
    }

    if (!name || typeof name !== 'string' || name.trim().length === 0) {
      return badRequestResponse('Persona name is required');
    }

    if (name.trim().length > 100) {
      return badRequestResponse('Persona name cannot exceed 100 characters');
    }

    // Validate photo URL size if provided (base64 data URLs can be large)
    if (photo_url && photo_url.startsWith('data:image/')) {
      const base64Data = photo_url.split(',')[1];
      const sizeInBytes = Math.ceil((base64Data.length * 3) / 4);
      if (sizeInBytes > 2 * 1024 * 1024) { // 2MB limit
        return badRequestResponse('Photo size too large. Please use an image smaller than 2MB.');
      }
    }

    // Create the persona
    const { data: persona, error } = await (supabase
      .from('personas') as any)
      .insert({
        project_id,
        user_id: userId,
        name: name.trim(),
        photo_url,
        demographics: demographics.trim(),
        psychographics: psychographics.trim(),
        pain_points: pain_points.trim(),
        language_patterns: language_patterns.trim(),
        goals: goals.trim(),
      })
      .select()
      .single();

    if (error) {
      console.error('Supabase error creating persona:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(persona, { status: 201 });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// PUT - Update an existing persona
// ============================================================================

export async function PUT(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body = await request.json();
    const { id, ...updates } = body;

    if (!id) {
      return badRequestResponse('Persona ID is required');
    }

    // Filter allowed update fields
    const allowedFields = [
      'name', 'photo_url', 'demographics', 'psychographics',
      'pain_points', 'language_patterns', 'goals'
    ];
    
    const filteredUpdates: Record<string, unknown> = {};
    for (const field of allowedFields) {
      if (updates[field] !== undefined) {
        filteredUpdates[field] = updates[field];
      }
    }

    // Validate name if being updated
    if (filteredUpdates.name !== undefined) {
      const name = filteredUpdates.name as string;
      if (typeof name !== 'string' || name.trim().length === 0) {
        return badRequestResponse('Persona name cannot be empty');
      }
      if (name.trim().length > 100) {
        return badRequestResponse('Persona name cannot exceed 100 characters');
      }
      filteredUpdates.name = name.trim();
    }

    // Validate photo URL size if being updated
    if (filteredUpdates.photo_url) {
      const photoUrl = filteredUpdates.photo_url as string;
      if (photoUrl.startsWith('data:image/')) {
        const base64Data = photoUrl.split(',')[1];
        const sizeInBytes = Math.ceil((base64Data.length * 3) / 4);
        if (sizeInBytes > 2 * 1024 * 1024) {
          return badRequestResponse('Photo size too large. Please use an image smaller than 2MB.');
        }
      }
    }

    if (Object.keys(filteredUpdates).length === 0) {
      return badRequestResponse('No valid updates provided');
    }

    // Update the persona
    const { data: persona, error } = await (supabase
      .from('personas') as any)
      .update(filteredUpdates)
      .eq('id', id)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return notFoundResponse('Persona');
      }
      console.error('Supabase error updating persona:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(persona);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// DELETE - Delete a persona
// ============================================================================

export async function DELETE(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
      return badRequestResponse('Persona ID is required');
    }

    const { error } = await (supabase
      .from('personas') as any)
      .delete()
      .eq('id', id)
      .eq('user_id', userId);

    if (error) {
      console.error('Supabase error deleting persona:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json({ success: true, id });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/db/projects/route.ts ===

/**
 * @file app/api/db/projects/route.ts
 * @description API route for project CRUD operations
 * 
 * Endpoints:
 * - GET: Fetch all projects for the authenticated user
 * - POST: Create a new project
 * - PUT: Update an existing project
 * - DELETE: Delete a project
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse, 
  badRequestResponse, 
  notFoundResponse,
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// Type Definitions
// ============================================================================

interface ProjectResponse {
  id: string;
  user_id: string;
  name: string;
  created_at: string;
  updated_at: string;
}

// ============================================================================
// GET - Fetch all projects
// ============================================================================

export async function GET() {
  try {
    // Check if Supabase is configured
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    // Get authenticated user
    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    // Fetch projects for this user
    const { data: projects, error } = await (supabase
      .from('projects') as any)
      .select('*')
      .eq('user_id', userId)
      .order('updated_at', { ascending: false });

    if (error) {
      console.error('Supabase error fetching projects:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(projects || []);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// POST - Create a new project
// ============================================================================

export async function POST(request: NextRequest) {
  try {
    // Check if Supabase is configured
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    // Get authenticated user
    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    // Parse request body
    const body = await request.json();
    const { name } = body;

    // Validate required fields
    if (!name || typeof name !== 'string' || name.trim().length === 0) {
      return badRequestResponse('Project name is required');
    }

    if (name.trim().length > 100) {
      return badRequestResponse('Project name cannot exceed 100 characters');
    }

    // Create the project
    const { data: project, error } = await (supabase
      .from('projects') as any)
      .insert({
        user_id: userId,
        name: name.trim(),
      })
      .select()
      .single();

    if (error) {
      console.error('Supabase error creating project:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(project, { status: 201 });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// PUT - Update an existing project
// ============================================================================

export async function PUT(request: NextRequest) {
  try {
    // Check if Supabase is configured
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    // Get authenticated user
    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    // Parse request body
    const body = await request.json();
    const { id, name } = body;

    // Validate required fields
    if (!id) {
      return badRequestResponse('Project ID is required');
    }

    // Build update object
    const updates: Record<string, unknown> = {};
    
    if (name !== undefined) {
      if (typeof name !== 'string' || name.trim().length === 0) {
        return badRequestResponse('Project name cannot be empty');
      }
      if (name.trim().length > 100) {
        return badRequestResponse('Project name cannot exceed 100 characters');
      }
      updates.name = name.trim();
    }

    if (Object.keys(updates).length === 0) {
      return badRequestResponse('No valid updates provided');
    }

    // Update the project
    const { data: project, error } = await (supabase
      .from('projects') as any)
      .update(updates)
      .eq('id', id)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return notFoundResponse('Project');
      }
      console.error('Supabase error updating project:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(project);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// DELETE - Delete a project
// ============================================================================

export async function DELETE(request: NextRequest) {
  try {
    // Check if Supabase is configured
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    // Get authenticated user
    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    // Get project ID from query params
    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
      return badRequestResponse('Project ID is required');
    }

    // Delete the project (cascading deletes will handle related data)
    const { error } = await (supabase
      .from('projects') as any)
      .delete()
      .eq('id', id)
      .eq('user_id', userId);

    if (error) {
      console.error('Supabase error deleting project:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json({ success: true, id });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/db/run-migration/route.ts ===

/**
 * @file app/api/db/run-migration/route.ts
 * @description API route to run database migrations via Supabase REST API
 * 
 * This endpoint allows running specific migrations to update the database schema.
 * Uses the Supabase REST API with service_role key to execute DDL commands.
 * 
 * Currently supports:
 * - multiple-brand-voices: Enables multiple brand voices per user
 */

import { NextRequest, NextResponse } from 'next/server';
import { isSupabaseConfigured, getSupabaseAdmin } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse, 
  badRequestResponse,
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// Helper to execute SQL via Supabase REST API
// ============================================================================

async function executeSql(sql: string): Promise<{ success: boolean; error?: string }> {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const serviceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  
  if (!supabaseUrl || !serviceKey) {
    return { success: false, error: 'Supabase not configured' };
  }

  try {
    // Use the Supabase REST API to execute SQL
    const response = await fetch(`${supabaseUrl}/rest/v1/rpc/exec_sql`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'apikey': serviceKey,
        'Authorization': `Bearer ${serviceKey}`,
      },
      body: JSON.stringify({ sql }),
    });

    if (!response.ok) {
      // If RPC doesn't exist, try alternative method via pg_query
      const text = await response.text();
      return { success: false, error: `SQL execution failed: ${text}` };
    }

    return { success: true };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
}

// ============================================================================
// POST - Run a specific migration
// ============================================================================

export async function POST(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    // Require authenticated user
    await requireUserId();
    
    const body = await request.json();
    const { migration } = body;

    if (!migration) {
      return badRequestResponse('Migration name is required');
    }

    if (migration === 'multiple-brand-voices') {
      const results: { step: string; success: boolean; error?: string }[] = [];
      
      // Try to execute migrations via SQL
      // Note: This requires the exec_sql function to be created in Supabase
      // If it doesn't exist, the user needs to run the migration manually
      
      // Step 1: Drop unique constraint
      const step1 = await executeSql(
        'ALTER TABLE brand_voices DROP CONSTRAINT IF EXISTS brand_voices_project_id_key;'
      );
      results.push({ step: 'Drop unique constraint', ...step1 });

      // Step 2: Make project_id nullable
      const step2 = await executeSql(
        'ALTER TABLE brand_voices ALTER COLUMN project_id DROP NOT NULL;'
      );
      results.push({ step: 'Make project_id nullable', ...step2 });

      // Step 3: Add brand_voice_id to projects
      const step3 = await executeSql(
        'ALTER TABLE projects ADD COLUMN IF NOT EXISTS brand_voice_id UUID REFERENCES brand_voices(id) ON DELETE SET NULL;'
      );
      results.push({ step: 'Add brand_voice_id column', ...step3 });

      // Step 4: Create index
      const step4 = await executeSql(
        'CREATE INDEX IF NOT EXISTS idx_projects_brand_voice_id ON projects(brand_voice_id);'
      );
      results.push({ step: 'Create index', ...step4 });

      const allSucceeded = results.every(r => r.success);
      const anyFailed = results.some(r => !r.success);

      if (anyFailed) {
        // Provide manual instructions
        return NextResponse.json({
          success: false,
          migration: 'multiple-brand-voices',
          results,
          message: 'Automatic migration failed. Please run the following SQL in your Supabase SQL Editor:',
          sql: `-- Run this in Supabase SQL Editor (https://supabase.com/dashboard)
-- Navigate to: SQL Editor > New Query

-- Step 1: Remove unique constraint (allows multiple brand voices)
ALTER TABLE brand_voices DROP CONSTRAINT IF EXISTS brand_voices_project_id_key;

-- Step 2: Make project_id optional (brand voices can exist without a project)
ALTER TABLE brand_voices ALTER COLUMN project_id DROP NOT NULL;

-- Step 3: Add brand_voice_id to projects (optional - for assigning brand voice to project)
ALTER TABLE projects ADD COLUMN IF NOT EXISTS brand_voice_id UUID REFERENCES brand_voices(id) ON DELETE SET NULL;

-- Step 4: Create index for faster lookups
CREATE INDEX IF NOT EXISTS idx_projects_brand_voice_id ON projects(brand_voice_id);

-- Done! You can now create multiple brand voices.`,
        }, { status: 200 });
      }

      return NextResponse.json({
        success: true,
        migration: 'multiple-brand-voices',
        results,
        message: 'Migration completed successfully! You can now create multiple brand voices.',
      });
    }

    return badRequestResponse(`Unknown migration: ${migration}`);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    console.error('Migration error:', error);
    return internalErrorResponse(error);
  }
}

// ============================================================================
// GET - Check migration status
// ============================================================================

export async function GET(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    await requireUserId();
    const supabase = getSupabaseAdmin();

    // Check if multiple brand voices are enabled by checking constraints
    // Try to insert a brand voice without project_id and see if it fails
    
    // Instead, let's just check if we can create multiple brand voices for same project
    // by checking the constraint exists
    
    const status = {
      multipleBrandVoicesEnabled: false,
      message: 'Unknown status'
    };

    // Try a simple test: count brand voices per project
    const { data, error } = await (supabase
      .from('brand_voices') as any)
      .select('project_id')
      .limit(100);

    if (!error && data) {
      // Check if any project_id is null (would indicate migration ran)
      const hasNullProjectId = data.some((bv: any) => bv.project_id === null);
      
      if (hasNullProjectId) {
        status.multipleBrandVoicesEnabled = true;
        status.message = 'Multiple brand voices are enabled (project_id can be null)';
      } else {
        status.message = 'Migration may not have been run yet - project_id is still required';
      }
    }

    return NextResponse.json(status);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/db/snippets/route.ts ===

/**
 * @file app/api/db/snippets/route.ts
 * @description API route for snippet CRUD operations
 * 
 * Endpoints:
 * - GET: Fetch snippets for a project
 * - POST: Create a new snippet
 * - PUT: Update an existing snippet
 * - DELETE: Delete a snippet
 * - PATCH: Increment snippet usage count
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse, 
  badRequestResponse, 
  notFoundResponse,
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// GET - Fetch snippets
// ============================================================================

export async function GET(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { searchParams } = new URL(request.url);
    const projectId = searchParams.get('project_id');
    const snippetId = searchParams.get('id');
    const search = searchParams.get('search');
    const tag = searchParams.get('tag');

    // Fetch single snippet by ID
    if (snippetId) {
      const { data: snippet, error } = await (supabase
        .from('snippets') as any)
        .select('*')
        .eq('id', snippetId)
        .eq('user_id', userId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return notFoundResponse('Snippet');
        }
        return internalErrorResponse(error);
      }

      return NextResponse.json(snippet);
    }

    // Fetch all snippets for a project
    if (!projectId) {
      return badRequestResponse('Project ID is required');
    }

    let query = (supabase
      .from('snippets') as any)
      .select('*')
      .eq('project_id', projectId)
      .eq('user_id', userId);

    // Apply search filter
    if (search) {
      query = query.or(`name.ilike.%${search}%,content.ilike.%${search}%,description.ilike.%${search}%`);
    }

    // Apply tag filter
    if (tag) {
      query = query.contains('tags', [tag]);
    }

    const { data: snippets, error } = await query.order('modified_at', { ascending: false });

    if (error) {
      return internalErrorResponse(error);
    }

    return NextResponse.json(snippets || []);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// POST - Create a new snippet
// ============================================================================

export async function POST(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body = await request.json();
    const { 
      project_id,
      name,
      content,
      description,
      tags = []
    } = body;

    // Validate required fields
    if (!project_id) {
      return badRequestResponse('Project ID is required');
    }

    if (!name || typeof name !== 'string' || name.trim().length === 0) {
      return badRequestResponse('Snippet name is required');
    }

    if (name.trim().length > 100) {
      return badRequestResponse('Snippet name cannot exceed 100 characters');
    }

    if (!content || typeof content !== 'string' || content.trim().length === 0) {
      return badRequestResponse('Snippet content is required');
    }

    if (content.length > 50000) {
      return badRequestResponse('Snippet content cannot exceed 50,000 characters');
    }

    // Create the snippet
    const { data: snippet, error } = await (supabase
      .from('snippets') as any)
      .insert({
        project_id,
        user_id: userId,
        name: name.trim(),
        content,
        description: description?.trim() || null,
        tags: tags || [],
        usage_count: 0,
      })
      .select()
      .single();

    if (error) {
      console.error('Supabase error creating snippet:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(snippet, { status: 201 });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// PUT - Update an existing snippet
// ============================================================================

export async function PUT(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body = await request.json();
    const { id, ...updates } = body;

    if (!id) {
      return badRequestResponse('Snippet ID is required');
    }

    // Filter allowed update fields
    const allowedFields = ['name', 'content', 'description', 'tags'];
    
    const filteredUpdates: Record<string, unknown> = {};
    for (const field of allowedFields) {
      if (updates[field] !== undefined) {
        filteredUpdates[field] = updates[field];
      }
    }

    // Validate name if being updated
    if (filteredUpdates.name !== undefined) {
      const name = filteredUpdates.name as string;
      if (typeof name !== 'string' || name.trim().length === 0) {
        return badRequestResponse('Snippet name cannot be empty');
      }
      if (name.trim().length > 100) {
        return badRequestResponse('Snippet name cannot exceed 100 characters');
      }
      filteredUpdates.name = name.trim();
    }

    // Validate content if being updated
    if (filteredUpdates.content !== undefined) {
      const content = filteredUpdates.content as string;
      if (typeof content !== 'string' || content.trim().length === 0) {
        return badRequestResponse('Snippet content cannot be empty');
      }
      if (content.length > 50000) {
        return badRequestResponse('Snippet content cannot exceed 50,000 characters');
      }
    }

    if (Object.keys(filteredUpdates).length === 0) {
      return badRequestResponse('No valid updates provided');
    }

    // Update the snippet
    const { data: snippet, error } = await (supabase
      .from('snippets') as any)
      .update(filteredUpdates)
      .eq('id', id)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) {
      if (error.code === 'PGRST116') {
        return notFoundResponse('Snippet');
      }
      console.error('Supabase error updating snippet:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json(snippet);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// PATCH - Increment snippet usage count
// ============================================================================

export async function PATCH(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
      return badRequestResponse('Snippet ID is required');
    }

    // Get current snippet and increment usage count
    const { data: currentSnippet } = await (supabase
      .from('snippets') as any)
      .select('usage_count')
      .eq('id', id)
      .eq('user_id', userId)
      .single();

    if (currentSnippet) {
      await (supabase
        .from('snippets') as any)
        .update({ usage_count: (currentSnippet.usage_count || 0) + 1 })
        .eq('id', id)
        .eq('user_id', userId);
    }

    return NextResponse.json({ success: true, id });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// DELETE - Delete a snippet
// ============================================================================

export async function DELETE(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { searchParams } = new URL(request.url);
    const id = searchParams.get('id');

    if (!id) {
      return badRequestResponse('Snippet ID is required');
    }

    const { error } = await (supabase
      .from('snippets') as any)
      .delete()
      .eq('id', id)
      .eq('user_id', userId);

    if (error) {
      console.error('Supabase error deleting snippet:', error);
      return internalErrorResponse(error);
    }

    return NextResponse.json({ success: true, id });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/db/sync/route.ts ===

/**
 * @file app/api/db/sync/route.ts
 * @description API route for syncing all project data at once
 * 
 * This endpoint fetches all projects with their nested data (brand voice,
 * personas, folders, documents, snippets) in a single request, optimized
 * for initial app load.
 * 
 * Endpoint:
 * - GET: Fetch all projects with nested data
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse,
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// Types for synced data
// ============================================================================

interface SyncedBrandVoice {
  id: string;
  brandName: string;
  brandTone: string;
  approvedPhrases: string[];
  forbiddenWords: string[];
  brandValues: string[];
  missionStatement: string;
  savedAt?: Date;
}

interface SyncedPersona {
  id: string;
  name: string;
  photoUrl?: string;
  demographics: string;
  psychographics: string;
  painPoints: string;
  languagePatterns: string;
  goals: string;
  createdAt: string;
  updatedAt: string;
}

interface SyncedFolder {
  id: string;
  name: string;
  projectId: string;
  parentFolderId?: string;
  createdAt: string;
  updatedAt: string;
}

interface SyncedDocument {
  id: string;
  projectId: string;
  baseTitle: string;
  title: string;
  version: number;
  parentVersionId?: string;
  folderId?: string;
  content: string;
  createdAt: string;
  modifiedAt: string;
  metadata?: {
    wordCount?: number;
    charCount?: number;
    templateId?: string;
    tags?: string[];
  };
  templateProgress?: unknown;
}

interface SyncedSnippet {
  id: string;
  projectId: string;
  name: string;
  content: string;
  description?: string;
  tags?: string[];
  createdAt: string;
  modifiedAt: string;
  usageCount: number;
}

interface SyncedProject {
  id: string;
  name: string;
  brandVoice: SyncedBrandVoice | null;
  personas: SyncedPersona[];
  folders: SyncedFolder[];
  documents: SyncedDocument[];
  snippets: SyncedSnippet[];
  createdAt: string;
  updatedAt: string;
}

interface SyncResponse {
  projects: SyncedProject[];
  activeProjectId: string | null;
  lastSyncedAt: string;
}

// ============================================================================
// GET - Fetch all projects with nested data
// ============================================================================

export async function GET(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    // Fetch all data in parallel for better performance
    const [
      projectsResult,
      brandVoicesResult,
      personasResult,
      foldersResult,
      documentsResult,
      snippetsResult,
      settingsResult,
    ] = await Promise.all([
      (supabase
        .from('projects') as any)
        .select('*')
        .eq('user_id', userId)
        .order('updated_at', { ascending: false }),
      (supabase
        .from('brand_voices') as any)
        .select('*')
        .eq('user_id', userId),
      (supabase
        .from('personas') as any)
        .select('*')
        .eq('user_id', userId),
      (supabase
        .from('folders') as any)
        .select('*')
        .eq('user_id', userId),
      (supabase
        .from('documents') as any)
        .select('*')
        .eq('user_id', userId)
        .order('modified_at', { ascending: false }),
      (supabase
        .from('snippets') as any)
        .select('*')
        .eq('user_id', userId)
        .order('modified_at', { ascending: false }),
      (supabase
        .from('user_settings') as any)
        .select('active_project_id')
        .eq('user_id', userId)
        .single(),
    ]);

    // Check for errors
    if (projectsResult.error) {
      console.error('Error fetching projects:', projectsResult.error);
      return internalErrorResponse(projectsResult.error);
    }

    const projects = projectsResult.data || [];
    const brandVoices = brandVoicesResult.data || [];
    const personas = personasResult.data || [];
    const folders = foldersResult.data || [];
    const documents = documentsResult.data || [];
    const snippets = snippetsResult.data || [];
    const activeProjectId = settingsResult.data?.active_project_id || null;

    // Build the synced projects with nested data
    const syncedProjects: SyncedProject[] = projects.map((project: any) => {
      // Find brand voice for this project
      const brandVoice = brandVoices.find((bv: any) => bv.project_id === project.id);
      
      // Filter related data for this project
      const projectPersonas = personas.filter((p: any) => p.project_id === project.id);
      const projectFolders = folders.filter((f: any) => f.project_id === project.id);
      const projectDocuments = documents.filter((d: any) => d.project_id === project.id);
      const projectSnippets = snippets.filter((s: any) => s.project_id === project.id);

      return {
        id: project.id,
        name: project.name,
        brandVoice: brandVoice ? {
          id: brandVoice.id,
          brandName: brandVoice.brand_name,
          brandTone: brandVoice.brand_tone,
          approvedPhrases: brandVoice.approved_phrases || [],
          forbiddenWords: brandVoice.forbidden_words || [],
          brandValues: brandVoice.brand_values || [],
          missionStatement: brandVoice.mission_statement,
          savedAt: brandVoice.updated_at ? new Date(brandVoice.updated_at) : undefined,
        } : null,
        personas: projectPersonas.map((p: any) => ({
          id: p.id,
          name: p.name,
          photoUrl: p.photo_url || undefined,
          demographics: p.demographics,
          psychographics: p.psychographics,
          painPoints: p.pain_points,
          languagePatterns: p.language_patterns,
          goals: p.goals,
          createdAt: p.created_at,
          updatedAt: p.updated_at,
        })),
        folders: projectFolders.map((f: any) => ({
          id: f.id,
          name: f.name,
          projectId: f.project_id,
          parentFolderId: f.parent_folder_id || undefined,
          createdAt: f.created_at,
          updatedAt: f.updated_at,
        })),
        documents: projectDocuments.map((d: any) => ({
          id: d.id,
          projectId: d.project_id,
          baseTitle: d.base_title,
          title: d.title,
          version: d.version,
          parentVersionId: d.parent_version_id || undefined,
          folderId: d.folder_id || undefined,
          content: d.content,
          createdAt: d.created_at,
          modifiedAt: d.modified_at,
          metadata: d.metadata as SyncedDocument['metadata'],
          templateProgress: d.template_progress,
        })),
        snippets: projectSnippets.map((s: any) => ({
          id: s.id,
          projectId: s.project_id,
          name: s.name,
          content: s.content,
          description: s.description || undefined,
          tags: s.tags || undefined,
          createdAt: s.created_at,
          modifiedAt: s.modified_at,
          usageCount: s.usage_count,
        })),
        createdAt: project.created_at,
        updatedAt: project.updated_at,
      };
    });

    const response: SyncResponse = {
      projects: syncedProjects,
      activeProjectId,
      lastSyncedAt: new Date().toISOString(),
    };

    return NextResponse.json(response);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/db/user-settings/route.ts ===

/**
 * @file app/api/db/user-settings/route.ts
 * @description API route for user settings and preferences
 * 
 * Endpoints:
 * - GET: Fetch user settings (including active project ID)
 * - POST: Create or update user settings (upsert)
 */

import { NextRequest, NextResponse } from 'next/server';
import { getSupabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { 
  requireUserId, 
  unauthorizedResponse, 
  badRequestResponse,
  internalErrorResponse 
} from '@/lib/utils/api-auth';

// ============================================================================
// GET - Fetch user settings
// ============================================================================

export async function GET() {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const { data: settings, error } = await (supabase
      .from('user_settings') as any)
      .select('*')
      .eq('user_id', userId)
      .single();

    if (error) {
      // No settings found is not an error - return defaults
      if (error.code === 'PGRST116') {
        return NextResponse.json({
          user_id: userId,
          active_project_id: null,
          settings: {},
        });
      }
      return internalErrorResponse(error);
    }

    return NextResponse.json(settings);

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}

// ============================================================================
// POST - Create or update user settings (upsert)
// ============================================================================

export async function POST(request: NextRequest) {
  try {
    if (!isSupabaseConfigured()) {
      return NextResponse.json(
        { error: 'Database not configured', details: 'Supabase is not set up' },
        { status: 503 }
      );
    }

    const userId = await requireUserId();
    const supabase = getSupabaseAdmin();

    const body = await request.json();
    const { active_project_id, settings } = body;

    // Check if settings already exist for this user
    const { data: existing } = await (supabase
      .from('user_settings') as any)
      .select('id, settings')
      .eq('user_id', userId)
      .single();

    let result;

    if (existing) {
      // Update existing settings
      const updates: Record<string, unknown> = {};
      
      if (active_project_id !== undefined) {
        updates.active_project_id = active_project_id;
      }
      
      if (settings !== undefined) {
        // Merge settings instead of replacing
        updates.settings = {
          ...(existing.settings || {}),
          ...settings,
        };
      }

      if (Object.keys(updates).length === 0) {
        return NextResponse.json(existing);
      }

      const { data, error } = await (supabase
        .from('user_settings') as any)
        .update(updates)
        .eq('id', existing.id)
        .select()
        .single();

      if (error) {
        console.error('Supabase error updating user settings:', error);
        return internalErrorResponse(error);
      }
      result = data;
    } else {
      // Create new settings
      const { data, error } = await (supabase
        .from('user_settings') as any)
        .insert({
          user_id: userId,
          active_project_id: active_project_id || null,
          settings: settings || {},
        })
        .select()
        .single();

      if (error) {
        console.error('Supabase error creating user settings:', error);
        return internalErrorResponse(error);
      }
      result = data;
    }

    return NextResponse.json(result, { status: existing ? 200 : 201 });

  } catch (error) {
    if (error instanceof Error && error.message === 'UNAUTHORIZED') {
      return unauthorizedResponse();
    }
    return internalErrorResponse(error);
  }
}


=== FILE: app/api/expand/route.ts ===

/**
 * @file app/api/expand/route.ts
 * @description API route for expanding copy using Claude AI
 * 
 * This endpoint accepts text and uses Claude to expand it by adding
 * detail, examples, benefits, and supporting information.
 * 
 * Includes automatic usage logging to track API costs per user.
 */

import { NextRequest, NextResponse } from 'next/server';
import Anthropic from '@anthropic-ai/sdk';
import { validateTextLength, validateNotEmpty, logError } from '@/lib/utils/error-handling';
import { logger } from '@/lib/utils/logger';
// Imports for usage logging and limit checking
import { getUserId, checkUserWithinLimit, usageLimitExceededResponse } from '@/lib/utils/api-auth';
import { supabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Request body structure
 */
interface ExpandRequest {
  text: string;
}

/**
 * Response body structure
 */
interface ExpandResponse {
  expandedText: string;
  originalLength: number;
  newLength: number;
}

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

// ============================================================================
// Constants
// ============================================================================

/**
 * System prompt that establishes Claude's role and expertise
 */
const SYSTEM_PROMPT = `You are an expert copywriter with 40 years of experience. Your job is to expand copy by adding detail, examples, benefits, and supporting information while maintaining the original message and tone.

CRITICAL OUTPUT FORMAT:
You must output valid HTML that preserves the original structure while expanding the content.
Use only these tags:
- <h2> or <h3> for headings and subject lines
- <p> for paragraphs
- <ul> and <li> for bullet lists
- <strong> for bold emphasis
- <em> for italic emphasis

HTML RULES:
- Preserve the original document structure (headings stay headings, bullets stay bullets)
- Expand ONLY the content/detail, NOT the structure
- If input has bullets, output must have bullets (just more detailed)
- If input has headings, output must have headings
- Output ONLY HTML, no markdown, no preamble
- Do NOT add blank lines between tags
- Add detail, examples, benefits, and supporting information

When expanding:
- Keep the original core message and tone intact
- Add relevant details, examples, and supporting facts
- Expand on benefits and value propositions
- Include sensory details and specific scenarios when appropriate
- Make the copy more comprehensive and engaging
- Maintain readability and flow
- Do NOT change the fundamental message or claims
- Do NOT add information that contradicts the original

Return ONLY the expanded HTML, no explanations or preambles.`;

/**
 * Generates a user prompt with the text to expand
 */
function buildUserPrompt(text: string): string {
  return `Expand the following copy by adding detail, examples, benefits, and supporting information. Maintain the original message and tone, but make it more comprehensive and engaging.

CRITICAL: Output must be valid HTML with preserved structure. If the input has headings, keep them as headings. If it has bullets, keep them as bullets (just expanded). Do not add a preamble or explanation - just return the expanded HTML.

Example - expanding while preserving structure:
INPUT:
<p>Our coffee is bold and energizing.</p>
OUTPUT:
<p>Our coffee delivers a <strong>bold, robust flavor profile</strong> that awakens your senses with every sip. The carefully selected beans provide a powerful <strong>energizing kick</strong> that fuels your morning and keeps you focused throughout your entire day, delivering sustained energy without the crash.</p>

ORIGINAL COPY:
${text}

EXPANDED HTML:`;
}

// ============================================================================
// Usage Logging (ADDED)
// ============================================================================

/**
 * Log API usage to Supabase for cost tracking
 * 
 * This function is fire-and-forget - logs errors but doesn't throw.
 * API responses should NOT fail due to logging issues.
 * 
 * @param userId - Clerk user ID
 * @param model - Claude model used
 * @param inputTokens - Number of input tokens
 * @param outputTokens - Number of output tokens
 * @param costUsd - Calculated cost in USD
 */
async function logUsageToSupabase(
  userId: string,
  model: string,
  inputTokens: number,
  outputTokens: number,
  costUsd: number
): Promise<void> {
  // Skip logging if Supabase is not configured
  if (!isSupabaseConfigured() || !supabaseAdmin) {
    logger.log('‚ö†Ô∏è Supabase not configured, skipping usage logging');
    return;
  }

  try {
    const { error } = await (supabaseAdmin
      .from('api_usage_logs') as any)
      .insert({
        user_id: userId,
        model,
        input_tokens: inputTokens,
        output_tokens: outputTokens,
        feature: 'expand',
        cost_usd: costUsd,
        // timestamp is auto-generated by database default
      });

    if (error) {
      // Log error but don't throw - API response should still succeed
      console.error('‚ùå Failed to log expand usage:', error);
    } else {
      logger.log('üìä Expand usage logged:', {
        userId: userId.substring(0, 8) + '...',
        model,
        tokens: inputTokens + outputTokens,
        cost: `$${costUsd.toFixed(6)}`,
      });
    }
  } catch (err) {
    // Log error but don't throw - this is fire-and-forget
    console.error('‚ùå Exception logging expand usage:', err);
  }
}

/**
 * Calculate cost in USD for a Claude API call
 * Based on Claude Sonnet 4 pricing: $3/1M input, $15/1M output
 */
function calculateCost(inputTokens: number, outputTokens: number): number {
  const inputCost = (inputTokens / 1_000_000) * 3;
  const outputCost = (outputTokens / 1_000_000) * 15;
  // Round to 6 decimal places for precision
  return Math.round((inputCost + outputCost) * 1_000_000) / 1_000_000;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * POST /api/expand
 * 
 * Expands copy using Claude AI
 * 
 * @param request - Next.js request object containing text
 * @returns JSON response with expanded text or error
 */
export async function POST(request: NextRequest): Promise<NextResponse<ExpandResponse | ErrorResponse>> {
  try {
    // ------------------------------------------------------------------------
    // 1. Check usage limit BEFORE processing request
    // ------------------------------------------------------------------------
    
    const userId = await getUserId();
    
    if (userId) {
      const usageCheck = await checkUserWithinLimit(userId);
      
      if (!usageCheck.withinLimit) {
        logger.log('üö´ User exceeded usage limit:', {
          userId: userId.substring(0, 8) + '...',
          totalCost: `$${usageCheck.totalCost.toFixed(4)}`,
        });
        return usageLimitExceededResponse(usageCheck.totalCost);
      }
    }
    
    // ------------------------------------------------------------------------
    // 2. Parse and validate request body
    // ------------------------------------------------------------------------
    
    let body: Partial<ExpandRequest>;
    
    try {
      body = await request.json();
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid JSON in request body',
          details: 'Please send valid JSON with a "text" field'
        },
        { status: 400 }
      );
    }

    const { text } = body;

    // Validate required fields
    if (!text || typeof text !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "text" field',
          details: 'Please provide the copy to expand as a string in the "text" field'
        },
        { status: 400 }
      );
    }

    // Validate text
    try {
      validateNotEmpty(text, 'Text');
      validateTextLength(text, 'Text');
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid text',
          details: error instanceof Error ? error.message : 'Please provide valid text to expand'
        },
        { status: 400 }
      );
    }

    // ------------------------------------------------------------------------
    // 2. Initialize Anthropic client
    // ------------------------------------------------------------------------
    
    // Read API key from environment variables
    const apiKey = process.env.ANTHROPIC_API_KEY;
    
    if (!apiKey) {
      logger.error('‚ùå ANTHROPIC_API_KEY not found in environment variables');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Server configuration error',
          details: 'API key not configured. Please contact support.'
        },
        { status: 500 }
      );
    }

    // Create Anthropic client instance
    const anthropic = new Anthropic({
      apiKey: apiKey,
    });

    // ------------------------------------------------------------------------
    // 3. Call Claude API to expand the text
    // ------------------------------------------------------------------------
    
    logger.log('üìù Expand request:', {
      originalLength: text.length,
      preview: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
    });

    // Build the user prompt with the text to expand
    const userPrompt = buildUserPrompt(text);

    // Call Claude's Messages API with timeout
    const message = await Promise.race([
      anthropic.messages.create({
        model: 'claude-sonnet-4-20250514', // Latest Claude Sonnet model
        max_tokens: 4000, // Maximum length of response
        system: SYSTEM_PROMPT, // System prompt defining Claude's role
        messages: [
          {
            role: 'user',
            content: userPrompt, // The actual expansion request
          },
        ],
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Request timed out after 30 seconds')), 30000)
      ),
    ]);

    // ------------------------------------------------------------------------
    // 4. Extract and process the response
    // ------------------------------------------------------------------------
    
    // Claude returns an array of content blocks; we want the text from the first one
    const expandedText = message.content[0].type === 'text' 
      ? message.content[0].text.trim()
      : '';

    if (!expandedText) {
      logger.error('‚ùå Claude returned empty response');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'Claude returned an empty response. Please try again.'
        },
        { status: 500 }
      );
    }

    // Calculate text lengths for comparison
    const originalLength = text.length;
    const newLength = expandedText.length;

    logger.log('‚úÖ Expand successful:', {
      originalLength,
      newLength,
      expansionPercent: ((newLength - originalLength) / originalLength * 100).toFixed(1) + '%',
      preview: expandedText.substring(0, 100) + (expandedText.length > 100 ? '...' : ''),
    });

    // ------------------------------------------------------------------------
    // 5. Log usage to Supabase
    // ------------------------------------------------------------------------
    
    // userId was already retrieved at start for limit check
    if (userId) {
      // Extract token usage from Claude's response
      const inputTokens = message.usage.input_tokens;
      const outputTokens = message.usage.output_tokens;
      
      // Calculate cost based on Claude Sonnet 4 pricing
      const costUsd = calculateCost(inputTokens, outputTokens);
      
      // Fire-and-forget logging - don't await, let it run in background
      // This ensures logging failures don't slow down or break the API response
      logUsageToSupabase(
        userId,
        'claude-sonnet-4-20250514', // Model used in this route
        inputTokens,
        outputTokens,
        costUsd
      ).catch(err => {
        // Extra safety net - should never throw but just in case
        console.error('‚ùå Unexpected error in expand usage logging:', err);
      });
    } else {
      logger.log('‚ö†Ô∏è No user ID found, skipping usage logging for expand');
    }

    // ------------------------------------------------------------------------
    // 6. Return the expanded text
    // ------------------------------------------------------------------------
    
    return NextResponse.json<ExpandResponse>(
      {
        expandedText,
        originalLength,
        newLength,
      },
      { status: 200 }
    );

  } catch (error) {
    // ------------------------------------------------------------------------
    // Error Handling
    // ------------------------------------------------------------------------
    
    logError(error, 'Expand API');

    // Handle timeout errors
    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Request timeout',
          details: 'The request took too long. Please try again with shorter text.'
        },
        { status: 408 }
      );
    }

    // Handle Anthropic-specific errors
    if (error instanceof Anthropic.APIError) {
      let userMessage = 'AI service error. Please try again.';
      
      if (error.status === 429) {
        userMessage = 'Rate limit exceeded. Please wait a moment and try again.';
      } else if (error.status === 500 || error.status === 503) {
        userMessage = 'AI service temporarily unavailable. Please try again in a moment.';
      }

      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI service error',
          details: userMessage
        },
        { status: error.status || 500 }
      );
    }

    // Handle generic errors
    return NextResponse.json<ErrorResponse>(
      { 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'An unexpected error occurred. Please try again.'
      },
      { status: 500 }
    );
  }
}


=== FILE: app/api/generate-section/route.ts ===

/**
 * @file app/api/generate-section/route.ts
 * @description API route for generating individual brochure sections using Claude AI
 * 
 * This endpoint handles section-by-section generation for multi-section templates,
 * providing context from previous sections for consistent tone and messaging.
 */

import { NextRequest, NextResponse } from 'next/server';
import Anthropic from '@anthropic-ai/sdk';
import { buildSectionPrompt, getSectionById } from '@/lib/templates/brochure-multi-section-config';
import type { SectionGenerationRequest, SectionGenerationResponse } from '@/lib/types/template-progress';
import { logError } from '@/lib/utils/error-handling';
import { logger } from '@/lib/utils/logger';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Build brand voice instructions for Claude
 */
function buildBrandVoiceInstructions(brandVoice: NonNullable<SectionGenerationRequest['brandVoice']>): string {
  return `Brand: ${brandVoice.brandName}
Tone: ${brandVoice.brandTone}
Approved Phrases: ${brandVoice.approvedPhrases.join(', ')}
Forbidden Words: ${brandVoice.forbiddenWords.join(', ')}
Brand Values: ${brandVoice.brandValues.join(', ')}
Mission: ${brandVoice.missionStatement}

Apply these brand guidelines to all copy generated.`;
}

/**
 * Build persona instructions for Claude
 */
function buildPersonaInstructions(persona: NonNullable<SectionGenerationRequest['persona']>): string {
  return `Target Persona: ${persona.name}
Demographics: ${persona.demographics}
Psychographics: ${persona.psychographics}
Pain Points: ${persona.painPoints}
Language Patterns: ${persona.languagePatterns}
Goals: ${persona.goals}

Write specifically for this persona's context and use language that resonates with them.`;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * POST /api/generate-section
 * 
 * Generates a single brochure section using Claude AI with context from previous sections
 * 
 * @param request - Next.js request object containing section generation request
 * @returns JSON response with generated content or error
 */
export async function POST(request: NextRequest): Promise<NextResponse<SectionGenerationResponse | ErrorResponse>> {
  try {
    // ------------------------------------------------------------------------
    // 1. Parse and validate request body
    // ------------------------------------------------------------------------
    
    let body: Partial<SectionGenerationRequest>;
    
    try {
      body = await request.json();
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid JSON in request body',
          details: 'Please send valid JSON with required fields'
        },
        { status: 400 }
      );
    }

    const { 
      templateId, 
      sectionId, 
      sectionIndex,
      formData, 
      previousContent, 
      applyBrandVoice, 
      brandVoice, 
      persona 
    } = body;

    // Validate required fields
    if (!templateId || typeof templateId !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "templateId" field',
          details: 'Please provide the template ID as a string'
        },
        { status: 400 }
      );
    }

    if (!sectionId || typeof sectionId !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "sectionId" field',
          details: 'Please provide the section ID as a string'
        },
        { status: 400 }
      );
    }

    if (!formData || typeof formData !== 'object') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "formData" field',
          details: 'Please provide form data as an object'
        },
        { status: 400 }
      );
    }

    // ------------------------------------------------------------------------
    // 2. Validate section exists
    // ------------------------------------------------------------------------
    
    const section = getSectionById(sectionId);
    
    if (!section) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Section not found',
          details: `No section found with ID: ${sectionId}`
        },
        { status: 404 }
      );
    }

    // Validate required fields for this section
    const missingFields = section.fields
      .filter((field) => {
        // Check if field is required and empty
        if (!field.required) return false;
        
        // Handle conditional fields
        if (field.conditionalOn) {
          const conditionValue = formData[field.conditionalOn.fieldId];
          const conditionMet = Array.isArray(field.conditionalOn.value)
            ? field.conditionalOn.value.includes(conditionValue)
            : conditionValue === field.conditionalOn.value;
          
          // If condition not met, field is not required
          if (!conditionMet) return false;
        }
        
        return !formData[field.id]?.trim();
      })
      .map((field) => field.label);
    
    if (missingFields.length > 0) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing required fields',
          details: `Please fill in: ${missingFields.join(', ')}`
        },
        { status: 400 }
      );
    }

    // ------------------------------------------------------------------------
    // 3. Initialize Anthropic client
    // ------------------------------------------------------------------------
    
    const apiKey = process.env.ANTHROPIC_API_KEY;
    
    if (!apiKey) {
      logger.error('‚ùå ANTHROPIC_API_KEY not found in environment variables');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Server configuration error',
          details: 'API key not configured. Please contact support.'
        },
        { status: 500 }
      );
    }

    const anthropic = new Anthropic({
      apiKey: apiKey,
    });

    // ------------------------------------------------------------------------
    // 4. Build the prompt with context
    // ------------------------------------------------------------------------
    
    const brandVoiceInstructions = applyBrandVoice && brandVoice 
      ? buildBrandVoiceInstructions(brandVoice)
      : undefined;
    
    const personaInstructions = persona 
      ? buildPersonaInstructions(persona)
      : undefined;

    const prompt = buildSectionPrompt(
      sectionId,
      formData,
      previousContent,
      brandVoiceInstructions,
      personaInstructions
    );

    logger.log(`üìÑ Generating section: ${section.name} (${sectionId})`);
    logger.log(`üìä Previous content length: ${previousContent?.length || 0} chars`);
    logger.log(`üé® Brand voice: ${applyBrandVoice ? 'enabled' : 'disabled'}`);
    logger.log(`üë§ Persona: ${persona?.name || 'none'}`);

    // ------------------------------------------------------------------------
    // 5. Call Claude API to generate section
    // ------------------------------------------------------------------------
    
    const timeoutMs = 45000; // 45 seconds timeout for section generation
    
    const message = await Promise.race([
      anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 2000, // Shorter than full template since it's a single section
        system: `You are an expert B2B copywriter creating brochure content. 

OUTPUT FORMAT RULES:
1. Output ONLY valid HTML using: <h2>, <h3>, <p>, <ul>, <li>, <strong>, <em>
2. Each paragraph MUST be wrapped in <p> tags
3. Use <ul><li> for bullet lists
4. Use <strong> for key phrases to emphasize
5. Do NOT include section headers/titles - those are added separately
6. Do NOT include markdown syntax - HTML only
7. Output ONLY the content, no preamble or explanation
8. Keep copy concise and benefit-focused

Generate professional, engaging brochure copy that converts.`,
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error(`Request timed out after ${timeoutMs / 1000} seconds`)), timeoutMs)
      ),
    ]);

    // ------------------------------------------------------------------------
    // 6. Extract and process the response
    // ------------------------------------------------------------------------
    
    const generatedContent = message.content[0].type === 'text' 
      ? message.content[0].text.trim()
      : '';

    if (!generatedContent) {
      logger.error('‚ùå Claude returned empty response');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'Claude returned an empty response. Please try again.'
        },
        { status: 500 }
      );
    }

    logger.log(`‚úÖ Section generated: ${generatedContent.length} chars`);

    // ------------------------------------------------------------------------
    // 7. Return the generated section
    // ------------------------------------------------------------------------
    
    return NextResponse.json<SectionGenerationResponse>(
      {
        generatedContent,
        sectionId,
        metadata: {
          textLength: generatedContent.length,
          sectionName: section.name,
          brandVoiceApplied: Boolean(applyBrandVoice && brandVoice),
          personaUsed: Boolean(persona),
        },
      },
      { status: 200 }
    );

  } catch (error) {
    // ------------------------------------------------------------------------
    // Error Handling
    // ------------------------------------------------------------------------
    
    logError(error, 'Section generation API');

    // Handle timeout errors
    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Request timeout',
          details: 'Section generation took too long. Please try again.'
        },
        { status: 408 }
      );
    }

    // Handle Anthropic-specific errors
    if (error instanceof Anthropic.APIError) {
      let userMessage = 'AI service error. Please try again.';
      
      if (error.status === 429) {
        userMessage = 'Rate limit exceeded. Please wait a moment and try again.';
      } else if (error.status === 500 || error.status === 503) {
        userMessage = 'AI service temporarily unavailable. Please try again in a moment.';
      }

      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI service error',
          details: userMessage
        },
        { status: error.status || 500 }
      );
    }

    // Handle generic errors
    return NextResponse.json<ErrorResponse>(
      { 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'An unexpected error occurred. Please try again.'
      },
      { status: 500 }
    );
  }
}


=== FILE: app/api/generate-template/route.ts ===

/**
 * @file app/api/generate-template/route.ts
 * @description API route for generating copy from templates using Claude AI
 * 
 * This endpoint accepts a template ID, form data, optional brand voice,
 * and optional persona, then uses Claude to generate high-quality copy.
 * 
 * Includes automatic usage logging to track API costs per user.
 */

import { NextRequest, NextResponse } from 'next/server';
import Anthropic from '@anthropic-ai/sdk';
import { getTemplateById } from '@/lib/data/templates';
import type { 
  TemplateFormData, 
  TemplateGenerationRequest, 
  TemplateGenerationResponse 
} from '@/lib/types/template';
import type { BrandVoice } from '@/lib/types/brand';
import type { Persona } from '@/lib/types/project';
import { logError } from '@/lib/utils/error-handling';
import { logger } from '@/lib/utils/logger';
// Imports for usage logging and limit checking
import { getUserId, checkUserWithinLimit, usageLimitExceededResponse } from '@/lib/utils/api-auth';
import { supabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Build brand voice instructions for Claude
 */
function buildBrandVoiceInstructions(brandVoice: BrandVoice): string {
  return `
BRAND VOICE REQUIREMENTS:

Brand: ${brandVoice.brandName}
Tone: ${brandVoice.brandTone}
Use these phrases: ${brandVoice.approvedPhrases.join(', ')}
Never use: ${brandVoice.forbiddenWords.join(', ')}
Reflect values: ${brandVoice.brandValues.join(', ')}
Mission context: ${brandVoice.missionStatement}

Write in a way that authentically reflects this brand voice.
`;
}

/**
 * Build persona instructions for Claude
 */
function buildPersonaInstructions(persona: Persona): string {
  return `
TARGET PERSONA:

Name: ${persona.name}
Demographics: ${persona.demographics}
Psychographics: ${persona.psychographics}
Pain Points: ${persona.painPoints}
Language they use: ${persona.languagePatterns}
Goals: ${persona.goals}

Write specifically for this persona's context and use language that resonates with them.
`;
}

/**
 * Replace placeholders in system prompt with form data and context
 */
function buildPrompt(
  systemPrompt: string,
  formData: TemplateFormData,
  brandVoice?: BrandVoice,
  persona?: Persona
): string {
  let prompt = systemPrompt;
  
  // Replace form data placeholders
  Object.entries(formData).forEach(([key, value]) => {
    const placeholder = `{${key}}`;
    prompt = prompt.replace(new RegExp(placeholder, 'g'), value || '(not provided)');
  });
  
  // Replace brand voice placeholder
  if (brandVoice) {
    const brandInstructions = buildBrandVoiceInstructions(brandVoice);
    prompt = prompt.replace('{brandVoiceInstructions}', brandInstructions);
  } else {
    prompt = prompt.replace('{brandVoiceInstructions}', '');
  }
  
  // Replace persona placeholder
  if (persona) {
    const personaInstructions = buildPersonaInstructions(persona);
    prompt = prompt.replace('{personaInstructions}', personaInstructions);
  } else {
    prompt = prompt.replace('{personaInstructions}', '');
  }
  
  return prompt;
}

// ============================================================================
// Usage Logging (ADDED)
// ============================================================================

/**
 * Log API usage to Supabase for cost tracking
 * 
 * This function is fire-and-forget - logs errors but doesn't throw.
 * API responses should NOT fail due to logging issues.
 * 
 * @param userId - Clerk user ID
 * @param model - Claude model used
 * @param inputTokens - Number of input tokens
 * @param outputTokens - Number of output tokens
 * @param costUsd - Calculated cost in USD
 */
async function logUsageToSupabase(
  userId: string,
  model: string,
  inputTokens: number,
  outputTokens: number,
  costUsd: number
): Promise<void> {
  // Skip logging if Supabase is not configured
  if (!isSupabaseConfigured() || !supabaseAdmin) {
    logger.log('‚ö†Ô∏è Supabase not configured, skipping usage logging');
    return;
  }

  try {
    const { error } = await (supabaseAdmin
      .from('api_usage_logs') as any)
      .insert({
        user_id: userId,
        model,
        input_tokens: inputTokens,
        output_tokens: outputTokens,
        feature: 'generate_template',
        cost_usd: costUsd,
        // timestamp is auto-generated by database default
      });

    if (error) {
      // Log error but don't throw - API response should still succeed
      console.error('‚ùå Failed to log generate-template usage:', error);
    } else {
      logger.log('üìä Generate-template usage logged:', {
        userId: userId.substring(0, 8) + '...',
        model,
        tokens: inputTokens + outputTokens,
        cost: `$${costUsd.toFixed(6)}`,
      });
    }
  } catch (err) {
    // Log error but don't throw - this is fire-and-forget
    console.error('‚ùå Exception logging generate-template usage:', err);
  }
}

/**
 * Calculate cost in USD for a Claude API call
 * Based on Claude Sonnet 4 pricing: $3/1M input, $15/1M output
 */
function calculateCost(inputTokens: number, outputTokens: number): number {
  const inputCost = (inputTokens / 1_000_000) * 3;
  const outputCost = (outputTokens / 1_000_000) * 15;
  // Round to 6 decimal places for precision
  return Math.round((inputCost + outputCost) * 1_000_000) / 1_000_000;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * Extract number of emails from form data for email sequence templates
 * @param formData - Form data from request
 * @returns Number of emails (1 if not an email sequence)
 */
function getEmailSequenceCount(formData: TemplateFormData): number {
  const numberOfEmails = formData.numberOfEmails;
  if (!numberOfEmails) return 1;
  
  // Parse "X emails" format (e.g., "5 emails" -> 5)
  const match = numberOfEmails.match(/^(\d+)/);
  return match ? parseInt(match[1], 10) : 1;
}

/**
 * POST /api/generate-template
 * 
 * Generates copy from a template using Claude AI
 * 
 * @param request - Next.js request object containing template generation request
 * @returns JSON response with generated copy or error
 */
export async function POST(request: NextRequest): Promise<NextResponse<TemplateGenerationResponse | ErrorResponse>> {
  try {
    // ------------------------------------------------------------------------
    // 1. Check usage limit BEFORE processing request
    // ------------------------------------------------------------------------
    
    const userId = await getUserId();
    
    if (userId) {
      const usageCheck = await checkUserWithinLimit(userId);
      
      if (!usageCheck.withinLimit) {
        logger.log('üö´ User exceeded usage limit:', {
          userId: userId.substring(0, 8) + '...',
          totalCost: `$${usageCheck.totalCost.toFixed(4)}`,
        });
        return usageLimitExceededResponse(usageCheck.totalCost);
      }
    }
    
    // ------------------------------------------------------------------------
    // 2. Parse and validate request body
    // ------------------------------------------------------------------------
    
    let body: Partial<TemplateGenerationRequest>;
    
    try {
      body = await request.json();
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid JSON in request body',
          details: 'Please send valid JSON with required fields'
        },
        { status: 400 }
      );
    }

    const { templateId, formData, applyBrandVoice, brandVoice, personaId, persona } = body;

    // Validate required fields
    if (!templateId || typeof templateId !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "templateId" field',
          details: 'Please provide the template ID as a string'
        },
        { status: 400 }
      );
    }

    if (!formData || typeof formData !== 'object') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "formData" field',
          details: 'Please provide form data as an object'
        },
        { status: 400 }
      );
    }

    // ------------------------------------------------------------------------
    // 2. Load template and validate
    // ------------------------------------------------------------------------
    
    const template = getTemplateById(templateId);
    
    if (!template) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Template not found',
          details: `No template found with ID: ${templateId}`
        },
        { status: 404 }
      );
    }

    // Validate required fields are filled
    const missingFields = template.fields
      .filter((field) => field.required && !formData[field.id]?.trim())
      .map((field) => field.label);
    
    if (missingFields.length > 0) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing required fields',
          details: `Please fill in: ${missingFields.join(', ')}`
        },
        { status: 400 }
      );
    }

    // ------------------------------------------------------------------------
    // 3. Initialize Anthropic client
    // ------------------------------------------------------------------------
    
    const apiKey = process.env.ANTHROPIC_API_KEY;
    
    if (!apiKey) {
      logger.error('‚ùå ANTHROPIC_API_KEY not found in environment variables');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Server configuration error',
          details: 'API key not configured. Please contact support.'
        },
        { status: 500 }
      );
    }

    const anthropic = new Anthropic({
      apiKey: apiKey,
    });

    // ------------------------------------------------------------------------
    // 4. Build prompt from template
    // ------------------------------------------------------------------------
    
    const prompt = buildPrompt(
      template.systemPrompt,
      formData,
      applyBrandVoice && brandVoice ? brandVoice : undefined,
      persona || undefined
    );

    // ------------------------------------------------------------------------
    // 5. Calculate dynamic timeout and tokens for email sequences
    // ------------------------------------------------------------------------
    
    const isEmailSequence = templateId === 'email-sequence-kickoff';
    const emailCount = isEmailSequence ? getEmailSequenceCount(formData) : 1;
    
    // Dynamic timeout: 30s base + 20s per email for sequences
    // 3 emails = 90s, 5 emails = 130s, 7 emails = 170s
    const timeoutMs = isEmailSequence 
      ? 30000 + (emailCount * 20000)
      : 30000;
    
    // Dynamic max tokens: ~1000 tokens per email (subject + body + formatting)
    // Base 4000 for single content, scale up for sequences
    const maxTokens = isEmailSequence 
      ? Math.min(8000, 1200 * emailCount) // Cap at 8000 tokens
      : 4000;
    
    logger.log(`üìß Template: ${templateId}, Emails: ${emailCount}, Timeout: ${timeoutMs}ms, MaxTokens: ${maxTokens}`);

    // ------------------------------------------------------------------------
    // 6. Call Claude API to generate copy
    // ------------------------------------------------------------------------
    
    const message = await Promise.race([
      anthropic.messages.create({
        model: 'claude-sonnet-4-20250514', // Latest Claude Sonnet model
        max_tokens: maxTokens, // Dynamic based on content type
        system: `You are an expert copywriter with 40 years of experience. You create compelling, high-converting copy that resonates with target audiences. Follow all instructions carefully and deliver polished, professional copy.

CRITICAL OUTPUT FORMAT:

You MUST output valid HTML using ONLY these tags:
- <h2> or <h3> for headings and section titles
- <p> for paragraphs
- <ul> and <li> for bullet lists
- <strong> for bold text (important phrases, key benefits)
- <em> for italic text (subtle emphasis)
- <br> for line breaks within paragraphs (use sparingly)

HTML OUTPUT RULES:

1. Each paragraph MUST be wrapped in <p> tags
2. Each heading MUST be wrapped in <h2> or <h3> tags
3. Bullet lists MUST use <ul><li>item</li></ul> structure
4. Use <strong> for emphasis, NOT markdown (**text**)
5. Do NOT include any preamble, explanation, or markdown
6. Output ONLY the HTML content, nothing else
7. Ensure proper tag closure (every opening tag has a closing tag)
8. CRITICAL: Do NOT add blank lines between paragraph tags. Write tags consecutively:
   CORRECT: <p>Text</p><p>Next text</p>
   INCORRECT: <p>Text</p>\n\n<p>Next text</p>
9. Do NOT use markdown syntax - only HTML tags

Example email structure:
<h3>Subject: Your Compelling Subject Line</h3>
<p>Dear Prospect,</p>
<p>Opening paragraph with <strong>key benefit</strong> highlighted that addresses their pain point...</p>
<p>Another paragraph explaining the value proposition and how it solves their problem...</p>
<ul>
<li>First benefit with clear, measurable value</li>
<li>Second benefit that resonates with their goals</li>
<li>Third benefit that closes the deal</li>
</ul>
<p>Closing paragraph with strong call-to-action and urgency...</p>
<p>Best regards,<br>Your Name</p>

Example landing page structure:
<h2>Your Compelling Headline That Communicates Core Benefit</h2>
<h3>Supporting subheadline that expands on the promise and builds interest</h3>
<p>Opening paragraph that introduces the <strong>unique value proposition</strong> and establishes credibility...</p>
<p>Another paragraph elaborating on how it works and why it's different from competitors...</p>
<ul>
<li>Key feature with benefit explanation</li>
<li>Another differentiator that matters to the audience</li>
<li>Final proof point that builds trust</li>
</ul>
<p><strong>Social proof:</strong> Trusted by 5,000+ companies including Fortune 500 brands...</p>

Quality Guidelines:
- Keep HTML clean and properly nested
- Use <h2> for main headlines, <h3> for subheadings
- Each idea gets its own <p> or <li> tag
- Use <strong> strategically for key phrases and CTAs
- Ensure bullets are concise and impactful
- No empty tags or unnecessary nesting

REMEMBER: Output ONLY HTML. No markdown, no preamble, no explanation. Just the HTML content.`,
        messages: [
          {
            role: 'user',
            content: prompt,
          },
        ],
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error(`Request timed out after ${timeoutMs / 1000} seconds`)), timeoutMs)
      ),
    ]);

    // ------------------------------------------------------------------------
    // 6. Extract and process the response
    // ------------------------------------------------------------------------
    
    const generatedCopy = message.content[0].type === 'text' 
      ? message.content[0].text.trim()
      : '';

    if (!generatedCopy) {
      logger.error('‚ùå Claude returned empty response');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'Claude returned an empty response. Please try again.'
        },
        { status: 500 }
      );
    }

    // ------------------------------------------------------------------------
    // 7. Log usage to Supabase
    // ------------------------------------------------------------------------
    
    // userId was already retrieved at start for limit check
    if (userId) {
      // Extract token usage from Claude's response
      const inputTokens = message.usage.input_tokens;
      const outputTokens = message.usage.output_tokens;
      
      // Calculate cost based on Claude Sonnet 4 pricing
      const costUsd = calculateCost(inputTokens, outputTokens);
      
      // Fire-and-forget logging - don't await, let it run in background
      // This ensures logging failures don't slow down or break the API response
      logUsageToSupabase(
        userId,
        'claude-sonnet-4-20250514', // Model used in this route
        inputTokens,
        outputTokens,
        costUsd
      ).catch(err => {
        // Extra safety net - should never throw but just in case
        console.error('‚ùå Unexpected error in generate-template usage logging:', err);
      });
    } else {
      logger.log('‚ö†Ô∏è No user ID found, skipping usage logging for generate-template');
    }

    // ------------------------------------------------------------------------
    // 8. Return the generated copy
    // ------------------------------------------------------------------------
    
    return NextResponse.json<TemplateGenerationResponse>(
      {
        generatedCopy,
        prompt: prompt, // Include for debugging (optional)
        metadata: {
          textLength: generatedCopy.length,
          templateUsed: template.name,
          brandVoiceApplied: Boolean(applyBrandVoice && brandVoice),
          personaUsed: Boolean(persona),
        },
      },
      { status: 200 }
    );

  } catch (error) {
    // ------------------------------------------------------------------------
    // Error Handling
    // ------------------------------------------------------------------------
    
    logError(error, 'Template generation API');

    // Handle timeout errors
    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Request timeout',
          details: 'Template generation took too long. Please try again or simplify your inputs.'
        },
        { status: 408 }
      );
    }

    // Handle Anthropic-specific errors
    if (error instanceof Anthropic.APIError) {
      let userMessage = 'AI service error. Please try again.';
      
      if (error.status === 429) {
        userMessage = 'Rate limit exceeded. Please wait a moment and try again.';
      } else if (error.status === 500 || error.status === 503) {
        userMessage = 'AI service temporarily unavailable. Please try again in a moment.';
      }

      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI service error',
          details: userMessage
        },
        { status: error.status || 500 }
      );
    }

    // Handle generic errors
    return NextResponse.json<ErrorResponse>(
      { 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'An unexpected error occurred. Please try again.'
      },
      { status: 500 }
    );
  }
}

// ============================================================================
// Future Enhancements (TODO)
// ============================================================================

/**
 * TODO: Rate Limiting
 * - Implement per-user rate limiting
 * - Use Redis or Upstash for distributed rate limiting
 * - Return 429 status when rate limit exceeded
 */

/**
 * TODO: Caching
 * - Cache generation results for identical inputs
 * - Use Redis or edge cache (Vercel KV)
 * - Set TTL to 24 hours
 * - Reduces API costs and improves response time
 */

/**
 * TODO: Cost Tracking
 * - Log token usage per request
 * - Track costs per user/organization
 * - Set up usage alerts for high-volume users
 */

/**
 * TODO: Template Versioning
 * - Track template versions
 * - Allow A/B testing different prompt variations
 * - Analytics on which templates perform best
 */


=== FILE: app/api/optimize-alignment/route.ts ===

/**
 * @file app/api/optimize-alignment/route.ts
 * @description API route for rewriting copy to optimize alignment with persona or brand
 * 
 * This endpoint takes copy that has been analyzed for alignment issues and
 * rewrites it to fix those specific issues while preserving strengths.
 * 
 * Includes automatic usage logging to track API costs per user.
 */

import { NextRequest, NextResponse } from 'next/server';
import Anthropic from '@anthropic-ai/sdk';
import { validateTextLength, validateNotEmpty, logError } from '@/lib/utils/error-handling';
import { logger } from '@/lib/utils/logger';
import { getUserId, checkUserWithinLimit, usageLimitExceededResponse } from '@/lib/utils/api-auth';
import { supabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import type { 
  OptimizeAlignmentRequest, 
  OptimizeAlignmentResponse,
  OptimizeAnalysisContext,
  OptimizePersonaContext,
  OptimizeBrandContext,
} from '@/lib/types/brand';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

// ============================================================================
// Constants
// ============================================================================

/**
 * System prompt for persona alignment optimization
 */
const PERSONA_SYSTEM_PROMPT = `You are an expert copywriter with 40 years of experience specializing in audience-targeted messaging. Your job is to rewrite copy to better resonate with a specific target persona.

CRITICAL OUTPUT FORMAT:
You must output valid HTML that preserves the original structure while optimizing the content.
Use only these tags:
- <h2> or <h3> for headings and subject lines
- <p> for paragraphs
- <ul> and <li> for bullet lists
- <strong> for bold emphasis
- <em> for italic emphasis

REWRITING RULES:
1. ONLY fix the specific alignment issues identified - do NOT rewrite everything
2. PRESERVE what's working well (the identified strengths)
3. Maintain the original structure and formatting
4. Keep the core message intact
5. Match the persona's language patterns and vocabulary
6. Address their pain points and goals
7. Use emotional triggers that resonate with their psychographics
8. Keep similar length - don't pad or over-expand

Return ONLY the rewritten HTML content, no explanations or preambles.`;

/**
 * System prompt for brand alignment optimization
 */
const BRAND_SYSTEM_PROMPT = `You are an expert copywriter with 40 years of experience specializing in brand voice consistency. Your job is to rewrite copy to better align with brand voice guidelines.

CRITICAL OUTPUT FORMAT:
You must output valid HTML that preserves the original structure while optimizing the content.
Use only these tags:
- <h2> or <h3> for headings and subject lines
- <p> for paragraphs
- <ul> and <li> for bullet lists
- <strong> for bold emphasis
- <em> for italic emphasis

REWRITING RULES:
1. ONLY fix the specific brand voice violations identified - do NOT rewrite everything
2. PRESERVE what's working well (the identified matches)
3. Maintain the original structure and formatting
4. Keep the core message intact
5. Use approved phrases where appropriate
6. REMOVE or replace any forbidden words/phrases
7. Match the brand tone consistently throughout
8. Align with brand values and mission
9. Keep similar length - don't pad or over-expand

Return ONLY the rewritten HTML content, no explanations or preambles.`;

/**
 * Generates a user prompt for persona optimization
 */
function buildPersonaPrompt(
  text: string, 
  analysis: OptimizeAnalysisContext, 
  persona: OptimizePersonaContext
): string {
  return `Rewrite this copy to better align with the target persona. Focus ONLY on fixing the identified issues while preserving the strengths.

TARGET PERSONA:
Name: ${persona.name}
${persona.demographics ? `Demographics: ${persona.demographics}` : ''}
${persona.psychographics ? `Psychographics: ${persona.psychographics}` : ''}
${persona.painPoints ? `Pain Points: ${persona.painPoints}` : ''}
${persona.goals ? `Goals: ${persona.goals}` : ''}

ANALYSIS RESULTS:
Current Score: ${analysis.score}%
Assessment: ${analysis.assessment}

STRENGTHS TO PRESERVE (do not change these aspects):
${analysis.strengths.length > 0 ? analysis.strengths.map(s => `‚Ä¢ ${s}`).join('\n') : '‚Ä¢ None identified'}

ISSUES TO FIX (focus your changes here):
${analysis.issues.length > 0 ? analysis.issues.map(i => `‚Ä¢ ${i}`).join('\n') : '‚Ä¢ None identified'}

RECOMMENDATIONS TO IMPLEMENT:
${analysis.recommendations.length > 0 ? analysis.recommendations.map(r => `‚Ä¢ ${r}`).join('\n') : '‚Ä¢ None identified'}

ORIGINAL COPY TO REWRITE:
${text}

INSTRUCTIONS:
1. Preserve the strengths listed above - don't change what's already working
2. Fix ONLY the specific issues identified
3. Implement the recommendations where possible
4. Keep the same structure (headings, bullets, paragraphs)
5. Maintain similar length

Return ONLY the rewritten HTML:`;
}

/**
 * Generates a user prompt for brand optimization
 */
function buildBrandPrompt(
  text: string, 
  analysis: OptimizeAnalysisContext, 
  brand: OptimizeBrandContext
): string {
  return `Rewrite this copy to better align with the brand voice. Focus ONLY on fixing the identified violations while preserving what matches well.

BRAND VOICE GUIDELINES:
Brand Name: ${brand.brandName}
${brand.brandTone ? `Tone: ${brand.brandTone}` : ''}
${brand.missionStatement ? `Mission: ${brand.missionStatement}` : ''}
${brand.brandValues && brand.brandValues.length > 0 ? `Values: ${brand.brandValues.join(', ')}` : ''}
${brand.approvedPhrases && brand.approvedPhrases.length > 0 ? `\nApproved Phrases to USE:\n${brand.approvedPhrases.map(p => `‚Ä¢ "${p}"`).join('\n')}` : ''}
${brand.forbiddenWords && brand.forbiddenWords.length > 0 ? `\nForbidden Words to AVOID:\n${brand.forbiddenWords.map(w => `‚Ä¢ "${w}"`).join('\n')}` : ''}

ANALYSIS RESULTS:
Current Score: ${analysis.score}%
Assessment: ${analysis.assessment}

WHAT MATCHES WELL (preserve these aspects):
${analysis.strengths.length > 0 ? analysis.strengths.map(s => `‚Ä¢ ${s}`).join('\n') : '‚Ä¢ None identified'}

VIOLATIONS TO FIX (focus your changes here):
${analysis.issues.length > 0 ? analysis.issues.map(i => `‚Ä¢ ${i}`).join('\n') : '‚Ä¢ None identified'}

RECOMMENDATIONS TO IMPLEMENT:
${analysis.recommendations.length > 0 ? analysis.recommendations.map(r => `‚Ä¢ ${r}`).join('\n') : '‚Ä¢ None identified'}

ORIGINAL COPY TO REWRITE:
${text}

INSTRUCTIONS:
1. Preserve what matches the brand voice - don't change what's already working
2. Fix ONLY the specific violations identified
3. Replace any forbidden words with brand-appropriate alternatives
4. Use approved phrases where they fit naturally
5. Keep the same structure (headings, bullets, paragraphs)
6. Maintain similar length

Return ONLY the rewritten HTML:`;
}

/**
 * Generates a summary of changes prompt
 */
function buildChangesSummaryPrompt(original: string, rewritten: string): string {
  return `Compare these two versions of copy and provide a brief summary of the key changes made.

ORIGINAL:
${original}

REWRITTEN:
${rewritten}

Provide 2-4 brief bullet points summarizing the main changes. Format as a JSON array of strings.
Example: ["Changed generic greeting to persona-specific language", "Added industry terminology", "Softened aggressive sales tone"]

Return ONLY the JSON array:`;
}

// ============================================================================
// Usage Logging
// ============================================================================

/**
 * Log API usage to Supabase for cost tracking
 */
async function logUsageToSupabase(
  userId: string,
  model: string,
  inputTokens: number,
  outputTokens: number,
  costUsd: number
): Promise<void> {
  if (!isSupabaseConfigured() || !supabaseAdmin) {
    logger.log('‚ö†Ô∏è Supabase not configured, skipping usage logging');
    return;
  }

  try {
    const { error } = await (supabaseAdmin
      .from('api_usage_logs') as any)
      .insert({
        user_id: userId,
        model,
        input_tokens: inputTokens,
        output_tokens: outputTokens,
        feature: 'optimize-alignment',
        cost_usd: costUsd,
      });

    if (error) {
      console.error('‚ùå Failed to log optimize-alignment usage:', error);
    } else {
      logger.log('üìä Optimize-alignment usage logged:', {
        userId: userId.substring(0, 8) + '...',
        model,
        tokens: inputTokens + outputTokens,
        cost: `$${costUsd.toFixed(6)}`,
      });
    }
  } catch (err) {
    console.error('‚ùå Exception logging optimize-alignment usage:', err);
  }
}

/**
 * Calculate cost in USD for a Claude API call
 * Based on Claude Sonnet 4 pricing: $3/1M input, $15/1M output
 */
function calculateCost(inputTokens: number, outputTokens: number): number {
  const inputCost = (inputTokens / 1_000_000) * 3;
  const outputCost = (outputTokens / 1_000_000) * 15;
  return Math.round((inputCost + outputCost) * 1_000_000) / 1_000_000;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * POST /api/optimize-alignment
 * 
 * Rewrites copy to optimize alignment with persona or brand
 */
export async function POST(request: NextRequest): Promise<NextResponse<OptimizeAlignmentResponse | ErrorResponse>> {
  let totalInputTokens = 0;
  let totalOutputTokens = 0;

  try {
    // ------------------------------------------------------------------------
    // 1. Check usage limit BEFORE processing request
    // ------------------------------------------------------------------------
    
    const userId = await getUserId();
    
    if (userId) {
      const usageCheck = await checkUserWithinLimit(userId);
      
      if (!usageCheck.withinLimit) {
        logger.log('üö´ User exceeded usage limit:', {
          userId: userId.substring(0, 8) + '...',
          totalCost: `$${usageCheck.totalCost.toFixed(4)}`,
        });
        return usageLimitExceededResponse(usageCheck.totalCost);
      }
    }
    
    // ------------------------------------------------------------------------
    // 2. Parse and validate request body
    // ------------------------------------------------------------------------
    
    let body: Partial<OptimizeAlignmentRequest>;
    
    try {
      body = await request.json();
    } catch {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid JSON in request body',
          details: 'Please send valid JSON'
        },
        { status: 400 }
      );
    }

    const { text, type, analysisContext, personaContext, brandContext } = body;

    // Validate required fields
    if (!text || typeof text !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "text" field',
          details: 'Please provide the copy to optimize'
        },
        { status: 400 }
      );
    }

    if (!type || (type !== 'persona' && type !== 'brand')) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "type" field',
          details: 'Type must be "persona" or "brand"'
        },
        { status: 400 }
      );
    }

    if (!analysisContext || typeof analysisContext !== 'object') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "analysisContext" field',
          details: 'Please provide the analysis results'
        },
        { status: 400 }
      );
    }

    // Validate type-specific context
    if (type === 'persona' && (!personaContext || !personaContext.name)) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing "personaContext" for persona optimization',
          details: 'Please provide persona details'
        },
        { status: 400 }
      );
    }

    if (type === 'brand' && (!brandContext || !brandContext.brandName)) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing "brandContext" for brand optimization',
          details: 'Please provide brand voice details'
        },
        { status: 400 }
      );
    }

    // Validate text
    try {
      validateNotEmpty(text, 'Text');
      validateTextLength(text, 'Text');
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid text',
          details: error instanceof Error ? error.message : 'Please provide valid text'
        },
        { status: 400 }
      );
    }

    // ------------------------------------------------------------------------
    // 3. Initialize Anthropic client
    // ------------------------------------------------------------------------
    
    const apiKey = process.env.ANTHROPIC_API_KEY;
    
    if (!apiKey) {
      logger.error('‚ùå ANTHROPIC_API_KEY not found');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Server configuration error',
          details: 'API key not configured. Please contact support.'
        },
        { status: 500 }
      );
    }

    const anthropic = new Anthropic({ apiKey });

    // ------------------------------------------------------------------------
    // 4. Build and send optimization request
    // ------------------------------------------------------------------------
    
    const targetName = type === 'persona' 
      ? personaContext!.name 
      : brandContext!.brandName;

    logger.log('üìù Optimize alignment request:', {
      type,
      targetName,
      textLength: text.length,
      score: analysisContext.score,
      issuesCount: analysisContext.issues?.length || 0,
    });

    const systemPrompt = type === 'persona' 
      ? PERSONA_SYSTEM_PROMPT 
      : BRAND_SYSTEM_PROMPT;

    const userPrompt = type === 'persona'
      ? buildPersonaPrompt(text, analysisContext as OptimizeAnalysisContext, personaContext!)
      : buildBrandPrompt(text, analysisContext as OptimizeAnalysisContext, brandContext!);

    // Call Claude API for rewrite with timeout
    const rewriteMessage = await Promise.race([
      anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 4000,
        system: systemPrompt,
        messages: [{ role: 'user', content: userPrompt }],
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Request timed out after 45 seconds')), 45000)
      ),
    ]);

    totalInputTokens += rewriteMessage.usage.input_tokens;
    totalOutputTokens += rewriteMessage.usage.output_tokens;

    const rewrittenText = rewriteMessage.content[0].type === 'text'
      ? rewriteMessage.content[0].text.trim()
      : '';

    if (!rewrittenText) {
      logger.error('‚ùå Claude returned empty rewrite');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'AI returned an empty response. Please try again.'
        },
        { status: 500 }
      );
    }

    // ------------------------------------------------------------------------
    // 5. Get changes summary
    // ------------------------------------------------------------------------
    
    const summaryPrompt = buildChangesSummaryPrompt(text, rewrittenText);
    
    const summaryMessage = await Promise.race([
      anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 500,
        messages: [{ role: 'user', content: summaryPrompt }],
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Summary request timed out')), 15000)
      ),
    ]);

    totalInputTokens += summaryMessage.usage.input_tokens;
    totalOutputTokens += summaryMessage.usage.output_tokens;

    let changesSummary: string[] = [];
    try {
      const summaryText = summaryMessage.content[0].type === 'text'
        ? summaryMessage.content[0].text.trim()
        : '[]';
      const cleanedSummary = summaryText.replace(/```json\n?/g, '').replace(/```\n?/g, '');
      changesSummary = JSON.parse(cleanedSummary);
      
      if (!Array.isArray(changesSummary)) {
        changesSummary = ['Copy optimized for better alignment'];
      }
    } catch {
      logger.warn('‚ö†Ô∏è Could not parse changes summary');
      changesSummary = ['Copy optimized for better alignment'];
    }

    // ------------------------------------------------------------------------
    // 6. Log usage
    // ------------------------------------------------------------------------
    
    if (userId) {
      const costUsd = calculateCost(totalInputTokens, totalOutputTokens);
      
      logUsageToSupabase(
        userId,
        'claude-sonnet-4-20250514',
        totalInputTokens,
        totalOutputTokens,
        costUsd
      ).catch(err => {
        console.error('‚ùå Unexpected error in optimize-alignment usage logging:', err);
      });
    }

    logger.log('‚úÖ Optimize alignment complete:', {
      targetName,
      originalLength: text.length,
      newLength: rewrittenText.length,
      changesCount: changesSummary.length,
    });

    // ------------------------------------------------------------------------
    // 7. Return the optimized result
    // ------------------------------------------------------------------------
    
    return NextResponse.json<OptimizeAlignmentResponse>(
      {
        rewrittenText,
        changesSummary,
        originalLength: text.length,
        newLength: rewrittenText.length,
        targetName,
      },
      { status: 200 }
    );

  } catch (error) {
    logError(error, 'Optimize alignment API');

    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Request timeout',
          details: 'The optimization took too long. Please try again with shorter text.'
        },
        { status: 408 }
      );
    }

    if (error instanceof Anthropic.APIError) {
      let userMessage = 'AI service error. Please try again.';
      
      if (error.status === 429) {
        userMessage = 'Rate limit exceeded. Please wait a moment and try again.';
      } else if (error.status === 500 || error.status === 503) {
        userMessage = 'AI service temporarily unavailable. Please try again in a moment.';
      }

      return NextResponse.json<ErrorResponse>(
        { error: 'AI service error', details: userMessage },
        { status: error.status || 500 }
      );
    }

    return NextResponse.json<ErrorResponse>(
      { 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'An unexpected error occurred.'
      },
      { status: 500 }
    );
  }
}


=== FILE: app/api/persona-alignment/route.ts ===

/**
 * @file app/api/persona-alignment/route.ts
 * @description API route for checking copy alignment with target persona using Claude AI
 * 
 * This endpoint accepts text and persona configuration, then uses Claude to analyze
 * how well the copy resonates with the target persona.
 */

import { NextRequest, NextResponse } from 'next/server';
import Anthropic from '@anthropic-ai/sdk';
import { validateTextLength, validateNotEmpty, logError } from '@/lib/utils/error-handling';
import type { Persona } from '@/lib/types/project';
import { logger } from '@/lib/utils/logger';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Persona alignment result structure
 */
interface PersonaAlignmentResult {
  score: number;
  assessment: string;
  strengths: string[];
  improvements: string[];
  recommendations: string[];
}

/**
 * Request body structure
 */
interface PersonaAlignmentRequest {
  text: string;
  persona: Persona;
}

/**
 * Response structure
 */
interface PersonaAlignmentResponse {
  result: PersonaAlignmentResult;
  textLength: number;
  /** Persona name that was analyzed against */
  personaName: string;
}

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

// ============================================================================
// Constants
// ============================================================================

/**
 * System prompt that establishes Claude's role as a persona alignment analyst
 */
const SYSTEM_PROMPT = `You are an expert copywriter and audience analyst with 40 years of experience. Your job is to analyze copy and assess how well it resonates with a target persona.

When analyzing:
- Consider if the language matches the persona's demographics and communication style
- Check if the copy addresses the persona's pain points
- Assess if the copy speaks to the persona's goals and aspirations
- Evaluate if the psychographic profile would find this copy compelling
- Consider the emotional resonance with the target audience
- Provide specific, actionable recommendations

Be thorough, objective, and provide constructive feedback.`;

/**
 * Generates a user prompt with the text and persona to analyze
 */
function buildUserPrompt(text: string, persona: Persona): string {
  return `Analyze the following copy for persona alignment.

TARGET PERSONA:
Name: ${persona.name}
${persona.demographics ? `Demographics: ${persona.demographics}` : ''}
${persona.psychographics ? `Psychographics: ${persona.psychographics}` : ''}
${persona.painPoints ? `Pain Points: ${persona.painPoints}` : ''}
${persona.goals ? `Goals: ${persona.goals}` : ''}

COPY TO ANALYZE:
${text}

Please provide your analysis in the following JSON format:
{
  "score": [0-100 numeric score],
  "assessment": "[overall assessment in 1-2 sentences explaining how well this copy would resonate with the persona]",
  "strengths": ["list", "of", "things", "that", "work", "well", "for", "this", "persona"],
  "improvements": ["list", "of", "areas", "that", "don't", "quite", "fit", "the", "persona"],
  "recommendations": ["specific", "actionable", "recommendations", "to", "better", "reach", "this", "persona"]
}

Return ONLY the JSON object, no other text.`;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * POST /api/persona-alignment
 * 
 * Checks copy alignment with target persona using Claude AI
 * 
 * @param request - Next.js request object containing text and persona
 * @returns JSON response with alignment analysis or error
 */
export async function POST(request: NextRequest): Promise<NextResponse<PersonaAlignmentResponse | ErrorResponse>> {
  try {
    // ------------------------------------------------------------------------
    // 1. Parse and validate request body
    // ------------------------------------------------------------------------
    
    let body: Partial<PersonaAlignmentRequest>;
    
    try {
      body = await request.json();
    } catch {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid JSON in request body',
          details: 'Please send valid JSON with "text" and "persona" fields'
        },
        { status: 400 }
      );
    }

    const { text, persona } = body;

    // Validate required fields
    if (!text || typeof text !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "text" field',
          details: 'Please provide the copy to analyze as a string in the "text" field'
        },
        { status: 400 }
      );
    }

    if (!persona || typeof persona !== 'object') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "persona" field',
          details: 'Please provide persona configuration'
        },
        { status: 400 }
      );
    }

    // Validate persona has required fields
    if (!persona.name) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid persona',
          details: 'Persona must include name'
        },
        { status: 400 }
      );
    }

    // Validate text
    try {
      validateNotEmpty(text, 'Text');
      validateTextLength(text, 'Text');
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid text',
          details: error instanceof Error ? error.message : 'Please provide valid text to analyze'
        },
        { status: 400 }
      );
    }

    // ------------------------------------------------------------------------
    // 2. Initialize Anthropic client
    // ------------------------------------------------------------------------
    
    const apiKey = process.env.ANTHROPIC_API_KEY;
    
    if (!apiKey) {
      logger.error('‚ùå ANTHROPIC_API_KEY not found in environment variables');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Server configuration error',
          details: 'API key not configured. Please contact support.'
        },
        { status: 500 }
      );
    }

    const anthropic = new Anthropic({
      apiKey: apiKey,
    });

    // ------------------------------------------------------------------------
    // 3. Call Claude API to analyze the text
    // ------------------------------------------------------------------------
    
    logger.log('üìù Persona alignment request:', {
      textLength: text.length,
      personaName: persona.name,
      preview: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
    });

    const userPrompt = buildUserPrompt(text, persona as Persona);

    // Call Claude's Messages API with timeout
    const message = await Promise.race([
      anthropic.messages.create({
        model: 'claude-sonnet-4-20250514',
        max_tokens: 4000,
        system: SYSTEM_PROMPT,
        messages: [
          {
            role: 'user',
            content: userPrompt,
          },
        ],
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Request timed out after 30 seconds')), 30000)
      ),
    ]);

    // ------------------------------------------------------------------------
    // 4. Extract and process the response
    // ------------------------------------------------------------------------
    
    const responseText = message.content[0].type === 'text' 
      ? message.content[0].text.trim()
      : '';

    if (!responseText) {
      logger.error('‚ùå Claude returned empty response');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'Claude returned an empty response. Please try again.'
        },
        { status: 500 }
      );
    }

    // Parse the JSON response from Claude
    let result: PersonaAlignmentResult;
    try {
      // Remove any markdown code blocks if present
      const cleanedResponse = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '');
      result = JSON.parse(cleanedResponse);
      
      // Validate result structure
      if (typeof result.score !== 'number' || !result.assessment) {
        throw new Error('Invalid result format');
      }
      
      // Ensure arrays exist
      result.strengths = result.strengths || [];
      result.improvements = result.improvements || [];
      result.recommendations = result.recommendations || [];
      
    } catch {
      logger.error('‚ùå Failed to parse Claude response');
      logger.error('Raw response:', responseText);
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'Failed to parse AI response. Please try again.'
        },
        { status: 500 }
      );
    }

    logger.log('‚úÖ Persona alignment analysis complete:', {
      score: result.score,
      strengthsCount: result.strengths.length,
      improvementsCount: result.improvements.length,
      recommendationsCount: result.recommendations.length,
    });

    // ------------------------------------------------------------------------
    // 5. Return the analysis result
    // ------------------------------------------------------------------------
    
    return NextResponse.json<PersonaAlignmentResponse>(
      {
        result,
        textLength: text.length,
        personaName: persona.name,
      },
      { status: 200 }
    );

  } catch (error) {
    // ------------------------------------------------------------------------
    // Error Handling
    // ------------------------------------------------------------------------
    
    logError(error, 'Persona alignment API');

    // Handle timeout errors
    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Request timeout',
          details: 'The analysis took too long. Please try again with shorter text.'
        },
        { status: 408 }
      );
    }

    // Handle Anthropic-specific errors
    if (error instanceof Anthropic.APIError) {
      let userMessage = 'AI service error. Please try again.';
      
      if (error.status === 429) {
        userMessage = 'Rate limit exceeded. Please wait a moment and try again.';
      } else if (error.status === 500 || error.status === 503) {
        userMessage = 'AI service temporarily unavailable. Please try again in a moment.';
      }

      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI service error',
          details: userMessage
        },
        { status: error.status || 500 }
      );
    }

    // Handle generic errors
    return NextResponse.json<ErrorResponse>(
      { 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'An unexpected error occurred. Please try again.'
      },
      { status: 500 }
    );
  }
}


=== FILE: app/api/rewrite-channel/route.ts ===

/**
 * @file app/api/rewrite-channel/route.ts
 * @description API route for rewriting copy for different marketing channels using Claude AI
 * 
 * This endpoint accepts text and a target channel, then uses Claude to optimize
 * the copy for that specific platform while preserving the core message.
 * 
 * Includes automatic usage logging to track API costs per user.
 */

import { NextRequest, NextResponse } from 'next/server';
import Anthropic from '@anthropic-ai/sdk';
import { validateTextLength, validateNotEmpty, logError } from '@/lib/utils/error-handling';
import { logger } from '@/lib/utils/logger';
// Imports for usage logging and limit checking
import { getUserId, checkUserWithinLimit, usageLimitExceededResponse } from '@/lib/utils/api-auth';
import { supabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Supported channel types for copy rewriting
 */
type ChannelType = 'linkedin' | 'twitter' | 'instagram' | 'facebook' | 'email';

/**
 * Request body structure
 */
interface RewriteChannelRequest {
  text: string;
  channel: ChannelType;
}

/**
 * Response body structure
 */
interface RewriteChannelResponse {
  rewrittenText: string;
  originalLength: number;
  newLength: number;
  channel: string;
}

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

// ============================================================================
// Constants
// ============================================================================

const VALID_CHANNELS: ChannelType[] = ['linkedin', 'twitter', 'instagram', 'facebook', 'email'];

/**
 * System prompt that establishes Claude's role and expertise
 */
const SYSTEM_PROMPT = `You are an expert copywriter with 40 years of experience across all marketing channels. Your job is to rewrite copy to optimize it for specific platforms while preserving the core message and maximizing engagement.

CRITICAL OUTPUT FORMAT:
You must output valid HTML that preserves the original structure while adapting to the channel.
Use only these tags:
- <h2> or <h3> for headings and subject lines
- <p> for paragraphs
- <ul> and <li> for bullet lists
- <strong> for bold emphasis
- <em> for italic emphasis

HTML RULES:
- Preserve the original document structure (headings stay headings, bullets stay bullets)
- Adapt the tone and wording for the channel, NOT the structure
- If input has bullets, output must have bullets (just reworded for platform)
- If input has headings, output must have headings
- Output ONLY HTML, no markdown, no preamble
- Do NOT add blank lines between tags
- Adapt style to match platform while preserving formatting

When rewriting:
- Adapt the tone, format, and style to match the platform's best practices
- Maintain the original meaning and key value propositions
- Optimize for the platform's audience expectations and behavior patterns
- Improve clarity and engagement
- Remove redundancies and awkward phrasing
- DO NOT add new information or claims not in the original

Return ONLY the rewritten HTML, no explanations or preambles.`;

/**
 * Channel-specific prompts with platform optimization guidelines
 */
const CHANNEL_PROMPTS: Record<ChannelType, string> = {
  linkedin: `Rewrite this copy for LinkedIn with a professional yet personable tone. Add business context and thought leadership angle. Aim for 1-2 impactful paragraphs that engage professional audiences.

LINKEDIN BEST PRACTICES:
- Professional but conversational tone
- Business value and insights focus
- Thought leadership positioning
- 1-3 paragraphs ideal
- Use line breaks for readability
- Strong opening hook
- Can include relevant hashtags (2-3 max)

ORIGINAL COPY:`,

  twitter: `Rewrite this copy for Twitter/X. Make it punchy and conversational with maximum impact in minimal words. Create a strong hook in the first 10 words. Keep it under 280 characters if possible, but prioritize impact over strict character limits.

TWITTER BEST PRACTICES:
- Punchy and concise
- Strong opening hook (first 10 words critical)
- Conversational tone
- Aim for under 280 characters when possible
- Can use 1-2 relevant hashtags
- Create engagement and shareability

ORIGINAL COPY:`,

  instagram: `Rewrite this copy for Instagram with an emotional, story-driven approach. Use casual, relatable language that connects personally. Format with line breaks for readability. Make it work well alongside visual content.

INSTAGRAM BEST PRACTICES:
- Emotional and story-driven
- Casual, relatable language
- Personal connection focus
- Use line breaks for visual appeal
- Works with visual content
- Longer captions are OK if engaging
- Can include emojis where appropriate
- 3-5 relevant hashtags at the end

ORIGINAL COPY:`,

  facebook: `Rewrite this copy for Facebook with a community-focused, conversational tone. Make it relatable and engaging for diverse audiences. Use friendly, approachable language that encourages interaction.

FACEBOOK BEST PRACTICES:
- Community-focused and conversational
- Relatable to diverse audiences
- Friendly and approachable tone
- Encourage comments and engagement
- Questions work well
- Mix of short and medium length
- Can include emojis naturally

ORIGINAL COPY:`,

  email: `Rewrite this copy for email with a direct, personal tone. Make it scannable with clear value proposition and strong call-to-action. Use short paragraphs and bullet points where appropriate.

EMAIL BEST PRACTICES:
- Direct and personal tone
- Clear value proposition up front
- Scannable format (short paragraphs)
- Use bullet points for key benefits
- Strong, clear call-to-action
- Action-oriented language
- Remove fluff, be concise

ORIGINAL COPY:`,
};

// ============================================================================
// Usage Logging (ADDED)
// ============================================================================

/**
 * Log API usage to Supabase for cost tracking
 * 
 * This function is fire-and-forget - logs errors but doesn't throw.
 * API responses should NOT fail due to logging issues.
 * 
 * @param userId - Clerk user ID
 * @param model - Claude model used
 * @param inputTokens - Number of input tokens
 * @param outputTokens - Number of output tokens
 * @param costUsd - Calculated cost in USD
 */
async function logUsageToSupabase(
  userId: string,
  model: string,
  inputTokens: number,
  outputTokens: number,
  costUsd: number
): Promise<void> {
  // Skip logging if Supabase is not configured
  if (!isSupabaseConfigured() || !supabaseAdmin) {
    logger.log('‚ö†Ô∏è Supabase not configured, skipping usage logging');
    return;
  }

  try {
    const { error } = await (supabaseAdmin
      .from('api_usage_logs') as any)
      .insert({
        user_id: userId,
        model,
        input_tokens: inputTokens,
        output_tokens: outputTokens,
        feature: 'rewrite_channel',
        cost_usd: costUsd,
        // timestamp is auto-generated by database default
      });

    if (error) {
      // Log error but don't throw - API response should still succeed
      console.error('‚ùå Failed to log rewrite-channel usage:', error);
    } else {
      logger.log('üìä Rewrite-channel usage logged:', {
        userId: userId.substring(0, 8) + '...',
        model,
        tokens: inputTokens + outputTokens,
        cost: `$${costUsd.toFixed(6)}`,
      });
    }
  } catch (err) {
    // Log error but don't throw - this is fire-and-forget
    console.error('‚ùå Exception logging rewrite-channel usage:', err);
  }
}

/**
 * Calculate cost in USD for a Claude API call
 * Based on Claude Sonnet 4 pricing: $3/1M input, $15/1M output
 */
function calculateCost(inputTokens: number, outputTokens: number): number {
  const inputCost = (inputTokens / 1_000_000) * 3;
  const outputCost = (outputTokens / 1_000_000) * 15;
  // Round to 6 decimal places for precision
  return Math.round((inputCost + outputCost) * 1_000_000) / 1_000_000;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * POST /api/rewrite-channel
 * 
 * Rewrites copy for a specific marketing channel using Claude AI
 * 
 * @param request - Next.js request object containing text and channel
 * @returns JSON response with rewritten text or error
 */
export async function POST(request: NextRequest): Promise<NextResponse<RewriteChannelResponse | ErrorResponse>> {
  try {
    // ------------------------------------------------------------------------
    // 1. Check usage limit BEFORE processing request
    // ------------------------------------------------------------------------
    
    const userId = await getUserId();
    
    if (userId) {
      const usageCheck = await checkUserWithinLimit(userId);
      
      if (!usageCheck.withinLimit) {
        logger.log('üö´ User exceeded usage limit:', {
          userId: userId.substring(0, 8) + '...',
          totalCost: `$${usageCheck.totalCost.toFixed(4)}`,
        });
        return usageLimitExceededResponse(usageCheck.totalCost);
      }
    }
    
    // ------------------------------------------------------------------------
    // 2. Parse and validate request body
    // ------------------------------------------------------------------------
    
    let body: Partial<RewriteChannelRequest>;
    
    try {
      body = await request.json();
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid JSON in request body',
          details: 'Please send valid JSON with "text" and "channel" fields'
        },
        { status: 400 }
      );
    }

    const { text, channel } = body;

    // Validate required fields
    if (!text || typeof text !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "text" field',
          details: 'Please provide the copy to rewrite as a string in the "text" field'
        },
        { status: 400 }
      );
    }

    if (!channel || typeof channel !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "channel" field',
          details: `Please provide a channel as one of: ${VALID_CHANNELS.join(', ')}`
        },
        { status: 400 }
      );
    }

    // Validate channel is one of the allowed values
    if (!VALID_CHANNELS.includes(channel as ChannelType)) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid channel value',
          details: `Channel must be one of: ${VALID_CHANNELS.join(', ')}. Received: "${channel}"`
        },
        { status: 400 }
      );
    }

    // Validate text
    try {
      validateNotEmpty(text, 'Text');
      validateTextLength(text, 'Text');
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid text',
          details: error instanceof Error ? error.message : 'Please provide valid text to rewrite'
        },
        { status: 400 }
      );
    }

    // ------------------------------------------------------------------------
    // 2. Initialize Anthropic client
    // ------------------------------------------------------------------------
    
    // Read API key from environment variables
    const apiKey = process.env.ANTHROPIC_API_KEY;
    
    if (!apiKey) {
      logger.error('‚ùå ANTHROPIC_API_KEY not found in environment variables');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Server configuration error',
          details: 'API key not configured. Please contact support.'
        },
        { status: 500 }
      );
    }

    // Create Anthropic client instance
    const anthropic = new Anthropic({
      apiKey: apiKey,
    });

    // ------------------------------------------------------------------------
    // 3. Call Claude API to rewrite the text
    // ------------------------------------------------------------------------
    
    logger.log('üìù Rewrite channel request:', {
      originalLength: text.length,
      channel: channel,
      preview: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
    });

    // Build the user prompt with the channel-specific instructions
    const channelPrompt = CHANNEL_PROMPTS[channel as ChannelType];
    const userPrompt = `${channelPrompt}\n\n${text}`;

    // Call Claude's Messages API with timeout
    const message = await Promise.race([
      anthropic.messages.create({
        model: 'claude-sonnet-4-20250514', // Latest Claude Sonnet model
        max_tokens: 4000, // Maximum length of response
        system: SYSTEM_PROMPT, // System prompt defining Claude's role
        messages: [
          {
            role: 'user',
            content: userPrompt, // The actual rewriting request
          },
        ],
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Request timed out after 30 seconds')), 30000)
      ),
    ]);

    // ------------------------------------------------------------------------
    // 4. Extract and process the response
    // ------------------------------------------------------------------------
    
    // Claude returns an array of content blocks; we want the text from the first one
    const rewrittenText = message.content[0].type === 'text' 
      ? message.content[0].text.trim()
      : '';

    if (!rewrittenText) {
      logger.error('‚ùå Claude returned empty response');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'Claude returned an empty response. Please try again.'
        },
        { status: 500 }
      );
    }

    // Calculate text lengths for comparison
    const originalLength = text.length;
    const newLength = rewrittenText.length;

    logger.log('‚úÖ Rewrite channel successful:', {
      channel,
      originalLength,
      newLength,
      changePercent: ((newLength - originalLength) / originalLength * 100).toFixed(1) + '%',
      preview: rewrittenText.substring(0, 100) + (rewrittenText.length > 100 ? '...' : ''),
    });

    // ------------------------------------------------------------------------
    // 5. Log usage to Supabase
    // ------------------------------------------------------------------------
    
    // userId was already retrieved at start for limit check
    if (userId) {
      // Extract token usage from Claude's response
      const inputTokens = message.usage.input_tokens;
      const outputTokens = message.usage.output_tokens;
      
      // Calculate cost based on Claude Sonnet 4 pricing
      const costUsd = calculateCost(inputTokens, outputTokens);
      
      // Fire-and-forget logging - don't await, let it run in background
      // This ensures logging failures don't slow down or break the API response
      logUsageToSupabase(
        userId,
        'claude-sonnet-4-20250514', // Model used in this route
        inputTokens,
        outputTokens,
        costUsd
      ).catch(err => {
        // Extra safety net - should never throw but just in case
        console.error('‚ùå Unexpected error in rewrite-channel usage logging:', err);
      });
    } else {
      logger.log('‚ö†Ô∏è No user ID found, skipping usage logging for rewrite-channel');
    }

    // ------------------------------------------------------------------------
    // 6. Return the rewritten text
    // ------------------------------------------------------------------------
    
    return NextResponse.json<RewriteChannelResponse>(
      {
        rewrittenText,
        originalLength,
        newLength,
        channel,
      },
      { status: 200 }
    );

  } catch (error) {
    // ------------------------------------------------------------------------
    // Error Handling
    // ------------------------------------------------------------------------
    
    logError(error, 'Rewrite channel API');

    // Handle timeout errors
    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Request timeout',
          details: 'The request took too long. Please try again with shorter text.'
        },
        { status: 408 }
      );
    }

    // Handle Anthropic-specific errors
    if (error instanceof Anthropic.APIError) {
      let userMessage = 'AI service error. Please try again.';
      
      if (error.status === 429) {
        userMessage = 'Rate limit exceeded. Please wait a moment and try again.';
      } else if (error.status === 500 || error.status === 503) {
        userMessage = 'AI service temporarily unavailable. Please try again in a moment.';
      }

      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI service error',
          details: userMessage
        },
        { status: error.status || 500 }
      );
    }

    // Handle generic errors
    return NextResponse.json<ErrorResponse>(
      { 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'An unexpected error occurred. Please try again.'
      },
      { status: 500 }
    );
  }
}


=== FILE: app/api/route.ts ===

/**
 * @file app/api/route.ts
 * @description Base API route for health check and API info
 */

import { NextResponse } from 'next/server';

/**
 * API health check endpoint
 * 
 * @returns JSON response with API status and version
 */
export async function GET() {
  return NextResponse.json({
    status: 'ok',
    name: 'CopyWorx API',
    version: '1.0.0',
    timestamp: new Date().toISOString(),
  });
}



=== FILE: app/api/shorten/route.ts ===

/**
 * @file app/api/shorten/route.ts
 * @description API route for shortening copy using Claude AI
 * 
 * This endpoint accepts text and uses Claude to shorten it while
 * preserving the core message and impact.
 * 
 * Includes automatic usage logging to track API costs per user.
 */

import { NextRequest, NextResponse } from 'next/server';
import Anthropic from '@anthropic-ai/sdk';
import { validateTextLength, validateNotEmpty, logError } from '@/lib/utils/error-handling';
import { logger } from '@/lib/utils/logger';
// Imports for usage logging and limit checking
import { getUserId, checkUserWithinLimit, usageLimitExceededResponse } from '@/lib/utils/api-auth';
import { supabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Request body structure
 */
interface ShortenRequest {
  text: string;
}

/**
 * Response body structure
 */
interface ShortenResponse {
  shortenedText: string;
  originalLength: number;
  newLength: number;
}

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

// ============================================================================
// Constants
// ============================================================================

/**
 * System prompt that establishes Claude's role and expertise
 * AGGRESSIVE SHORTENING: Targets 40-50% length reduction
 */
const SYSTEM_PROMPT = `You are an expert copywriter with 40 years of experience. Your job is to AGGRESSIVELY shorten copy by cutting it to approximately 40-50% of its original length while preserving only the essential core message.

CRITICAL OUTPUT FORMAT:
You must output valid HTML that preserves the original structure while shortening the content.
Use only these tags:
- <h2> or <h3> for headings and subject lines
- <p> for paragraphs
- <ul> and <li> for bullet lists
- <strong> for bold emphasis
- <em> for italic emphasis

HTML RULES:
- Preserve the original document structure (headings stay headings, bullets stay bullets)
- Shorten ONLY the content/wording, NOT the structure
- If input has bullets, output must have bullets (just more concise)
- If input has headings, output must have headings
- Output ONLY HTML, no markdown, no preamble
- Do NOT add blank lines between tags

AGGRESSIVE SHORTENING STRATEGY:
- TARGET: Reduce to approximately HALF the original length (40-50% reduction)
- Cut ruthlessly - every word must earn its place
- Remove ALL redundant phrases and filler words
- Eliminate descriptive fluff and unnecessary modifiers
- Strip out repetitive explanations
- Keep ONLY the essential information and core value proposition
- Use the most concise possible wording
- Combine related ideas into single, tight sentences
- Remove examples unless absolutely critical
- Cut transitional phrases and connecting words where possible
- Be ruthless: if it doesn't add critical value, cut it

What to KEEP:
- The single most important benefit or message
- Critical facts, numbers, or claims that drive the message
- Essential calls-to-action
- Core brand differentiators

What to CUT:
- Adjective stacking (e.g., "amazing, incredible, fantastic" ‚Üí pick ONE)
- Redundant phrases (e.g., "completely and totally" ‚Üí "completely")
- Unnecessary explanations
- Backstory and context unless critical
- Polite filler (e.g., "We are pleased to announce" ‚Üí "Announcing")
- Examples and illustrations unless they ARE the message

Do NOT change the core message or add new information.

Return ONLY the shortened HTML, no explanations or preambles.`;

/**
 * Generates a user prompt with the text to shorten
 * AGGRESSIVE VERSION: Emphasizes 40-50% length reduction
 */
function buildUserPrompt(text: string): string {
  return `AGGRESSIVELY shorten the following copy to approximately 40-50% of its original length. Cut ruthlessly while preserving only the essential core message. Remove ALL redundant phrases, eliminate unnecessary words, and keep ONLY critical information.

CRITICAL: Output must be valid HTML with preserved structure. If the input has headings, keep them as headings. If it has bullets, keep them as bullets (just drastically shorter). Do not add a preamble or explanation - just return the aggressively shortened HTML.

Example - aggressive shortening (notice the 50%+ reduction):
INPUT (33 words):
<p>Our coffee delivers a bold, robust flavor profile that awakens your senses with every sip. The carefully selected beans provide a powerful energizing kick that will keep you going all day long.</p>

OUTPUT (11 words - 67% reduction):
<p><strong>Bold coffee</strong> that energizes and keeps you going.</p>

TARGET: Aim for approximately HALF the original word count. Be ruthless - every word must justify its existence.

ORIGINAL COPY:
${text}

SHORTENED HTML:`;
}

// ============================================================================
// Usage Logging (ADDED)
// ============================================================================

/**
 * Log API usage to Supabase for cost tracking
 * 
 * This function is fire-and-forget - logs errors but doesn't throw.
 * API responses should NOT fail due to logging issues.
 * 
 * @param userId - Clerk user ID
 * @param model - Claude model used
 * @param inputTokens - Number of input tokens
 * @param outputTokens - Number of output tokens
 * @param costUsd - Calculated cost in USD
 */
async function logUsageToSupabase(
  userId: string,
  model: string,
  inputTokens: number,
  outputTokens: number,
  costUsd: number
): Promise<void> {
  // Skip logging if Supabase is not configured
  if (!isSupabaseConfigured() || !supabaseAdmin) {
    logger.log('‚ö†Ô∏è Supabase not configured, skipping usage logging');
    return;
  }

  try {
    const { error } = await (supabaseAdmin
      .from('api_usage_logs') as any)
      .insert({
        user_id: userId,
        model,
        input_tokens: inputTokens,
        output_tokens: outputTokens,
        feature: 'shorten',
        cost_usd: costUsd,
        // timestamp is auto-generated by database default
      });

    if (error) {
      // Log error but don't throw - API response should still succeed
      console.error('‚ùå Failed to log shorten usage:', error);
    } else {
      logger.log('üìä Shorten usage logged:', {
        userId: userId.substring(0, 8) + '...',
        model,
        tokens: inputTokens + outputTokens,
        cost: `$${costUsd.toFixed(6)}`,
      });
    }
  } catch (err) {
    // Log error but don't throw - this is fire-and-forget
    console.error('‚ùå Exception logging shorten usage:', err);
  }
}

/**
 * Calculate cost in USD for a Claude API call
 * Based on Claude Sonnet 4 pricing: $3/1M input, $15/1M output
 */
function calculateCost(inputTokens: number, outputTokens: number): number {
  const inputCost = (inputTokens / 1_000_000) * 3;
  const outputCost = (outputTokens / 1_000_000) * 15;
  // Round to 6 decimal places for precision
  return Math.round((inputCost + outputCost) * 1_000_000) / 1_000_000;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * POST /api/shorten
 * 
 * Shortens copy using Claude AI
 * 
 * @param request - Next.js request object containing text
 * @returns JSON response with shortened text or error
 */
export async function POST(request: NextRequest): Promise<NextResponse<ShortenResponse | ErrorResponse>> {
  try {
    // ------------------------------------------------------------------------
    // 1. Check usage limit BEFORE processing request
    // ------------------------------------------------------------------------
    
    const userId = await getUserId();
    
    if (userId) {
      const usageCheck = await checkUserWithinLimit(userId);
      
      if (!usageCheck.withinLimit) {
        logger.log('üö´ User exceeded usage limit:', {
          userId: userId.substring(0, 8) + '...',
          totalCost: `$${usageCheck.totalCost.toFixed(4)}`,
        });
        return usageLimitExceededResponse(usageCheck.totalCost);
      }
    }
    
    // ------------------------------------------------------------------------
    // 2. Parse and validate request body
    // ------------------------------------------------------------------------
    
    let body: Partial<ShortenRequest>;
    
    try {
      body = await request.json();
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid JSON in request body',
          details: 'Please send valid JSON with a "text" field'
        },
        { status: 400 }
      );
    }

    const { text } = body;

    // Validate required fields
    if (!text || typeof text !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "text" field',
          details: 'Please provide the copy to shorten as a string in the "text" field'
        },
        { status: 400 }
      );
    }

    // Validate text
    try {
      validateNotEmpty(text, 'Text');
      validateTextLength(text, 'Text');
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid text',
          details: error instanceof Error ? error.message : 'Please provide valid text to shorten'
        },
        { status: 400 }
      );
    }

    // ------------------------------------------------------------------------
    // 2. Initialize Anthropic client
    // ------------------------------------------------------------------------
    
    // Read API key from environment variables
    const apiKey = process.env.ANTHROPIC_API_KEY;
    
    if (!apiKey) {
      logger.error('‚ùå ANTHROPIC_API_KEY not found in environment variables');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Server configuration error',
          details: 'API key not configured. Please contact support.'
        },
        { status: 500 }
      );
    }

    // Create Anthropic client instance
    const anthropic = new Anthropic({
      apiKey: apiKey,
    });

    // ------------------------------------------------------------------------
    // 3. Call Claude API to shorten the text
    // ------------------------------------------------------------------------
    
    // Build the user prompt with the text to shorten
    const userPrompt = buildUserPrompt(text);

    // Call Claude's Messages API with timeout
    const message = await Promise.race([
      anthropic.messages.create({
        model: 'claude-sonnet-4-20250514', // Latest Claude Sonnet model
        max_tokens: 4000, // Maximum length of response
        system: SYSTEM_PROMPT, // System prompt defining Claude's role
        messages: [
          {
            role: 'user',
            content: userPrompt, // The actual shortening request
          },
        ],
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Request timed out after 30 seconds')), 30000)
      ),
    ]);

    // ------------------------------------------------------------------------
    // 4. Extract and process the response
    // ------------------------------------------------------------------------
    
    // Claude returns an array of content blocks; we want the text from the first one
    const shortenedText = message.content[0].type === 'text' 
      ? message.content[0].text.trim()
      : '';

    if (!shortenedText) {
      logger.error('‚ùå Claude returned empty response');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'Claude returned an empty response. Please try again.'
        },
        { status: 500 }
      );
    }

    // Calculate text lengths for comparison
    const originalLength = text.length;
    const newLength = shortenedText.length;

    // ------------------------------------------------------------------------
    // 5. Log usage to Supabase
    // ------------------------------------------------------------------------
    
    // userId was already retrieved at start for limit check
    if (userId) {
      // Extract token usage from Claude's response
      const inputTokens = message.usage.input_tokens;
      const outputTokens = message.usage.output_tokens;
      
      // Calculate cost based on Claude Sonnet 4 pricing
      const costUsd = calculateCost(inputTokens, outputTokens);
      
      // Fire-and-forget logging - don't await, let it run in background
      // This ensures logging failures don't slow down or break the API response
      logUsageToSupabase(
        userId,
        'claude-sonnet-4-20250514', // Model used in this route
        inputTokens,
        outputTokens,
        costUsd
      ).catch(err => {
        // Extra safety net - should never throw but just in case
        console.error('‚ùå Unexpected error in shorten usage logging:', err);
      });
    } else {
      logger.log('‚ö†Ô∏è No user ID found, skipping usage logging for shorten');
    }

    // ------------------------------------------------------------------------
    // 6. Return the shortened text
    // ------------------------------------------------------------------------
    
    return NextResponse.json<ShortenResponse>(
      {
        shortenedText,
        originalLength,
        newLength,
      },
      { status: 200 }
    );

  } catch (error) {
    // ------------------------------------------------------------------------
    // Error Handling
    // ------------------------------------------------------------------------
    
    logError(error, 'Shorten API');

    // Handle timeout errors
    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Request timeout',
          details: 'The request took too long. Please try again with shorter text.'
        },
        { status: 408 }
      );
    }

    // Handle Anthropic-specific errors
    if (error instanceof Anthropic.APIError) {
      let userMessage = 'AI service error. Please try again.';
      
      if (error.status === 429) {
        userMessage = 'Rate limit exceeded. Please wait a moment and try again.';
      } else if (error.status === 500 || error.status === 503) {
        userMessage = 'AI service temporarily unavailable. Please try again in a moment.';
      }

      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI service error',
          details: userMessage
        },
        { status: error.status || 500 }
      );
    }

    // Handle generic errors
    return NextResponse.json<ErrorResponse>(
      { 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'An unexpected error occurred. Please try again.'
      },
      { status: 500 }
    );
  }
}


=== FILE: app/api/tone-shift/route.ts ===

/**
 * @file app/api/tone-shift/route.ts
 * @description API route for rewriting copy in different tones using Claude AI
 * 
 * This endpoint accepts text and a target tone, then uses Claude to rewrite
 * the copy while preserving the core message and improving clarity.
 * 
 * Includes automatic usage logging to track API costs per user.
 */

import { NextRequest, NextResponse } from 'next/server';
import Anthropic from '@anthropic-ai/sdk';
import { validateTextLength, validateNotEmpty, logError } from '@/lib/utils/error-handling';
import { logger } from '@/lib/utils/logger';
// Imports for usage logging and limit checking
import { getUserId, checkUserWithinLimit, usageLimitExceededResponse } from '@/lib/utils/api-auth';
import { supabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Supported tone types for copy rewriting
 */
type ToneType = 'professional' | 'casual' | 'urgent' | 'friendly' | 'techy' | 'playful';

/**
 * Request body structure
 */
interface ToneShiftRequest {
  text: string;
  tone: ToneType;
}

/**
 * Response body structure
 */
interface ToneShiftResponse {
  rewrittenText: string;
  originalLength: number;
  newLength: number;
}

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

// ============================================================================
// Constants
// ============================================================================

const VALID_TONES: ToneType[] = ['professional', 'casual', 'urgent', 'friendly', 'techy', 'playful'];

/**
 * System prompt that establishes Claude's role and expertise
 * This tells Claude to act as an expert copywriter with decades of experience
 */
const SYSTEM_PROMPT = `You are an expert copywriter with 40 years of experience. Your job is to rewrite copy to match a specific tone while preserving the core message, structure, and formatting.

CRITICAL OUTPUT FORMAT:
You MUST output valid HTML that preserves the original structure while changing the tone.
Use ONLY these tags:
- <h2> or <h3> for headings and subject lines
- <p> for paragraphs
- <ul> and <li> for bullet lists
- <strong> for bold emphasis
- <em> for italic emphasis
- <br> for line breaks within paragraphs (use sparingly)

HTML RULES:
1. Preserve the original document structure (headings stay headings, bullets stay bullets)
2. Change ONLY the tone/voice/word choice, NOT the structure
3. If input has bullets, output must have bullets
4. If input has headings, output must have headings
5. Output ONLY HTML, no markdown, no preamble
6. Do NOT add blank lines between tags - write consecutively: <p>Text</p><p>Next</p>
7. Keep emojis if appropriate for the tone (especially Playful and Casual)
8. Preserve bold/italic on key phrases where appropriate

Example - changing Professional to Playful while preserving structure:
INPUT (plain or HTML):
Subject: New Product Launch
We are excited to announce our new product.
‚Ä¢ Advanced features
‚Ä¢ Competitive pricing

OUTPUT (HTML):
<h3>Subject: üéâ Get Ready to Fall in Love with Our New Product!</h3>
<p>Guess what? We just dropped something amazing that's about to make your day!</p>
<ul>
<li>Features so cool they'll make you do a happy dance</li>
<li>Prices that won't make your wallet cry</li>
</ul>

When rewriting:
- Maintain the original meaning and key points
- Adjust word choice, sentence structure, and phrasing to match the target tone
- Keep the length roughly similar (¬±20% is acceptable)
- Improve clarity and readability
- Remove redundancies and awkward phrasing
- Do NOT add new information or claims not in the original

Return ONLY the HTML content, no explanations or preambles.`;

/**
 * Generates a user prompt with the text to rewrite and target tone
 */
function buildUserPrompt(text: string, tone: ToneType): string {
  const toneDescriptions: Record<ToneType, string> = {
    professional: 'Professional tone: formal, polished, business-appropriate, authoritative',
    casual: 'Casual tone: conversational, friendly, relaxed, approachable',
    urgent: 'Urgent tone: time-sensitive, compelling, action-oriented, creates FOMO',
    friendly: 'Friendly tone: warm, personable, welcoming, builds rapport',
    techy: `Technical, precise tone. Use:
- Technical terminology where appropriate
- Specific metrics and data points
- Clear, accurate language
- Demonstrate expertise and precision
- Focus on capabilities and specifications
- Use industry-standard terms
- Maintain clarity while being technical

Avoid: Jargon for jargon's sake, overly complex explanations, condescension`,
    playful: `Playful, fun tone. Use:
- Energetic, upbeat language
- Playful expressions and word choices
- Light humor where appropriate
- Conversational and engaging style
- Creative analogies or metaphors
- Enthusiasm without being annoying
- Keep it professional enough for the context

Avoid: Forced humor, being overly silly, losing the core message`,
  };

  return `Rewrite the following copy in a ${tone} tone while preserving its structure.

TARGET TONE: ${toneDescriptions[tone]}

ORIGINAL COPY:
${text}

REWRITTEN COPY (HTML only):`;
}

// ============================================================================
// Usage Logging (ADDED)
// ============================================================================

/**
 * Log API usage to Supabase for cost tracking
 * 
 * This function is fire-and-forget - logs errors but doesn't throw.
 * API responses should NOT fail due to logging issues.
 * 
 * @param userId - Clerk user ID
 * @param model - Claude model used
 * @param inputTokens - Number of input tokens
 * @param outputTokens - Number of output tokens
 * @param costUsd - Calculated cost in USD
 */
async function logUsageToSupabase(
  userId: string,
  model: string,
  inputTokens: number,
  outputTokens: number,
  costUsd: number
): Promise<void> {
  // Skip logging if Supabase is not configured
  if (!isSupabaseConfigured() || !supabaseAdmin) {
    logger.log('‚ö†Ô∏è Supabase not configured, skipping usage logging');
    return;
  }

  try {
    const { error } = await (supabaseAdmin
      .from('api_usage_logs') as any)
      .insert({
        user_id: userId,
        model,
        input_tokens: inputTokens,
        output_tokens: outputTokens,
        feature: 'tone_shifter',
        cost_usd: costUsd,
        // timestamp is auto-generated by database default
      });

    if (error) {
      // Log error but don't throw - API response should still succeed
      console.error('‚ùå Failed to log tone-shift usage:', error);
    } else {
      logger.log('üìä Tone-shift usage logged:', {
        userId: userId.substring(0, 8) + '...',
        model,
        tokens: inputTokens + outputTokens,
        cost: `$${costUsd.toFixed(6)}`,
      });
    }
  } catch (err) {
    // Log error but don't throw - this is fire-and-forget
    console.error('‚ùå Exception logging tone-shift usage:', err);
  }
}

/**
 * Calculate cost in USD for a Claude API call
 * Based on Claude Sonnet 4 pricing: $3/1M input, $15/1M output
 */
function calculateCost(inputTokens: number, outputTokens: number): number {
  const inputCost = (inputTokens / 1_000_000) * 3;
  const outputCost = (outputTokens / 1_000_000) * 15;
  // Round to 6 decimal places for precision
  return Math.round((inputCost + outputCost) * 1_000_000) / 1_000_000;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * POST /api/tone-shift
 * 
 * Rewrites copy in a different tone using Claude AI
 * 
 * @param request - Next.js request object containing text and tone
 * @returns JSON response with rewritten text or error
 */
export async function POST(request: NextRequest): Promise<NextResponse<ToneShiftResponse | ErrorResponse>> {
  try {
    // ------------------------------------------------------------------------
    // 1. Check usage limit BEFORE processing request
    // ------------------------------------------------------------------------
    
    const userId = await getUserId();
    
    if (userId) {
      const usageCheck = await checkUserWithinLimit(userId);
      
      if (!usageCheck.withinLimit) {
        logger.log('üö´ User exceeded usage limit:', {
          userId: userId.substring(0, 8) + '...',
          totalCost: `$${usageCheck.totalCost.toFixed(4)}`,
        });
        return usageLimitExceededResponse(usageCheck.totalCost);
      }
    }
    
    // ------------------------------------------------------------------------
    // 2. Parse and validate request body
    // ------------------------------------------------------------------------
    
    let body: Partial<ToneShiftRequest>;
    
    try {
      body = await request.json();
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid JSON in request body',
          details: 'Please send valid JSON with "text" and "tone" fields'
        },
        { status: 400 }
      );
    }

    const { text, tone } = body;

    // Validate required fields
    if (!text || typeof text !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "text" field',
          details: 'Please provide the copy to rewrite as a string in the "text" field'
        },
        { status: 400 }
      );
    }

    if (!tone || typeof tone !== 'string') {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Missing or invalid "tone" field',
          details: `Please provide a tone as one of: ${VALID_TONES.join(', ')}`
        },
        { status: 400 }
      );
    }

    // Validate tone is one of the allowed values
    if (!VALID_TONES.includes(tone as ToneType)) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Invalid tone value',
          details: `Tone must be one of: ${VALID_TONES.join(', ')}. Received: "${tone}"`
        },
        { status: 400 }
      );
    }

    // Validate text is not empty
    try {
      validateNotEmpty(text, 'Text');
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Empty text provided',
          details: error instanceof Error ? error.message : 'Please provide non-empty text to rewrite'
        },
        { status: 400 }
      );
    }

    // Validate text length (max 10,000 characters)
    try {
      validateTextLength(text, 'Text');
    } catch (error) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Text too long',
          details: error instanceof Error ? error.message : 'Text exceeds maximum length'
        },
        { status: 400 }
      );
    }

    // ------------------------------------------------------------------------
    // 2. Initialize Anthropic client
    // ------------------------------------------------------------------------
    
    // Read API key from environment variables
    const apiKey = process.env.ANTHROPIC_API_KEY;
    
    if (!apiKey) {
      logger.error('‚ùå ANTHROPIC_API_KEY not found in environment variables');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Server configuration error',
          details: 'API key not configured. Please contact support.'
        },
        { status: 500 }
      );
    }

    // Create Anthropic client instance
    const anthropic = new Anthropic({
      apiKey: apiKey,
    });

    // ------------------------------------------------------------------------
    // 3. Call Claude API to rewrite the text
    // ------------------------------------------------------------------------
    
    // Build the user prompt with the text and target tone
    const userPrompt = buildUserPrompt(text, tone as ToneType);

    // Call Claude's Messages API with timeout
    // This sends the request to Claude and waits for the full response
    const message = await Promise.race([
      anthropic.messages.create({
        model: 'claude-sonnet-4-20250514', // Latest Claude Sonnet model
        max_tokens: 4000, // Maximum length of response
        system: SYSTEM_PROMPT, // System prompt defining Claude's role
        messages: [
          {
            role: 'user',
            content: userPrompt, // The actual rewriting request
          },
        ],
      }),
      new Promise<never>((_, reject) =>
        setTimeout(() => reject(new Error('Request timed out after 30 seconds')), 30000)
      ),
    ]);

    // ------------------------------------------------------------------------
    // 4. Extract and process the response
    // ------------------------------------------------------------------------
    
    // Claude returns an array of content blocks; we want the text from the first one
    const rewrittenText = message.content[0].type === 'text' 
      ? message.content[0].text.trim()
      : '';

    if (!rewrittenText) {
      logger.error('‚ùå Claude returned empty response');
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI processing error',
          details: 'Claude returned an empty response. Please try again.'
        },
        { status: 500 }
      );
    }

    // Calculate text lengths for comparison
    const originalLength = text.length;
    const newLength = rewrittenText.length;

    // ------------------------------------------------------------------------
    // 5. Log usage to Supabase
    // ------------------------------------------------------------------------
    
    // userId was already retrieved at start for limit check
    if (userId) {
      // Extract token usage from Claude's response
      const inputTokens = message.usage.input_tokens;
      const outputTokens = message.usage.output_tokens;
      
      // Calculate cost based on Claude Sonnet 4 pricing
      const costUsd = calculateCost(inputTokens, outputTokens);
      
      // Fire-and-forget logging - don't await, let it run in background
      // This ensures logging failures don't slow down or break the API response
      logUsageToSupabase(
        userId,
        'claude-sonnet-4-20250514', // Model used in this route
        inputTokens,
        outputTokens,
        costUsd
      ).catch(err => {
        // Extra safety net - should never throw but just in case
        console.error('‚ùå Unexpected error in tone-shift usage logging:', err);
      });
    } else {
      logger.log('‚ö†Ô∏è No user ID found, skipping usage logging for tone-shift');
    }

    // ------------------------------------------------------------------------
    // 6. Return the rewritten text
    // ------------------------------------------------------------------------
    
    return NextResponse.json<ToneShiftResponse>(
      {
        rewrittenText,
        originalLength,
        newLength,
      },
      { status: 200 }
    );

  } catch (error) {
    // ------------------------------------------------------------------------
    // Error Handling
    // ------------------------------------------------------------------------
    
    logError(error, 'Tone shift API');

    // Handle timeout errors
    if (error instanceof Error && error.message.includes('timed out')) {
      return NextResponse.json<ErrorResponse>(
        { 
          error: 'Request timeout',
          details: 'The request took too long to complete. Please try again with shorter text or check your connection.'
        },
        { status: 408 }
      );
    }

    // Handle Anthropic-specific errors
    if (error instanceof Anthropic.APIError) {
      logger.error('Anthropic API Error:', {
        status: error.status,
        message: error.message,
      });

      // Provide user-friendly messages for common Claude errors
      let userMessage = 'AI service error. Please try again.';
      
      if (error.status === 429) {
        userMessage = 'Rate limit exceeded. Please wait a moment and try again.';
      } else if (error.status === 401 || error.status === 403) {
        userMessage = 'Authentication error. Please contact support.';
      } else if (error.status === 500 || error.status === 503) {
        userMessage = 'AI service temporarily unavailable. Please try again in a moment.';
      }

      return NextResponse.json<ErrorResponse>(
        { 
          error: 'AI service error',
          details: userMessage
        },
        { status: error.status || 500 }
      );
    }

    // Handle generic errors
    return NextResponse.json<ErrorResponse>(
      { 
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'An unexpected error occurred. Please try again.'
      },
      { status: 500 }
    );
  }
}

// ============================================================================
// Future Enhancements (TODO)
// ============================================================================

/**
 * TODO: Rate Limiting
 * - Implement per-user rate limiting (e.g., 50 requests per hour)
 * - Use Redis or Upstash for distributed rate limiting
 * - Return 429 status when rate limit exceeded
 * 
 * Example with Upstash Redis:
 * ```
 * import { Ratelimit } from "@upstash/ratelimit";
 * import { Redis } from "@upstash/redis";
 * 
 * const ratelimit = new Ratelimit({
 *   redis: Redis.fromEnv(),
 *   limiter: Ratelimit.slidingWindow(50, "1 h"),
 * });
 * ```
 */

/**
 * TODO: Caching
 * - Cache rewrite results for identical text+tone combinations
 * - Use Redis or edge cache (Vercel KV)
 * - Set TTL to 24 hours
 * - Reduces API costs and improves response time
 */

/**
 * DONE: Cost Tracking (Implemented January 2026)
 * ‚úÖ Log token usage per request to api_usage_logs table
 * ‚úÖ Track costs per user via Clerk userId
 * - TODO: Set up usage alerts for high-volume users
 * - TODO: Display usage in user dashboard
 */

/**
 * TODO: Streaming Response
 * - Implement streaming for real-time text generation
 * - Improves perceived performance for long rewrites
 * - Use Server-Sent Events (SSE) or WebSocket
 * 
 * Example:
 * ```
 * const stream = await anthropic.messages.stream({...});
 * return new Response(stream.toReadableStream());
 * ```
 */


=== FILE: app/api/usage/route.ts ===

/**
 * @file app/api/usage/route.ts
 * @description API route to fetch user's API usage statistics
 * 
 * Queries the user_usage_summary view in Supabase to get aggregated
 * usage data for the authenticated user. Used by the useApiUsage hook.
 * 
 * @endpoint GET /api/usage
 * @auth Required (Clerk authentication)
 */

import { NextResponse } from 'next/server';
import { getUserId } from '@/lib/utils/api-auth';
import { supabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { logger } from '@/lib/utils/logger';

// ============================================================================
// Types
// ============================================================================

/**
 * Success response structure
 */
interface UsageResponse {
  totalTokens: number;
  totalCost: number;
  totalApiCalls: number;
  lastApiCall: string | null;
}

/**
 * Error response structure
 */
interface ErrorResponse {
  error: string;
  details?: string;
}

// ============================================================================
// API Route Handler
// ============================================================================

/**
 * GET /api/usage
 * 
 * Fetches the authenticated user's API usage statistics from Supabase.
 * Returns aggregated data from the user_usage_summary view.
 * 
 * @returns {UsageResponse} Aggregated usage statistics
 * @returns {ErrorResponse} Error details if request fails
 */
export async function GET(): Promise<NextResponse<UsageResponse | ErrorResponse>> {
  try {
    // ------------------------------------------------------------------------
    // 1. Check authentication
    // ------------------------------------------------------------------------
    
    const userId = await getUserId();
    
    if (!userId) {
      return NextResponse.json<ErrorResponse>(
        {
          error: 'Unauthorized',
          details: 'You must be logged in to view usage data',
        },
        { status: 401 }
      );
    }

    // ------------------------------------------------------------------------
    // 2. Check Supabase configuration
    // ------------------------------------------------------------------------
    
    if (!isSupabaseConfigured() || !supabaseAdmin) {
      logger.log('‚ö†Ô∏è Supabase not configured, returning zero usage');
      
      // Return zero usage if Supabase isn't configured
      // This allows the app to function in development without Supabase
      return NextResponse.json<UsageResponse>({
        totalTokens: 0,
        totalCost: 0,
        totalApiCalls: 0,
        lastApiCall: null,
      });
    }

    // ------------------------------------------------------------------------
    // 3. Query user_usage_summary view
    // ------------------------------------------------------------------------
    
    const { data, error } = await (supabaseAdmin
      .from('user_usage_summary') as any)
      .select('*')
      .eq('user_id', userId)
      .single();

    // Handle case where user has no usage records yet
    if (error && error.code === 'PGRST116') {
      // No rows found - user hasn't used the API yet
      logger.log('üìä No usage records found for user:', userId.substring(0, 8) + '...');
      
      return NextResponse.json<UsageResponse>({
        totalTokens: 0,
        totalCost: 0,
        totalApiCalls: 0,
        lastApiCall: null,
      });
    }

    if (error) {
      logger.error('‚ùå Failed to fetch usage data:', error);
      return NextResponse.json<ErrorResponse>(
        {
          error: 'Database error',
          details: 'Failed to fetch usage data. Please try again.',
        },
        { status: 500 }
      );
    }

    // ------------------------------------------------------------------------
    // 4. Return usage data
    // ------------------------------------------------------------------------
    
    logger.log('üìä Usage data fetched for user:', {
      userId: userId.substring(0, 8) + '...',
      totalCost: `$${data.total_cost_usd?.toFixed(4) || '0.0000'}`,
      totalTokens: data.total_tokens_used || 0,
    });

    return NextResponse.json<UsageResponse>({
      totalTokens: data.total_tokens_used || 0,
      totalCost: data.total_cost_usd || 0,
      totalApiCalls: data.total_api_calls || 0,
      lastApiCall: data.last_api_call || null,
    });

  } catch (error) {
    logger.error('‚ùå Unexpected error in /api/usage:', error);
    
    return NextResponse.json<ErrorResponse>(
      {
        error: 'Internal server error',
        details: error instanceof Error ? error.message : 'An unexpected error occurred',
      },
      { status: 500 }
    );
  }
}


=== FILE: app/home/page.tsx ===

/**
 * @file app/home/page.tsx
 * @description CopyWorx App Splash Page
 * 
 * Entry point for CopyWorx app workspace.
 * Shows 4 action buttons for different workspace entry modes:
 * - New: Start fresh project
 * - AI@Worx‚Ñ¢: Start from AI template
 * - Import: Open text file
 * - Worxspace: Navigate directly to workspace
 * 
 * Route: /home
 */

import { SplashPage } from '@/components/splash';

export default function CopyWorxPage() {
  return <SplashPage />;
}





=== FILE: app/layout.tsx ===

/**
 * @file app/layout.tsx
 * @description Root layout for the CopyWorx application
 * 
 * Provides:
 * - Clerk authentication provider
 * - Global font loading (Inter)
 * - Metadata configuration
 * - Global styles wrapper
 */

import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import { ClerkProvider } from '@clerk/nextjs';
import { Toaster } from 'sonner';
import './globals.css';

/**
 * Inter - Clean sans-serif font for all text throughout the application
 * Provides consistent, professional typography across the entire UI
 */
const inter = Inter({
  subsets: ['latin'],
  display: 'swap',
  variable: '--font-inter',
  weight: ['400', '500', '600', '700'],
});

/**
 * Additional Google Fonts TEMPORARILY DISABLED to speed up build
 * Will re-enable once font loading timeout issue is resolved
 */
// const roboto = Roboto({
//   subsets: ['latin'],
//   display: 'swap',
//   variable: '--font-roboto',
//   weight: ['400', '500', '700'],
// });

// const openSans = Open_Sans({
//   subsets: ['latin'],
//   display: 'swap',
//   variable: '--font-open-sans',
//   weight: ['400', '500', '600', '700'],
// });

// const lato = Lato({
//   subsets: ['latin'],
//   display: 'swap',
//   variable: '--font-lato',
//   weight: ['400', '700'],
// });

// const montserrat = Montserrat({
//   subsets: ['latin'],
//   display: 'swap',
//   variable: '--font-montserrat',
//   weight: ['400', '500', '600', '700'],
// });

/**
 * Application metadata for SEO and social sharing
 */
export const metadata: Metadata = {
  title: {
    default: 'CopyWorx - Professional Copywriting Tool',
    template: '%s | CopyWorx',
  },
  description: 'Create compelling copy that converts. CopyWorx provides AI-powered templates and tools for professional copywriters.',
  keywords: [
    'copywriting',
    'AI writing',
    'content creation',
    'marketing copy',
    'sales copy',
    'copywriting templates',
  ],
  authors: [{ name: 'CopyWorx' }],
  creator: 'CopyWorx',
  openGraph: {
    type: 'website',
    locale: 'en_US',
    url: 'https://copyworx.app',
    title: 'CopyWorx - Professional Copywriting Tool',
    description: 'Create compelling copy that converts. AI-powered templates and tools for professional copywriters.',
    siteName: 'CopyWorx',
  },
  twitter: {
    card: 'summary_large_image',
    title: 'CopyWorx - Professional Copywriting Tool',
    description: 'Create compelling copy that converts.',
  },
  robots: {
    index: true,
    follow: true,
  },
};

/**
 * Root layout component
 * Wraps all pages with ClerkProvider and global styles
 * 
 * Note: In Clerk 5.x, ClerkProvider must be inside the <body> tag
 */
export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html 
      lang="en" 
      className={`${inter.variable}`}
      suppressHydrationWarning
    >
      <body className={`${inter.className} min-h-screen bg-background antialiased`}>
        <ClerkProvider
          appearance={{
            variables: {
              colorPrimary: '#EFBF04',
              colorTextOnPrimaryBackground: '#1e2433',
              colorBackground: '#ffffff',
              colorInputBackground: '#ffffff',
              colorInputText: '#1e2433',
              borderRadius: '0.625rem',
            },
            elements: {
              formButtonPrimary: 
                'bg-amber-500 hover:bg-amber-400 text-ink-900 shadow-lg',
              card: 'shadow-xl border border-border/50',
              headerTitle: 'font-sans font-semibold text-ink-900',
              headerSubtitle: 'text-ink-600',
              socialButtonsBlockButton: 
                'border border-border hover:bg-ink-50 transition-colors',
              formFieldInput: 
                'border-border focus:ring-amber-500 focus:border-amber-500',
              footerActionLink: 'text-amber-600 hover:text-amber-700',
            },
          }}
        >
          {children}
          <Toaster 
            position="top-right"
            toastOptions={{
              style: {
                background: '#ffffff',
                border: '1px solid #e5e7eb',
                borderRadius: '0.5rem',
              },
            }}
          />
        </ClerkProvider>
      </body>
    </html>
  );
}


=== FILE: app/sign-in/[[...sign-in]]/page.tsx ===

/**
 * @file app/sign-in/[[...sign-in]]/page.tsx
 * @description Sign-in page using Clerk's SignIn component
 * 
 * Features:
 * - Clerk SignIn component with custom styling
 * - Centered layout with decorative side panel
 * - Brand-consistent orange/amber theme
 */

import type { Metadata } from 'next';
import Link from 'next/link';
import { SignIn } from '@clerk/nextjs';
import { Feather, ArrowLeft } from 'lucide-react';

export const metadata: Metadata = {
  title: 'Sign In',
  description: 'Sign in to your CopyWorx account.',
};

/**
 * Sign-in page component
 * 
 * Uses Clerk's SignIn component with custom appearance
 * configured in the root layout's ClerkProvider.
 */
export default function SignInPage() {
  return (
    <div className="min-h-screen flex">
      {/* Left Side - Form */}
      <div className="flex-1 flex items-center justify-center p-8 bg-white">
        <div className="w-full max-w-md">
          {/* Back Link */}
          <Link 
            href="/home"
            className="inline-flex items-center text-sm text-ink-500 hover:text-ink-700 mb-8 transition-colors"
          >
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to home
          </Link>

          {/* Logo */}
          <div className="flex items-center gap-2 mb-8">
            <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-ink-900 shadow-lg">
              <Feather className="h-5 w-5 text-amber-400" />
            </div>
            <span className="font-sans text-2xl font-bold text-ink-900">
              CopyWorx
            </span>
          </div>

          {/* Clerk SignIn Component */}
          <SignIn 
            appearance={{
              elements: {
                rootBox: 'w-full',
                card: 'shadow-none p-0 w-full',
                headerTitle: 'font-sans text-2xl font-bold text-ink-900',
                headerSubtitle: 'text-ink-600',
                socialButtonsBlockButton: 
                  'border border-border bg-white hover:bg-ink-50 text-ink-700 transition-colors',
                socialButtonsBlockButtonText: 'font-medium',
                dividerLine: 'bg-border',
                dividerText: 'text-ink-400 text-xs',
                formFieldLabel: 'text-sm font-medium text-ink-700',
                formFieldInput: 
                  'border-border rounded-md focus:ring-2 focus:ring-amber-500 focus:border-amber-500 transition-colors',
                formButtonPrimary: 
                  'bg-amber-500 hover:bg-amber-400 text-ink-900 font-medium shadow-lg hover:shadow-xl transition-all rounded-md',
                footerActionLink: 
                  'text-amber-600 hover:text-amber-700 font-medium',
                identityPreviewEditButton: 'text-amber-600 hover:text-amber-700',
                formFieldAction: 'text-amber-600 hover:text-amber-700',
                alert: 'border-red-200 bg-red-50 text-red-800',
              },
            }}
            forceRedirectUrl="/worxspace"
            signUpUrl="/sign-up"
          />
        </div>
      </div>

      {/* Right Side - Decorative */}
      <div className="hidden lg:flex lg:flex-1 bg-ink-950 items-center justify-center p-8 relative overflow-hidden">
        {/* Background Pattern */}
        <div className="absolute inset-0 bg-grid-dark opacity-20" />
        
        {/* Decorative Elements */}
        <div className="absolute top-20 left-10 w-72 h-72 bg-amber-500/20 rounded-full blur-3xl" />
        <div className="absolute bottom-20 right-10 w-96 h-96 bg-ink-600/30 rounded-full blur-3xl" />
        
        {/* Content */}
        <div className="relative max-w-md text-center">
          <div className="text-6xl mb-6">‚úçÔ∏è</div>
          <h2 className="font-sans text-3xl font-bold text-white mb-4">
            Write copy that converts
          </h2>
          <p className="text-ink-300 leading-relaxed">
            Join thousands of copywriters and marketers using CopyWorx to create 
            compelling content that drives results.
          </p>
        </div>
      </div>
    </div>
  );
}


=== FILE: app/sign-up/[[...sign-up]]/page.tsx ===

/**
 * @file app/sign-up/[[...sign-up]]/page.tsx
 * @description Sign-up page using Clerk's SignUp component
 * 
 * Features:
 * - Clerk SignUp component with custom styling
 * - Centered layout with benefits side panel
 * - Brand-consistent orange/amber theme
 */

import type { Metadata } from 'next';
import Link from 'next/link';
import { SignUp } from '@clerk/nextjs';
import { Feather, ArrowLeft, CheckCircle2 } from 'lucide-react';

export const metadata: Metadata = {
  title: 'Sign Up',
  description: 'Create your CopyWorx account and start writing better copy.',
};

/**
 * Benefits list for the sign-up page
 */
const benefits = [
  '50+ AI-powered copywriting templates',
  'Unlimited projects and organization',
  'Brand voice customization',
  'Collaboration tools for teams',
  '14-day free trial, no credit card required',
] as const;

/**
 * Sign-up page component
 * 
 * Uses Clerk's SignUp component with custom appearance
 * configured in the root layout's ClerkProvider.
 */
export default function SignUpPage() {
  return (
    <div className="min-h-screen flex">
      {/* Left Side - Decorative */}
      <div className="hidden lg:flex lg:flex-1 bg-gradient-to-br from-amber-50 via-white to-ink-50 items-center justify-center p-8 relative overflow-hidden">
        {/* Background Pattern */}
        <div className="absolute inset-0 bg-grid opacity-40" />
        
        {/* Decorative Elements */}
        <div className="absolute top-20 right-10 w-72 h-72 bg-amber-400/20 rounded-full blur-3xl" />
        <div className="absolute bottom-20 left-10 w-96 h-96 bg-ink-400/10 rounded-full blur-3xl" />
        
        {/* Content */}
        <div className="relative max-w-md">
          <h2 className="font-sans text-4xl font-bold text-ink-900 mb-6">
            Start creating copy that converts today
          </h2>
          <p className="text-ink-600 leading-relaxed mb-8">
            Join over 10,000 marketers and copywriters who trust CopyWorx 
            to help them create compelling content every day.
          </p>
          
          {/* Benefits List */}
          <ul className="space-y-4">
            {benefits.map((benefit) => (
              <li key={benefit} className="flex items-center gap-3">
                <div className="h-6 w-6 rounded-full bg-green-100 flex items-center justify-center shrink-0">
                  <CheckCircle2 className="h-4 w-4 text-green-600" />
                </div>
                <span className="text-ink-700">{benefit}</span>
              </li>
            ))}
          </ul>
        </div>
      </div>

      {/* Right Side - Form */}
      <div className="flex-1 flex items-center justify-center p-8 bg-white">
        <div className="w-full max-w-md">
          {/* Back Link */}
          <Link 
            href="/home"
            className="inline-flex items-center text-sm text-ink-500 hover:text-ink-700 mb-8 transition-colors"
          >
            <ArrowLeft className="h-4 w-4 mr-2" />
            Back to home
          </Link>

          {/* Logo */}
          <div className="flex items-center gap-2 mb-8">
            <div className="flex h-10 w-10 items-center justify-center rounded-lg bg-ink-900 shadow-lg">
              <Feather className="h-5 w-5 text-amber-400" />
            </div>
            <span className="font-sans text-2xl font-bold text-ink-900">
              CopyWorx
            </span>
          </div>

          {/* Clerk SignUp Component */}
          <SignUp 
            appearance={{
              elements: {
                rootBox: 'w-full',
                card: 'shadow-none p-0 w-full',
                headerTitle: 'font-sans text-2xl font-bold text-ink-900',
                headerSubtitle: 'text-ink-600',
                socialButtonsBlockButton: 
                  'border border-border bg-white hover:bg-ink-50 text-ink-700 transition-colors',
                socialButtonsBlockButtonText: 'font-medium',
                dividerLine: 'bg-border',
                dividerText: 'text-ink-400 text-xs',
                formFieldLabel: 'text-sm font-medium text-ink-700',
                formFieldInput: 
                  'border-border rounded-md focus:ring-2 focus:ring-amber-500 focus:border-amber-500 transition-colors',
                formButtonPrimary: 
                  'bg-amber-500 hover:bg-amber-400 text-ink-900 font-medium shadow-lg hover:shadow-xl transition-all rounded-md',
                footerActionLink: 
                  'text-amber-600 hover:text-amber-700 font-medium',
                identityPreviewEditButton: 'text-amber-600 hover:text-amber-700',
                formFieldAction: 'text-amber-600 hover:text-amber-700',
                alert: 'border-red-200 bg-red-50 text-red-800',
              },
            }}
            forceRedirectUrl="/worxspace"
            signInUrl="/sign-in"
          />
          
          {/* Terms */}
          <p className="text-xs text-ink-400 text-center mt-6">
            By signing up, you agree to our{' '}
            <Link href="#" className="text-amber-600 hover:underline">
              Terms of Service
            </Link>{' '}
            and{' '}
            <Link href="#" className="text-amber-600 hover:underline">
              Privacy Policy
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
}


=== FILE: app/worxspace/page.tsx ===

/**
 * @file app/worxspace/page.tsx
 * @description Main workspace page with document version control
 * Route: /worxspace
 * 
 * Features:
 * - Document list with version grouping
 * - Editor with save/save-as-new-version
 * - Project switching
 * - AI tools
 */

'use client';

import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import dynamic from 'next/dynamic';
import { useSearchParams, useRouter } from 'next/navigation';
import { WorkspaceLayout } from '@/components/workspace/WorkspaceLayout';
import { EditorArea, type EditorAreaHandle } from '@/components/workspace/EditorArea';
import { LeftSidebarContent } from '@/components/workspace/LeftSidebarContent';
import { RightSidebarContent } from '@/components/workspace/RightSidebarContent';
import { TemplateFormSlideOut, TEMPLATE_FORM_PANEL_ID } from '@/components/workspace/TemplateFormSlideOut';
import { BrandVoiceSlideOut, BRAND_VOICE_PANEL_ID } from '@/components/workspace/BrandVoiceSlideOut';
import { PersonasSlideOut, PERSONAS_PANEL_ID } from '@/components/workspace/PersonasSlideOut';
import { OptimizeComparisonModal } from '@/components/workspace/OptimizeComparisonModal';
import { useWorkspaceStore } from '@/lib/stores/workspaceStore';
import { useIsSlideOutOpen, useSlideOutActions } from '@/lib/stores/slideOutStore';
import { getTemplateById } from '@/lib/data/templates';
import { initializeProjectSystem } from '@/lib/utils/project-utils';
import { createDocument, getDocument } from '@/lib/storage/unified-storage';
import { useProductTour } from '@/lib/hooks/useProductTour';
import { shouldRedirectToSplash } from '@/lib/utils/daily-visit-tracker';
import { logger } from '@/lib/utils/logger';
import type { Editor } from '@tiptap/react';
import type { ProjectDocument, Project } from '@/lib/types/project';

// Dynamic import for ProductTour to avoid SSR issues with react-joyride
const ProductTour = dynamic(() => import('@/components/ProductTour'), {
  ssr: false,
});

/**
 * Loading spinner component
 */
function LoadingSpinner() {
  return (
    <div className="h-screen w-screen flex items-center justify-center bg-[#f5f5f7]">
      <div className="flex flex-col items-center gap-4">
        <div className="w-8 h-8 border-2 border-[#007AFF] border-t-transparent rounded-full animate-spin" />
        <p className="text-sm text-[#86868b]">Loading workspace...</p>
      </div>
    </div>
  );
}

/**
 * Main workspace page component
 */
export default function WorkspacePage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const action = searchParams.get('action');
  const templateParam = searchParams.get('template');
  const documentParam = searchParams.get('document');
  const importParam = searchParams.get('import');
  
  // Client-side mounting state
  const [mounted, setMounted] = useState(false);
  
  // Editor instance state
  const [editor, setEditor] = useState<Editor | null>(null);
  
  // Ref for EditorArea to call loadDocument
  const editorRef = useRef<EditorAreaHandle>(null);
  
  // Prevent double initialization in StrictMode
  const initRef = useRef(false);
  
  // Track if daily redirect check has been performed
  const dailyCheckRef = useRef(false);
  
  // Product tour state
  const { runTour, completeTour, restartTour } = useProductTour();
  
  // Slide-outs state
  const isTemplateFormOpen = useIsSlideOutOpen(TEMPLATE_FORM_PANEL_ID);
  const isBrandVoiceOpen = useIsSlideOutOpen(BRAND_VOICE_PANEL_ID);
  const isPersonasOpen = useIsSlideOutOpen(PERSONAS_PANEL_ID);
  const { closeSlideOut } = useSlideOutActions();
  const selectedTemplateId = useWorkspaceStore((state) => state.selectedTemplateId);
  const activeProjectId = useWorkspaceStore((state) => state.activeProjectId);
  const activeDocumentId = useWorkspaceStore((state) => state.activeDocumentId);
  const projects = useWorkspaceStore((state) => state.projects);
  
  // Get selected template and active project
  const selectedTemplate = useMemo(() => {
    return selectedTemplateId ? getTemplateById(selectedTemplateId) ?? null : null;
  }, [selectedTemplateId]);
  
  const activeProject = useMemo((): Project | null => {
    if (!activeProjectId) return null;
    return projects.find((p) => p.id === activeProjectId) || null;
  }, [activeProjectId, projects]);
  
  // Wait for client-side mounting
  useEffect(() => {
    setMounted(true);
  }, []);
  
  // Check for first visit of the day - redirect to splash page if needed
  useEffect(() => {
    if (!mounted || dailyCheckRef.current) return;
    dailyCheckRef.current = true;
    
    // Check if this is the first visit of the day
    if (shouldRedirectToSplash()) {
      logger.log('üåÖ First visit of the day - redirecting to splash page');
      router.push('/home');
    } else {
      logger.log('‚úÖ Already visited today - continuing to workspace');
    }
  }, [mounted, router]);
  
  // Initialize workspace
  useEffect(() => {
    if (!mounted || initRef.current) return;
    initRef.current = true;
    
    logger.log('üöÄ Initializing workspace...');
    
    // Initialize project system
    initializeProjectSystem();
    
    // Refresh projects into store
    const store = useWorkspaceStore.getState();
    store.refreshProjects();
    
    // Note: Documents are created via DocumentList, not automatically here
    // The activeDocumentId will be restored from Zustand persistence if it exists
    logger.log('‚úÖ Workspace initialized');
  }, [mounted, action]);
  
  // Handle template parameter from URL (coming from splash page)
  useEffect(() => {
    if (!mounted || !templateParam) return;
    
    logger.log('üé® Template parameter detected:', templateParam);
    logger.log('üìÑ Document parameter:', documentParam);
    
    // Get store state
    const store = useWorkspaceStore.getState();
    
    // Check if we have an active project
    if (!store.activeProjectId) {
      logger.error('‚ùå No active project found');
      return;
    }
    
    const handleTemplateParam = async () => {
      // If document parameter exists, load that existing document
      if (documentParam) {
        try {
          const existingDoc = await getDocument(store.activeProjectId!, documentParam);
          
          if (existingDoc) {
            // Set as active document
            store.setActiveDocumentId(existingDoc.id);
            logger.log('‚úÖ Loading existing document from splash page:', existingDoc.id, existingDoc.title);
            
            // Load the document into the editor
            if (editorRef.current) {
              editorRef.current.loadDocument(existingDoc);
            }
          } else {
            logger.error('‚ùå Document not found:', documentParam);
          }
        } catch (error) {
          logger.error('‚ùå Failed to load document:', error);
        }
      }
      // Fallback: create new document if no document parameter provided
      else if (!store.activeDocumentId) {
        try {
          const template = getTemplateById(templateParam);
          if (!template) {
            logger.error('‚ùå Template not found:', templateParam);
            return;
          }
          
          const newDoc = await createDocument(store.activeProjectId!, `${template.name}`);
          store.setActiveDocumentId(newDoc.id);
          logger.log('‚úÖ Created new document for template:', newDoc.id, newDoc.title);
          
          // Load the document into the editor
          if (editorRef.current) {
            editorRef.current.loadDocument(newDoc);
          }
        } catch (error) {
          logger.error('‚ùå Failed to create document for template:', error);
        }
      }
      
      // Set the template if not already set
      if (!store.selectedTemplateId) {
        store.setSelectedTemplateId(templateParam);
      }
      
      // Ensure right sidebar is open
      if (!store.rightSidebarOpen) {
        store.setRightSidebarOpen(true);
      }
      
      logger.log('‚úÖ Template slideout should be visible');
    };
    
    handleTemplateParam();
  }, [mounted, templateParam, documentParam]);
  
  // Handle file import from splash page
  useEffect(() => {
    if (!mounted || !importParam || !editor) return;
    
    logger.log('üì• Import parameter detected, checking for pending file...');
    
    // Check for pending file import in localStorage
    const pendingImportStr = localStorage.getItem('pendingFileImport');
    const pendingContent = localStorage.getItem('pendingFileContent');
    
    if (!pendingImportStr || !pendingContent) {
      logger.warn('‚ö†Ô∏è No pending import found');
      return;
    }
    
    try {
      const importData = JSON.parse(pendingImportStr);
      const { fileName, fileType, documentId } = importData;
      
      logger.log('üì• Processing import:', fileName);
      
      // Process the import based on file type
      const processImport = async () => {
        try {
          if (fileName.endsWith('.docx')) {
            // Decode base64 back to binary
            const binaryString = atob(pendingContent);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              bytes[i] = binaryString.charCodeAt(i);
            }
            const blob = new Blob([bytes], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
            const file = new File([blob], fileName, { type: fileType });
            
            // Import using the document-import utility
            const { importDocument } = await import('@/lib/utils/document-import');
            const result = await importDocument(editor, file);
            
            if (result.success) {
              logger.log('‚úÖ Successfully imported DOCX file');
            } else {
              logger.error('‚ùå Failed to import DOCX:', result.error);
            }
          } else {
            // For text files (txt, md), just set the content directly
            editor.commands.setContent(pendingContent);
            logger.log('‚úÖ Successfully imported text file');
          }
          
          // Clear the pending import data
          localStorage.removeItem('pendingFileImport');
          localStorage.removeItem('pendingFileContent');
          
        } catch (error) {
          logger.error('‚ùå Error processing import:', error);
          // Clear the data anyway to prevent retry loop
          localStorage.removeItem('pendingFileImport');
          localStorage.removeItem('pendingFileContent');
        }
      };
      
      // Execute the import
      processImport();
      
    } catch (error) {
      logger.error('‚ùå Error parsing pending import:', error);
      // Clear corrupted data
      localStorage.removeItem('pendingFileImport');
      localStorage.removeItem('pendingFileContent');
    }
  }, [mounted, importParam, editor]);
  
  // Handle editor ready
  const handleEditorReady = React.useCallback((editorInstance: Editor | null) => {
    setEditor(editorInstance);
  }, []);
  
  /**
   * Handle document click from DocumentList
   * Loads the selected document into the editor
   */
  const handleDocumentClick = useCallback((doc: ProjectDocument) => {
    logger.log('üìÑ Document clicked in workspace:', {
      id: doc.id,
      title: doc.title,
      version: doc.version,
    });
    
    if (editorRef.current) {
      editorRef.current.loadDocument(doc);
    } else {
      logger.warn('‚ö†Ô∏è Editor ref not ready, cannot load document');
    }
  }, []);
  
  /**
   * Handle closing template form slide-out
   */
  const handleCloseTemplateForm = useCallback(() => {
    closeSlideOut(TEMPLATE_FORM_PANEL_ID);
  }, [closeSlideOut]);
  
  /**
   * Handle closing brand voice slide-out
   */
  const handleCloseBrandVoice = useCallback(() => {
    closeSlideOut(BRAND_VOICE_PANEL_ID);
  }, [closeSlideOut]);
  
  /**
   * Handle closing personas slide-out
   */
  const handleClosePersonas = useCallback(() => {
    closeSlideOut(PERSONAS_PANEL_ID);
  }, [closeSlideOut]);
  
  // Show loading during SSR/hydration
  if (!mounted) {
    return <LoadingSpinner />;
  }
  
  return (
    <>
      <WorkspaceLayout
        leftSidebar={<LeftSidebarContent onDocumentClick={handleDocumentClick} />}
        rightSidebar={<RightSidebarContent editor={editor} />}
        onRestartTour={restartTour}
      >
        <EditorArea ref={editorRef} onEditorReady={handleEditorReady} />
      </WorkspaceLayout>
      
      {/* Template Form Slide-Out - Opens from right when template selected */}
      {/* Only render for non-multi-section templates - multi-section templates use RightSidebarContent */}
      {selectedTemplate && selectedTemplate.id !== 'brochure-multi-section' && (
        <TemplateFormSlideOut
          isOpen={isTemplateFormOpen}
          onClose={handleCloseTemplateForm}
          template={selectedTemplate}
          editor={editor}
          activeProject={activeProject}
        />
      )}
      
      {/* Brand Voice Slide-Out - Opens from right when brand voice tool clicked */}
      <BrandVoiceSlideOut
        isOpen={isBrandVoiceOpen}
        onClose={handleCloseBrandVoice}
      />
      
      {/* Personas Slide-Out - Opens from right when personas tool clicked */}
      <PersonasSlideOut
        isOpen={isPersonasOpen}
        onClose={handleClosePersonas}
      />
      
      {/* Product Tour - Shows on first visit */}
      <ProductTour run={runTour} onComplete={completeTour} />
      
      {/* Optimize Alignment Comparison Modal - Shows after rewrite optimization */}
      <OptimizeComparisonModal
        editor={editor}
        projectId={activeProjectId}
        documentId={activeDocumentId}
      />
    </>
  );
}


=== FILE: collect-source-code.js ===

#!/usr/bin/env node

/**
 * Copyright Source Code Collection Script
 * Collects all TypeScript/JavaScript source files for U.S. Copyright Office registration
 */

const fs = require('fs');
const path = require('path');

// Configuration
const BASE_DIR = '/Users/experracbo/Desktop/copyworx-v4';
const OUTPUT_FILE = path.join(BASE_DIR, 'copyworx-source-code-complete.txt');
const SUMMARY_FILE = path.join(BASE_DIR, 'copyright-filing-summary.txt');

const EXCLUDED_DIRS = ['node_modules', '.next', 'dist', 'build', '.git', '.vercel'];
const EXCLUDED_FILES = ['package-lock.json', 'yarn.lock'];
const VALID_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx'];

// Storage for collected files
const collectedFiles = [];

/**
 * Check if a directory should be excluded
 */
function shouldExcludeDir(dirName) {
  return EXCLUDED_DIRS.includes(dirName);
}

/**
 * Check if a file should be excluded
 */
function shouldExcludeFile(fileName) {
  // Exclude specific files
  if (EXCLUDED_FILES.includes(fileName)) return true;
  
  // Exclude .env files
  if (fileName.startsWith('.env')) return true;
  
  // Only include files with valid extensions
  const ext = path.extname(fileName);
  return !VALID_EXTENSIONS.includes(ext);
}

/**
 * Recursively scan directory for source files
 */
function scanDirectory(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    
    if (entry.isDirectory()) {
      // Skip excluded directories
      if (!shouldExcludeDir(entry.name)) {
        scanDirectory(fullPath);
      }
    } else if (entry.isFile()) {
      // Process files
      if (!shouldExcludeFile(entry.name)) {
        const relativePath = path.relative(BASE_DIR, fullPath);
        const content = fs.readFileSync(fullPath, 'utf-8');
        const lineCount = content.split('\n').length;
        
        collectedFiles.push({
          relativePath,
          fullPath,
          content,
          lineCount
        });
      }
    }
  }
}

/**
 * Sort files alphabetically by relative path
 */
function sortFiles() {
  collectedFiles.sort((a, b) => a.relativePath.localeCompare(b.relativePath));
}

/**
 * Write concatenated source code file
 */
function writeSourceCodeFile() {
  const stream = fs.createWriteStream(OUTPUT_FILE, { encoding: 'utf-8' });
  
  // Write header
  stream.write('CopyWorx Studio - Complete Source Code\n');
  stream.write(`Generated on: ${new Date().toISOString().split('T')[0]} ${new Date().toLocaleTimeString()}\n`);
  stream.write('For U.S. Copyright Office Registration\n');
  stream.write('\n');
  stream.write('========================================\n');
  stream.write('\n');
  
  // Write each file with header
  for (const file of collectedFiles) {
    stream.write('\n');
    stream.write(`=== FILE: ${file.relativePath} ===\n`);
    stream.write('\n');
    stream.write(file.content);
    stream.write('\n');
  }
  
  stream.end();
  
  console.log(`‚úÖ Source code file created: ${OUTPUT_FILE}`);
}

/**
 * Write summary file
 */
function writeSummaryFile() {
  const stream = fs.createWriteStream(SUMMARY_FILE, { encoding: 'utf-8' });
  
  const totalFiles = collectedFiles.length;
  const totalLines = collectedFiles.reduce((sum, file) => sum + file.lineCount, 0);
  
  // Count by extension
  const extCounts = {
    '.ts': 0,
    '.tsx': 0,
    '.js': 0,
    '.jsx': 0
  };
  
  for (const file of collectedFiles) {
    const ext = path.extname(file.relativePath);
    if (extCounts.hasOwnProperty(ext)) {
      extCounts[ext]++;
    }
  }
  
  // Write header
  stream.write('CopyWorx Studio - Copyright Filing Summary\n');
  stream.write(`Generated on: ${new Date().toISOString().split('T')[0]} ${new Date().toLocaleTimeString()}\n`);
  stream.write('\n');
  stream.write('========================================\n');
  stream.write('SUMMARY STATISTICS\n');
  stream.write('========================================\n');
  stream.write('\n');
  stream.write(`Total Files Included: ${totalFiles}\n`);
  stream.write(`Total Lines of Code: ${totalLines}\n`);
  stream.write('\n');
  stream.write('File Breakdown:\n');
  stream.write(`  TypeScript (.ts):      ${extCounts['.ts']}\n`);
  stream.write(`  TypeScript JSX (.tsx): ${extCounts['.tsx']}\n`);
  stream.write(`  JavaScript (.js):      ${extCounts['.js']}\n`);
  stream.write(`  JavaScript JSX (.jsx): ${extCounts['.jsx']}\n`);
  stream.write('\n');
  stream.write('========================================\n');
  stream.write('COMPLETE FILE LIST WITH LINE COUNTS\n');
  stream.write('========================================\n');
  stream.write('\n');
  
  // Write file list
  for (const file of collectedFiles) {
    const paddedPath = file.relativePath.padEnd(80, ' ');
    const lineInfo = `${file.lineCount} lines`;
    stream.write(`${paddedPath} ${lineInfo.padStart(10, ' ')}\n`);
  }
  
  stream.write('\n');
  stream.write('========================================\n');
  stream.write('NOTES FOR COPYRIGHT REGISTRATION\n');
  stream.write('========================================\n');
  stream.write('\n');
  stream.write('This package contains the complete source code for CopyWorx Studio,\n');
  stream.write('an AI-powered copywriting platform.\n');
  stream.write('\n');
  stream.write('Excluded from this filing:\n');
  stream.write('  - node_modules (third-party dependencies)\n');
  stream.write('  - .next (build artifacts)\n');
  stream.write('  - dist, build (compiled output)\n');
  stream.write('  - .git (version control metadata)\n');
  stream.write('  - .vercel (deployment configuration)\n');
  stream.write('  - package-lock.json, yarn.lock (dependency lock files)\n');
  stream.write('  - .env files (environment configuration)\n');
  stream.write('\n');
  stream.write('All source files are included in alphabetical order by path.\n');
  stream.write('Each file is prefixed with its relative path for easy reference.\n');
  stream.write('\n');
  
  stream.end();
  
  console.log(`‚úÖ Summary file created: ${SUMMARY_FILE}`);
}

/**
 * Main execution
 */
function main() {
  console.log('üîç Scanning CopyWorx Studio source code...\n');
  console.log(`Base directory: ${BASE_DIR}`);
  console.log(`Excluding directories: ${EXCLUDED_DIRS.join(', ')}`);
  console.log(`Including extensions: ${VALID_EXTENSIONS.join(', ')}\n`);
  
  // Scan directory
  console.log('üìÇ Scanning directories...');
  scanDirectory(BASE_DIR);
  
  console.log(`üìÑ Found ${collectedFiles.length} source files\n`);
  
  // Sort files
  console.log('üî§ Sorting files alphabetically...');
  sortFiles();
  
  // Write output files
  console.log('üíæ Writing output files...\n');
  writeSourceCodeFile();
  writeSummaryFile();
  
  // Final summary
  const totalLines = collectedFiles.reduce((sum, file) => sum + file.lineCount, 0);
  const outputSize = (fs.statSync(OUTPUT_FILE).size / 1024 / 1024).toFixed(2);
  
  console.log('\n========================================');
  console.log('‚úÖ COPYRIGHT PACKAGE COMPLETE');
  console.log('========================================\n');
  console.log(`Total Files:  ${collectedFiles.length}`);
  console.log(`Total Lines:  ${totalLines.toLocaleString()}`);
  console.log(`Output Size:  ${outputSize} MB\n`);
  console.log('üìÅ Files created:');
  console.log(`   - ${OUTPUT_FILE}`);
  console.log(`   - ${SUMMARY_FILE}\n`);
}

// Run the script
try {
  main();
} catch (error) {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
}


=== FILE: components/ApiUsageDisplay.tsx ===

/**
 * @file components/ApiUsageDisplay.tsx
 * @description Displays API usage statistics for the current user
 * 
 * Features:
 * - Progress bar showing usage against $5.00 beta limit
 * - Color-coded status (green/yellow/red)
 * - Loading skeleton state
 * - Tooltip with beta info
 * - Responsive design for sidebar/topbar placement
 * 
 * @example
 * ```tsx
 * // In sidebar or dashboard
 * <ApiUsageDisplay />
 * 
 * // Compact variant for header
 * <ApiUsageDisplay variant="compact" />
 * ```
 */

'use client';

import React, { useState } from 'react';
import { useApiUsage } from '@/lib/hooks/useApiUsage';
import { cn } from '@/lib/utils';
import { AlertTriangle, Info, RefreshCw } from 'lucide-react';

// ============================================================================
// Types
// ============================================================================

interface ApiUsageDisplayProps {
  /** Display variant */
  variant?: 'default' | 'compact';
  /** Additional CSS classes */
  className?: string;
}

// ============================================================================
// Helper Components
// ============================================================================

/**
 * Skeleton loader for the usage display
 */
function UsageSkeleton({ variant }: { variant: 'default' | 'compact' }) {
  if (variant === 'compact') {
    return (
      <div className="flex items-center gap-2 animate-pulse">
        <div className="h-2 w-16 bg-ink-200 dark:bg-ink-700 rounded-full" />
        <div className="h-3 w-12 bg-ink-200 dark:bg-ink-700 rounded" />
      </div>
    );
  }

  return (
    <div className="space-y-2 animate-pulse">
      <div className="flex items-center justify-between">
        <div className="h-3 w-16 bg-ink-200 dark:bg-ink-700 rounded" />
        <div className="h-3 w-12 bg-ink-200 dark:bg-ink-700 rounded" />
      </div>
      <div className="h-2 w-full bg-ink-200 dark:bg-ink-700 rounded-full" />
      <div className="flex items-center justify-between">
        <div className="h-3 w-20 bg-ink-200 dark:bg-ink-700 rounded" />
        <div className="h-3 w-16 bg-ink-200 dark:bg-ink-700 rounded" />
      </div>
    </div>
  );
}

/**
 * Tooltip component for displaying beta info
 */
function Tooltip({ 
  children, 
  content 
}: { 
  children: React.ReactNode; 
  content: string;
}) {
  const [isVisible, setIsVisible] = useState(false);

  return (
    <div 
      className="relative inline-block"
      onMouseEnter={() => setIsVisible(true)}
      onMouseLeave={() => setIsVisible(false)}
      onFocus={() => setIsVisible(true)}
      onBlur={() => setIsVisible(false)}
    >
      {children}
      {isVisible && (
        <div 
          className="absolute z-50 top-full left-1/2 -translate-x-1/2 mt-2 px-3 py-2 text-xs text-white bg-ink-900 dark:bg-ink-700 rounded-lg shadow-lg whitespace-nowrap max-w-[250px] text-center"
          role="tooltip"
        >
          {content}
          {/* Arrow pointing up */}
          <div className="absolute bottom-full left-1/2 -translate-x-1/2 border-4 border-transparent border-b-ink-900 dark:border-b-ink-700" />
        </div>
      )}
    </div>
  );
}

// ============================================================================
// Progress Bar Colors
// ============================================================================

/**
 * Get progress bar color based on percentage used
 */
function getProgressColor(percentUsed: number): string {
  if (percentUsed >= 80) {
    return 'bg-red-500'; // #ef4444
  }
  if (percentUsed >= 50) {
    return 'bg-amber-500'; // #f59e0b
  }
  return 'bg-emerald-500'; // #10b981
}

/**
 * Get text color based on percentage used
 */
function getTextColor(percentUsed: number, isOverLimit: boolean): string {
  if (isOverLimit) {
    return 'text-red-600 dark:text-red-400 font-semibold';
  }
  if (percentUsed >= 80) {
    return 'text-red-600 dark:text-red-400';
  }
  if (percentUsed >= 50) {
    return 'text-amber-600 dark:text-amber-400';
  }
  return 'text-ink-600 dark:text-ink-300';
}

// ============================================================================
// Main Component
// ============================================================================

/**
 * API Usage Display component
 * 
 * Shows the user's API usage progress toward the $5.00 beta limit
 * with color-coded status indicators and helpful tooltips.
 */
export function ApiUsageDisplay({ 
  variant = 'default',
  className 
}: ApiUsageDisplayProps) {
  const {
    totalCost,
    percentUsed,
    remainingBudget,
    isOverLimit,
    isLoading,
    error,
    refetch,
  } = useApiUsage();

  // Format currency to 2 decimal places
  const formatCurrency = (amount: number): string => {
    return `$${amount.toFixed(2)}`;
  };

  // Format percentage (cap display at 100% for visual, show actual in text)
  const displayPercent = Math.min(percentUsed, 100);
  const percentText = `${Math.round(percentUsed)}%`;

  // Handle error state
  if (error && !isLoading) {
    return (
      <div className={cn('text-xs text-red-500', className)}>
        <span>Unable to load usage</span>
      </div>
    );
  }

  // ============================================================================
  // Compact Variant
  // ============================================================================
  
  if (variant === 'compact') {
    if (isLoading) {
      return <UsageSkeleton variant="compact" />;
    }

    return (
      <Tooltip content="Beta users have $5 API credit. Contact support to upgrade.">
        <div 
          className={cn(
            'flex items-center gap-1.5 cursor-help',
            'min-w-[75px] max-w-[90px]', // Constrain width to prevent overlap
            className
          )}
        >
          {/* Mini progress bar */}
          <div className="w-12 sm:w-16 h-1.5 bg-ink-200 dark:bg-ink-700 rounded-full overflow-hidden flex-shrink-0">
            <div
              className={cn(
                'h-full rounded-full transition-all duration-500',
                getProgressColor(percentUsed)
              )}
              style={{ width: `${displayPercent}%` }}
            />
          </div>
          
          {/* Cost text */}
          <span className={cn(
            'text-xs font-medium whitespace-nowrap',
            getTextColor(percentUsed, isOverLimit)
          )}>
            {formatCurrency(totalCost)}
          </span>

          {/* Warning icon if over limit */}
          {isOverLimit && (
            <AlertTriangle className="w-3 h-3 text-red-500 flex-shrink-0" />
          )}
        </div>
      </Tooltip>
    );
  }

  // ============================================================================
  // Default Variant
  // ============================================================================

  if (isLoading) {
    return (
      <div className={cn('p-3 rounded-lg bg-ink-50 dark:bg-ink-900/50', className)}>
        <UsageSkeleton variant="default" />
      </div>
    );
  }

  return (
    <div 
      className={cn(
        'p-3 rounded-lg bg-ink-50 dark:bg-ink-900/50 border border-ink-200 dark:border-ink-800',
        className
      )}
    >
      {/* Header */}
      <div className="flex items-center justify-between mb-2">
        <Tooltip content="Beta users have $5 API credit. Contact support to upgrade.">
          <div className="flex items-center gap-1.5 cursor-help">
            <span className="text-xs font-medium text-ink-500 dark:text-ink-400 uppercase tracking-wide">
              API Usage
            </span>
            <Info className="w-3 h-3 text-ink-400 dark:text-ink-500" />
          </div>
        </Tooltip>

        {/* Refresh button */}
        <button
          onClick={() => refetch()}
          className="p-1 rounded hover:bg-ink-200 dark:hover:bg-ink-800 transition-colors"
          title="Refresh usage data"
          aria-label="Refresh usage data"
        >
          <RefreshCw className="w-3 h-3 text-ink-400 dark:text-ink-500" />
        </button>
      </div>

      {/* Progress Bar */}
      <div className="mb-2">
        <div className="h-2 bg-ink-200 dark:bg-ink-700 rounded-full overflow-hidden">
          <div
            className={cn(
              'h-full rounded-full transition-all duration-500 ease-out',
              getProgressColor(percentUsed)
            )}
            style={{ width: `${displayPercent}%` }}
            role="progressbar"
            aria-valuenow={Math.round(percentUsed)}
            aria-valuemin={0}
            aria-valuemax={100}
            aria-label={`API usage: ${percentText}`}
          />
        </div>
      </div>

      {/* Stats Row */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-1">
        {/* Cost display */}
        <span className={cn(
          'text-sm',
          getTextColor(percentUsed, isOverLimit)
        )}>
          {formatCurrency(totalCost)} / $5.00
        </span>

        {/* Percentage or Limit Badge */}
        {isOverLimit ? (
          <div className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-400 text-xs font-semibold">
            <AlertTriangle className="w-3 h-3" />
            Limit Reached
          </div>
        ) : (
          <span className={cn(
            'text-xs',
            getTextColor(percentUsed, isOverLimit)
          )}>
            {percentText} used
          </span>
        )}
      </div>

      {/* Remaining budget (only show if not over limit) */}
      {!isOverLimit && remainingBudget > 0 && (
        <p className="text-xs text-ink-400 dark:text-ink-500 mt-1.5">
          {formatCurrency(remainingBudget)} remaining
        </p>
      )}

      {/* Over limit message */}
      {isOverLimit && (
        <p className="text-xs text-red-600 dark:text-red-400 mt-1.5">
          Contact support to upgrade your plan.
        </p>
      )}
    </div>
  );
}

// ============================================================================
// Default Export
// ============================================================================

export default ApiUsageDisplay;


=== FILE: components/layout/footer.tsx ===

/**
 * @file components/layout/footer.tsx
 * @description Footer component for the marketing site
 * 
 * Contains:
 * - Company info and links
 * - Navigation sections
 * - Social links
 * - Copyright notice
 */

import Link from 'next/link';
import { Feather, Twitter, Github, Linkedin, Mail } from 'lucide-react';

/**
 * Footer link sections configuration
 */
const footerSections = [
  {
    title: 'Product',
    links: [
      { href: '/pricing', label: 'Pricing' },
      { href: '/templates', label: 'Templates' },
      { href: '#features', label: 'Features' },
      { href: '#integrations', label: 'Integrations' },
    ],
  },
  {
    title: 'Company',
    links: [
      { href: '/about', label: 'About' },
      { href: '#careers', label: 'Careers' },
      { href: '#blog', label: 'Blog' },
      { href: '#press', label: 'Press' },
    ],
  },
  {
    title: 'Resources',
    links: [
      { href: '#docs', label: 'Documentation' },
      { href: '#tutorials', label: 'Tutorials' },
      { href: '#support', label: 'Support' },
      { href: '#community', label: 'Community' },
    ],
  },
  {
    title: 'Legal',
    links: [
      { href: '#privacy', label: 'Privacy' },
      { href: '#terms', label: 'Terms' },
      { href: '#cookies', label: 'Cookies' },
      { href: '#security', label: 'Security' },
    ],
  },
] as const;

/**
 * Social links configuration
 */
const socialLinks = [
  { href: '#twitter', icon: Twitter, label: 'Twitter' },
  { href: '#github', icon: Github, label: 'GitHub' },
  { href: '#linkedin', icon: Linkedin, label: 'LinkedIn' },
  { href: 'mailto:hello@copyworx.app', icon: Mail, label: 'Email' },
] as const;

/**
 * Footer component
 * 
 * Full-width footer with multiple sections, social links, and newsletter signup.
 */
export function Footer() {
  const currentYear = new Date().getFullYear();

  return (
    <footer className="bg-ink-950 text-white">
      {/* Main Footer Content */}
      <div className="container mx-auto px-4 sm:px-6 lg:px-8">
        <div className="py-16 lg:py-20">
          <div className="grid grid-cols-2 md:grid-cols-6 lg:grid-cols-12 gap-8 lg:gap-12">
            {/* Brand Section */}
            <div className="col-span-2 md:col-span-6 lg:col-span-4">
              <Link 
                href="/home" 
                className="inline-flex items-center gap-2 mb-4"
              >
                <div className="flex h-9 w-9 items-center justify-center rounded-lg bg-amber-500 shadow-lg">
                  <Feather className="h-5 w-5 text-ink-900" />
                </div>
                <span className="font-sans text-xl font-bold text-white">
                  CopyWorx
                </span>
              </Link>
              <p className="text-ink-300 text-sm leading-relaxed max-w-xs mb-6">
                Create compelling copy that converts. AI-powered templates and tools for professional copywriters and marketers.
              </p>
              {/* Social Links */}
              <div className="flex gap-4">
                {socialLinks.map((social) => (
                  <a
                    key={social.label}
                    href={social.href}
                    className="flex h-10 w-10 items-center justify-center rounded-full bg-ink-800 text-ink-300 hover:bg-amber-500 hover:text-ink-900 transition-all duration-300"
                    aria-label={social.label}
                  >
                    <social.icon className="h-5 w-5" />
                  </a>
                ))}
              </div>
            </div>

            {/* Footer Sections */}
            {footerSections.map((section) => (
              <div key={section.title} className="col-span-1 lg:col-span-2">
                <h3 className="text-sm font-semibold text-white mb-4">
                  {section.title}
                </h3>
                <ul className="space-y-3">
                  {section.links.map((link) => (
                    <li key={link.label}>
                      <Link
                        href={link.href}
                        className="text-sm text-ink-400 hover:text-amber-400 transition-colors"
                      >
                        {link.label}
                      </Link>
                    </li>
                  ))}
                </ul>
              </div>
            ))}
          </div>
        </div>

        {/* Bottom Bar */}
        <div className="border-t border-ink-800 py-6">
          <div className="flex flex-col md:flex-row justify-between items-center gap-4">
            <p className="text-sm text-ink-400">
              ¬© {currentYear} CopyWorx‚Ñ¢ Studio LLC. All rights reserved.
            </p>
            <p className="text-sm text-ink-500">
              CopyWorx‚Ñ¢ and AI@Worx‚Ñ¢ are trademarks of CopyWorx‚Ñ¢ Studio LLC.
            </p>
          </div>
        </div>
      </div>
    </footer>
  );
}



=== FILE: components/layout/index.ts ===

/**
 * @file components/layout/index.ts
 * @description Barrel export for layout components
 */

export { Navbar } from './navbar';
export { Footer } from './footer';
export { Sidebar } from './sidebar';



=== FILE: components/layout/marketing-footer.tsx ===

/**
 * @file components/layout/marketing-footer.tsx
 * @description Simplified footer component for the marketing site
 * 
 * Layout:
 * - Left: CopyWorx logo
 * - Right: Social media icons (LinkedIn, Email)
 * - Center: Copyright text below
 */

import Link from 'next/link';
import Image from 'next/image';
import { Linkedin, Mail } from 'lucide-react';

/**
 * Social links configuration
 */
const socialLinks = [
  { href: 'https://www.linkedin.com/company/copyworx-studio', icon: Linkedin, label: 'LinkedIn' },
  { href: 'mailto:support@copyworx.io', icon: Mail, label: 'Email' },
];

/**
 * MarketingFooter component
 * 
 * Simplified footer with logo, social icons, and copyright.
 */
export function MarketingFooter() {
  return (
    <footer className="bg-[#1a1a1a] text-white">
      <div className="container mx-auto px-4 sm:px-6 lg:px-8">
        {/* Main Footer Content */}
        <div className="py-8 flex flex-col lg:flex-row justify-between items-center gap-8">
          {/* Logo and Tagline */}
          <div className="flex flex-col md:flex-row items-center gap-6">
            {/* Logo - White background version with padding for breathing room */}
            <Link 
              href="/home" 
              className="flex-shrink-0 flex items-center transition-opacity hover:opacity-80 bg-white rounded-md px-4 py-2"
            >
              <Image
                src="/CopyWorx_2_WB.png"
                alt="CopyWorx Studio Logo"
                width={304}
                height={85}
                className="h-[68px] w-auto"
              />
            </Link>
            
            {/* Tagline */}
            <p className="text-xs text-white/80 leading-relaxed max-w-md text-center md:text-left">
              CopyWorx‚Ñ¢ Studio leverages proven, time-tested copywriting tools and combines them with the power of AI to create a platform any marketing professional can use ‚Äî regardless of writing experience ‚Äî to create professional, high-converting copy in minutes.
            </p>
          </div>

          {/* Social Links */}
          <div className="flex items-center gap-3 flex-shrink-0">
            {socialLinks.map((social) => (
              <a
                key={social.label}
                href={social.href}
                className="flex h-10 w-10 items-center justify-center rounded-full bg-gradient-to-r from-[#006EE6] to-[#A755F7] text-white hover:opacity-80 transition-all duration-300"
                aria-label={social.label}
              >
                <social.icon className="h-5 w-5" />
              </a>
            ))}
          </div>
        </div>

        {/* Copyright - Centered */}
        <div className="border-t border-white/10 py-6">
          <div className="text-center space-y-2">
            <p className="text-sm text-white/60">
              ¬© 2026 CopyWorx‚Ñ¢ Studio LLC. All rights reserved.
            </p>
            <p className="text-xs text-white/40">
              CopyWorx‚Ñ¢ and AI@Worx‚Ñ¢ are trademarks of CopyWorx‚Ñ¢ Studio LLC.
            </p>
          </div>
        </div>
      </div>
    </footer>
  );
}


=== FILE: components/layout/navbar.tsx ===

/**
 * @file components/layout/navbar.tsx
 * @description Main navigation component for the marketing site
 * 
 * Features:
 * - Responsive design with mobile menu
 * - Authentication state awareness
 * - UserButton for logged-in users
 * - Glass morphism effect on scroll
 */

'use client';

import * as React from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { SignedIn, SignedOut, UserButton } from '@clerk/nextjs';
import { Menu, X, Feather } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

/**
 * Navigation links configuration
 */
const navLinks = [
  { href: '/copyworx', label: 'Home' },
  { href: '/about', label: 'About' },
  { href: '/pricing', label: 'Pricing' },
] as const;

/**
 * Navbar component
 * 
 * Main navigation bar for the marketing site with:
 * - Logo and brand
 * - Navigation links
 * - Auth buttons (Sign In/Get Started) or UserButton
 * - Mobile responsive menu
 */
export function Navbar() {
  const [isOpen, setIsOpen] = React.useState(false);
  const [isScrolled, setIsScrolled] = React.useState(false);
  const pathname = usePathname();

  // Track scroll position for glass effect
  React.useEffect(() => {
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 10);
    };

    window.addEventListener('scroll', handleScroll, { passive: true });
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  // Close mobile menu on route change
  React.useEffect(() => {
    setIsOpen(false);
  }, [pathname]);

  return (
    <header
      className={cn(
        'fixed top-0 left-0 right-0 z-50 transition-all duration-300',
        isScrolled
          ? 'glass border-b border-border/50 shadow-sm'
          : 'bg-transparent'
      )}
    >
      <nav className="container mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex h-16 items-center justify-between">
          {/* Logo */}
          <Link 
            href="/home" 
            className="flex items-center gap-2 transition-opacity hover:opacity-80"
          >
            <div className="flex h-9 w-9 items-center justify-center rounded-lg bg-ink-900 shadow-lg">
              <Feather className="h-5 w-5 text-amber-400" />
            </div>
            <span className="font-sans text-xl font-bold text-ink-900">
              CopyWorx
            </span>
          </Link>

          {/* Desktop Navigation */}
          <div className="hidden md:flex md:items-center md:gap-8">
            {navLinks.map((link) => (
              <Link
                key={link.href}
                href={link.href}
                className={cn(
                  'text-sm font-medium transition-colors link-underline',
                  pathname === link.href
                    ? 'text-ink-900'
                    : 'text-ink-600 hover:text-ink-900'
                )}
              >
                {link.label}
              </Link>
            ))}
          </div>

          {/* Desktop Auth Section */}
          <div className="hidden md:flex md:items-center md:gap-4">
            {/* Show when user is NOT signed in */}
            <SignedOut>
              <Button variant="ghost" asChild>
                <Link href="/sign-in">Sign In</Link>
              </Button>
              <Button variant="amber" asChild>
                <Link href="/sign-up">Get Started</Link>
              </Button>
            </SignedOut>

            {/* Show when user IS signed in */}
            <SignedIn>
              <Button variant="ghost" asChild>
                <Link href="/worxspace">Worxspace</Link>
              </Button>
              <UserButton 
                afterSignOutUrl="/home"
                appearance={{
                  elements: {
                    avatarBox: 'h-9 w-9',
                    userButtonPopoverCard: 'shadow-xl border border-border/50',
                    userButtonPopoverActionButton: 'hover:bg-ink-50',
                    userButtonPopoverActionButtonText: 'text-ink-700',
                    userButtonPopoverActionButtonIcon: 'text-ink-500',
                    userButtonPopoverFooter: 'hidden',
                  },
                }}
              />
            </SignedIn>
          </div>

          {/* Mobile Menu Button */}
          <button
            type="button"
            className="md:hidden p-2 rounded-md text-ink-700 hover:bg-ink-100 transition-colors"
            onClick={() => setIsOpen(!isOpen)}
            aria-expanded={isOpen}
            aria-label={isOpen ? 'Close menu' : 'Open menu'}
          >
            {isOpen ? (
              <X className="h-6 w-6" />
            ) : (
              <Menu className="h-6 w-6" />
            )}
          </button>
        </div>

        {/* Mobile Menu */}
        <div
          className={cn(
            'md:hidden overflow-hidden transition-all duration-300 ease-in-out',
            isOpen ? 'max-h-96 opacity-100' : 'max-h-0 opacity-0'
          )}
        >
          <div className="py-4 space-y-4">
            {navLinks.map((link) => (
              <Link
                key={link.href}
                href={link.href}
                className={cn(
                  'block px-3 py-2 rounded-md text-base font-medium transition-colors',
                  pathname === link.href
                    ? 'bg-ink-100 text-ink-900'
                    : 'text-ink-600 hover:bg-ink-50 hover:text-ink-900'
                )}
              >
                {link.label}
              </Link>
            ))}
            
            {/* Mobile Auth Section */}
            <div className="pt-4 border-t border-border space-y-2">
              {/* Show when user is NOT signed in */}
              <SignedOut>
                <Button variant="outline" className="w-full" asChild>
                  <Link href="/sign-in">Sign In</Link>
                </Button>
                <Button variant="amber" className="w-full" asChild>
                  <Link href="/sign-up">Get Started</Link>
                </Button>
              </SignedOut>

              {/* Show when user IS signed in */}
              <SignedIn>
                <Button variant="outline" className="w-full" asChild>
                  <Link href="/worxspace">Worxspace</Link>
                </Button>
                <div className="flex items-center justify-center pt-2">
                  <UserButton 
                    afterSignOutUrl="/home"
                    appearance={{
                      elements: {
                        avatarBox: 'h-10 w-10',
                      },
                    }}
                  />
                </div>
              </SignedIn>
            </div>
          </div>
        </div>
      </nav>
    </header>
  );
}


=== FILE: components/layout/sidebar.tsx ===

/**
 * @file components/layout/sidebar.tsx
 * @description Sidebar navigation for the authenticated app area
 * 
 * Features:
 * - Collapsible sidebar
 * - Active state indicators
 * - Icon + text navigation
 */

'use client';

import * as React from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import {
  FileText,
  FolderOpen,
  Settings,
  HelpCircle,
  Feather,
  ChevronLeft,
  ChevronRight,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';

/**
 * Sidebar navigation items
 */
const navItems = [
  {
    href: '/templates',
    icon: FileText,
    label: 'Templates',
  },
  {
    href: '/projects',
    icon: FolderOpen,
    label: 'Projects',
  },
] as const;

/**
 * Bottom navigation items
 */
const bottomNavItems = [
  {
    href: '#settings',
    icon: Settings,
    label: 'Settings',
  },
  {
    href: '#help',
    icon: HelpCircle,
    label: 'Help & Support',
  },
] as const;

/**
 * Sidebar component
 * 
 * Collapsible sidebar for the authenticated app area.
 * Includes navigation links and user info.
 */
export function Sidebar() {
  const [isCollapsed, setIsCollapsed] = React.useState(false);
  const pathname = usePathname();

  return (
    <aside
      className={cn(
        'flex flex-col h-screen bg-ink-950 text-white border-r border-ink-800 transition-all duration-300',
        isCollapsed ? 'w-16' : 'w-64'
      )}
    >
      {/* Logo */}
      <div className="flex items-center h-16 px-4 border-b border-ink-800">
        <div className="flex items-center gap-2">
          <div className="flex h-8 w-8 items-center justify-center rounded-lg bg-amber-500 shadow-lg shrink-0">
            <Feather className="h-4 w-4 text-ink-900" />
          </div>
          {!isCollapsed && (
            <span className="font-sans text-lg font-bold text-white">
              CopyWorx
            </span>
          )}
        </div>
      </div>

      {/* Main Navigation */}
      <nav className="flex-1 py-4 px-2 space-y-1">
        {navItems.map((item) => {
          const isActive = pathname === item.href || pathname.startsWith(`${item.href}/`);
          
          return (
            <Link
              key={item.href}
              href={item.href}
              className={cn(
                'flex items-center gap-3 px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200',
                isActive
                  ? 'bg-amber-500/10 text-amber-400'
                  : 'text-ink-300 hover:bg-ink-800 hover:text-white',
                isCollapsed && 'justify-center'
              )}
              title={isCollapsed ? item.label : undefined}
            >
              <item.icon className={cn('h-5 w-5 shrink-0', isActive && 'text-amber-400')} />
              {!isCollapsed && <span>{item.label}</span>}
            </Link>
          );
        })}
      </nav>

      {/* Bottom Navigation */}
      <div className="py-4 px-2 border-t border-ink-800 space-y-1">
        {bottomNavItems.map((item) => (
          <Link
            key={item.label}
            href={item.href}
            className={cn(
              'flex items-center gap-3 px-3 py-2 rounded-lg text-sm font-medium text-ink-400 hover:bg-ink-800 hover:text-white transition-all duration-200',
              isCollapsed && 'justify-center'
            )}
            title={isCollapsed ? item.label : undefined}
          >
            <item.icon className="h-5 w-5 shrink-0" />
            {!isCollapsed && <span>{item.label}</span>}
          </Link>
        ))}
      </div>

      {/* Collapse Toggle */}
      <div className="p-2 border-t border-ink-800">
        <Button
          variant="ghost"
          size="sm"
          className={cn(
            'w-full justify-center text-ink-400 hover:text-white hover:bg-ink-800',
            isCollapsed && 'px-2'
          )}
          onClick={() => setIsCollapsed(!isCollapsed)}
          aria-label={isCollapsed ? 'Expand sidebar' : 'Collapse sidebar'}
        >
          {isCollapsed ? (
            <ChevronRight className="h-4 w-4" />
          ) : (
            <>
              <ChevronLeft className="h-4 w-4 mr-2" />
              <span>Collapse</span>
            </>
          )}
        </Button>
      </div>
    </aside>
  );
}



=== FILE: components/migration/index.ts ===

/**
 * @file components/migration/index.ts
 * @description Export migration components
 */

export { MigrationBanner } from './MigrationBanner';
export { default } from './MigrationBanner';


=== FILE: components/migration/MigrationBanner.tsx ===

/**
 * @file components/migration/MigrationBanner.tsx
 * @description Banner component prompting users to migrate localStorage data to Supabase cloud
 * 
 * Shows when:
 * - Supabase is configured
 * - User has localStorage data
 * - Migration hasn't been completed
 */

'use client';

import React, { useState, useEffect } from 'react';
import { Cloud, X, Loader2, CheckCircle, AlertCircle } from 'lucide-react';
import { 
  isCloudAvailable, 
  hasLocalDataToMigrate, 
  migrateLocalToCloud,
  isMigrationComplete 
} from '@/lib/storage/unified-storage';

type MigrationState = 'idle' | 'migrating' | 'success' | 'error';

interface MigrationBannerProps {
  /** Callback when migration completes */
  onMigrationComplete?: () => void;
  /** Callback when banner is dismissed */
  onDismiss?: () => void;
}

export function MigrationBanner({ onMigrationComplete, onDismiss }: MigrationBannerProps) {
  const [show, setShow] = useState(false);
  const [state, setState] = useState<MigrationState>('idle');
  const [result, setResult] = useState<{ migrated: number; errors: string[] } | null>(null);

  // Check if we should show the banner
  useEffect(() => {
    const checkMigration = () => {
      const shouldShow = 
        isCloudAvailable() && 
        hasLocalDataToMigrate() && 
        !isMigrationComplete();
      
      setShow(shouldShow);
    };

    // Delay check to allow other components to load
    const timer = setTimeout(checkMigration, 500);
    return () => clearTimeout(timer);
  }, []);

  // Handle migration
  const handleMigrate = async () => {
    setState('migrating');
    
    try {
      const migrationResult = await migrateLocalToCloud();
      setResult({
        migrated: migrationResult.migrated,
        errors: migrationResult.errors,
      });

      if (migrationResult.success) {
        setState('success');
        // Auto-dismiss after success
        setTimeout(() => {
          setShow(false);
          onMigrationComplete?.();
        }, 3000);
      } else if (migrationResult.migrated > 0) {
        // Partial success
        setState('success');
        setTimeout(() => {
          setShow(false);
          onMigrationComplete?.();
        }, 5000);
      } else {
        setState('error');
      }
    } catch (error) {
      setState('error');
      setResult({
        migrated: 0,
        errors: [error instanceof Error ? error.message : 'Unknown error'],
      });
    }
  };

  // Handle dismiss
  const handleDismiss = () => {
    setShow(false);
    onDismiss?.();
  };

  // Don't render if not showing
  if (!show) return null;

  return (
    <div className="fixed bottom-4 right-4 z-50 max-w-md animate-in slide-in-from-bottom-4 duration-300">
      <div className="bg-gradient-to-r from-blue-600 to-indigo-600 text-white rounded-lg shadow-lg p-4">
        <div className="flex items-start gap-3">
          {/* Icon */}
          <div className="flex-shrink-0 mt-0.5">
            {state === 'idle' && <Cloud className="w-5 h-5" />}
            {state === 'migrating' && <Loader2 className="w-5 h-5 animate-spin" />}
            {state === 'success' && <CheckCircle className="w-5 h-5 text-green-300" />}
            {state === 'error' && <AlertCircle className="w-5 h-5 text-red-300" />}
          </div>

          {/* Content */}
          <div className="flex-1 min-w-0">
            {state === 'idle' && (
              <>
                <p className="font-medium text-sm">
                  Enable Cloud Sync
                </p>
                <p className="text-xs text-blue-100 mt-1">
                  Migrate your data to the cloud to access it from any device.
                </p>
                <div className="flex gap-2 mt-3">
                  <button
                    onClick={handleMigrate}
                    className="px-3 py-1.5 bg-white text-blue-600 rounded-md text-xs font-medium 
                             hover:bg-blue-50 transition-colors"
                  >
                    Migrate Now
                  </button>
                  <button
                    onClick={handleDismiss}
                    className="px-3 py-1.5 bg-blue-500/30 text-white rounded-md text-xs font-medium 
                             hover:bg-blue-500/50 transition-colors"
                  >
                    Later
                  </button>
                </div>
              </>
            )}

            {state === 'migrating' && (
              <>
                <p className="font-medium text-sm">
                  Migrating your data...
                </p>
                <p className="text-xs text-blue-100 mt-1">
                  Please wait while we sync your projects to the cloud.
                </p>
              </>
            )}

            {state === 'success' && (
              <>
                <p className="font-medium text-sm">
                  Migration Complete!
                </p>
                <p className="text-xs text-blue-100 mt-1">
                  {result?.migrated || 0} project(s) synced to the cloud.
                  {result?.errors && result.errors.length > 0 && (
                    <span className="text-yellow-200">
                      {' '}({result.errors.length} warning(s))
                    </span>
                  )}
                </p>
              </>
            )}

            {state === 'error' && (
              <>
                <p className="font-medium text-sm">
                  Migration Failed
                </p>
                <p className="text-xs text-red-200 mt-1">
                  {result?.errors?.[0] || 'An error occurred during migration.'}
                </p>
                <button
                  onClick={handleMigrate}
                  className="mt-2 px-3 py-1.5 bg-white text-red-600 rounded-md text-xs font-medium 
                           hover:bg-red-50 transition-colors"
                >
                  Retry
                </button>
              </>
            )}
          </div>

          {/* Dismiss button */}
          {state !== 'migrating' && (
            <button
              onClick={handleDismiss}
              className="flex-shrink-0 text-blue-200 hover:text-white transition-colors"
              aria-label="Dismiss"
            >
              <X className="w-4 h-4" />
            </button>
          )}
        </div>
      </div>
    </div>
  );
}

export default MigrationBanner;


=== FILE: components/ProductTour.tsx ===

/**
 * @file components/ProductTour.tsx
 * @description Interactive product tour for CopyWorx using React Joyride
 * 
 * Features:
 * - Guides new users through key features
 * - Shows on first visit only (localStorage flag)
 * - Can be skipped at any time
 * - Can be restarted from help menu
 * - Uses CopyWorx branding (#006EE6 blue, #7A3991 purple)
 * - Takes 60-90 seconds to complete
 */

'use client';

import { useState, useCallback } from 'react';
import Joyride, { CallBackProps, STATUS, Step, ACTIONS, EVENTS } from 'react-joyride';
import { logger } from '@/lib/utils/logger';

/**
 * Props for ProductTour component
 */
interface ProductTourProps {
  /** Whether the tour should be running */
  run: boolean;
  /** Callback when tour is completed or skipped */
  onComplete: () => void;
}

/**
 * Tour steps configuration
 * Each step highlights a key feature of CopyWorx
 */
const tourSteps: Step[] = [
  {
    target: 'body',
    content: (
      <div>
        <h2 className="text-2xl font-bold text-[#006EE6] mb-3">Welcome to CopyWorx‚Ñ¢ Studio!</h2>
        <p className="text-base mb-3">Let&apos;s take a quick 60-second tour to show you the key features.</p>
        <p className="text-sm text-gray-600">You can skip this tour anytime by clicking &quot;Skip&quot; or pressing ESC.</p>
      </div>
    ),
    placement: 'center',
    disableBeacon: true,
  },
  {
    target: '[data-tour="projects"]',
    content: (
      <div>
        <h3 className="text-xl font-bold text-[#006EE6] mb-2">My Projects</h3>
        <p className="text-base">Organize your work by project, client or campaign. Keep everything structured and easy to find.</p>
      </div>
    ),
    placement: 'right',
    disableBeacon: true,
  },
  {
    target: '[data-tour="brand-voice"]',
    content: (
      <div>
        <h3 className="text-xl font-bold text-[#006EE6] mb-2">Brand Voice &amp; Personas</h3>
        <p className="text-base mb-2">This is your strategic foundation. Set up your Brand Voice first, then a Persona or two ‚Äî they ensure every piece of copy maintains consistency.</p>
        <p className="text-sm text-gray-600 italic">Pro tip: Spend 10 minutes here before writing anything!</p>
      </div>
    ),
    placement: 'right',
    disableBeacon: true,
  },
  {
    target: '[data-tour="templates"]',
    content: (
      <div>
        <h3 className="text-xl font-bold text-[#006EE6] mb-2">AI@Worx‚Ñ¢ Templates</h3>
        <p className="text-base">Professional copywriting templates across 6 categories. Generate strategic copy in minutes, not hours.</p>
      </div>
    ),
    placement: 'right',
    disableBeacon: true,
  },
  {
    target: '[data-tour="copy-optimizer"]',
    content: (
      <div>
        <h3 className="text-xl font-bold text-[#006EE6] mb-2">Copy Optimizer Suite</h3>
        <p className="text-base mb-2">Transform your copy with:</p>
        <ul className="text-sm list-disc list-inside space-y-1">
          <li>Tone Shifter (6 professional tones)</li>
          <li>Expand or Shorten</li>
          <li>Rewrite for Channel (email, social, ads)</li>
        </ul>
      </div>
    ),
    placement: 'right',
    disableBeacon: true,
  },
  {
    target: '[data-tour="insights"]',
    content: (
      <div>
        <h3 className="text-xl font-bold text-[#006EE6] mb-2">My Insights</h3>
        <p className="text-base mb-2">Write smarter with AI-powered insights:</p>
        <ul className="text-sm list-disc list-inside space-y-1">
          <li>Alignment scores</li>
          <li>Copy strengths</li>
          <li>Areas to improve</li>
          <li>Recommendations</li>
        </ul>
      </div>
    ),
    placement: 'right',
    disableBeacon: true,
  },
  {
    target: '[data-tour="snippets"]',
    content: (
      <div>
        <h3 className="text-xl font-bold text-[#006EE6] mb-2">Snippets</h3>
        <p className="text-base mb-2">Save and reuse copy easily:</p>
        <ul className="text-sm list-disc list-inside space-y-1">
          <li>Taglines</li>
          <li>CTAs</li>
          <li>Copyright info</li>
          <li>Boilerplate</li>
        </ul>
      </div>
    ),
    placement: 'bottom',
    disableBeacon: true,
  },
  {
    target: '[data-tour="editor"]',
    content: (
      <div>
        <h3 className="text-xl font-bold text-[#006EE6] mb-2">Your Writing Canvas</h3>
        <p className="text-base">Clean, distraction-free editor with professional formatting tools. This is where the magic happens.</p>
      </div>
    ),
    placement: 'center',
    disableBeacon: true,
  },
  {
    target: '[data-tour="toolbox"]',
    content: (
      <div>
        <h3 className="text-xl font-bold text-[#006EE6] mb-2">AI@Worx‚Ñ¢ Toolbox</h3>
        <p className="text-base">Your AI assistant panel. It dynamically changes based on which tool you select.</p>
      </div>
    ),
    placement: 'left',
    disableBeacon: true,
  },
  {
    target: 'body',
    content: (
      <div>
        <h2 className="text-2xl font-bold text-[#7A3991] mb-3">You&apos;re Ready to Write to Win!</h2>
        <p className="text-base mb-3">Start by setting up your Brand Voice and Personas, or jump straight into a template.</p>
        <p className="text-base font-semibold text-[#006EE6]">Now get to worx with CopyWorx‚Ñ¢ Studio!</p>
      </div>
    ),
    placement: 'center',
    disableBeacon: true,
  },
];

/**
 * Custom styles for the tour tooltip
 * Uses CopyWorx branding colors
 */
const tourStyles = {
  options: {
    primaryColor: '#006EE6',
    zIndex: 10000,
    arrowColor: '#fff',
    backgroundColor: '#fff',
    textColor: '#333',
    overlayColor: 'rgba(0, 0, 0, 0.5)',
  },
  buttonNext: {
    backgroundColor: '#006EE6',
    borderRadius: '6px',
    fontSize: '14px',
    padding: '10px 20px',
  },
  buttonBack: {
    color: '#666',
    marginRight: '10px',
  },
  buttonSkip: {
    color: '#999',
    fontSize: '13px',
  },
  buttonClose: {
    color: '#999',
    padding: '8px',
  },
  tooltip: {
    borderRadius: '12px',
    padding: '20px',
    fontSize: '16px',
  },
  tooltipContainer: {
    textAlign: 'left' as const,
  },
  spotlight: {
    borderRadius: '8px',
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    border: '3px solid #006EE6',
  },
  overlay: {
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  beacon: {
    display: 'none',
  },
};

/**
 * Locale strings for tour buttons
 */
const tourLocale = {
  back: 'Back',
  close: 'Close',
  last: 'Finish',
  next: 'Next',
  skip: 'Skip Tour',
};

/**
 * ProductTour component
 * Renders the Joyride tour with CopyWorx branding and content
 */
export default function ProductTour({ run, onComplete }: ProductTourProps) {
  const [stepIndex, setStepIndex] = useState(0);

  /**
   * Handle Joyride callback events
   * Manages step navigation and completion
   */
  const handleJoyrideCallback = useCallback((data: CallBackProps) => {
    const { status, action, index, type } = data;
    
    // Log for debugging
    logger.log('Tour callback:', { status, action, index, type });

    // Handle tour completion or skip
    if (status === STATUS.FINISHED || status === STATUS.SKIPPED) {
      onComplete();
      setStepIndex(0);
      return;
    }

    // Handle step navigation
    if (type === EVENTS.STEP_AFTER) {
      if (action === ACTIONS.NEXT) {
        setStepIndex(index + 1);
      } else if (action === ACTIONS.PREV) {
        setStepIndex(index - 1);
      }
    }

    // Handle close button click
    if (action === ACTIONS.CLOSE) {
      onComplete();
      setStepIndex(0);
    }
  }, [onComplete]);

  return (
    <Joyride
      steps={tourSteps}
      run={run}
      continuous
      showProgress
      showSkipButton
      stepIndex={stepIndex}
      callback={handleJoyrideCallback}
      styles={tourStyles}
      locale={tourLocale}
      scrollToFirstStep
      disableOverlayClose
      spotlightClicks
      floaterProps={{
        disableAnimation: false,
        styles: {
          floater: {
            transition: 'all 0.3s ease',
          },
        },
      }}
    />
  );
}


=== FILE: components/splash/index.ts ===

/**
 * @file components/splash/index.ts
 * @description Barrel export for splash page components
 */

export { SplashPage } from './SplashPage';





=== FILE: components/splash/SplashPage.tsx ===

/**
 * @file components/splash/SplashPage.tsx
 * @description Entry splash page for CopyWorx v2
 * 
 * Features:
 * - Centered CopyWorx Studio logo
 * - Subtitle: "AI-Powered Writing Suite"
 * - Four action buttons in a row
 * - Apple-style aesthetic with blue accent
 * - Responsive (stacks on mobile)
 * - Footer with copyright
 * 
 * @example
 * ```tsx
 * <SplashPage />
 * ```
 */

'use client';

import React, { useState, useRef, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import Image from 'next/image';
import {
  FilePlus,
  Sparkles,
  Upload,
  Rocket,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { useWorkspaceStore, useActiveProjectId } from '@/lib/stores/workspaceStore';
import { createDocument } from '@/lib/storage/unified-storage';
import { TemplatesModal } from '@/components/workspace/TemplatesModal';
import { getTemplateById } from '@/lib/data/templates';
import { markDailyVisitComplete, markSplashViewed } from '@/lib/utils/daily-visit-tracker';
import { logger } from '@/lib/utils/logger';

interface ActionButtonProps {
  icon: React.ReactNode;
  label: string;
  description: string;
  onClick: () => void;
}

/**
 * Action button for splash page with full text
 */
function ActionButton({ icon, label, description, onClick }: ActionButtonProps) {
  return (
    <button
      onClick={onClick}
      className={cn(
        'group',
        'flex flex-col items-center justify-center',
        'w-32 h-32',
        'bg-apple-blue hover:bg-[#7A3991]',
        'text-white',
        'rounded-xl',
        'shadow-md hover:shadow-xl',
        'transition-all duration-300',
        'transform hover:-translate-y-1',
        'focus:outline-none focus:ring-2 focus:ring-apple-blue/30 focus:ring-offset-2'
      )}
    >
      {/* Icon */}
      <div className="mb-2 transform group-hover:scale-110 transition-transform duration-300">
        {icon}
      </div>

      {/* Label */}
      <div className="text-sm font-semibold mb-1">
        {label}
      </div>

      {/* Description */}
      <div className="text-xs opacity-90 px-2 text-center leading-tight">
        {description}
      </div>
    </button>
  );
}

/**
 * Splash page component with action buttons
 */
export function SplashPage() {
  const router = useRouter();
  const activeProjectId = useActiveProjectId();
  
  // Templates modal state
  const [templatesModalOpen, setTemplatesModalOpen] = useState(false);
  
  // File input ref for importing documents
  const fileInputRef = useRef<HTMLInputElement>(null);

  // Mark splash as viewed when page loads (prevents redirect loops)
  useEffect(() => {
    markSplashViewed();
  }, []);

  const handleNewDocument = async () => {
    // Mark daily visit as complete before navigating
    markDailyVisitComplete();
    if (!activeProjectId) {
      logger.warn('‚ö†Ô∏è No active project, going to workspace anyway');
      router.push('/worxspace?action=new');
      return;
    }
    
    try {
      // Create document in localStorage via document-storage
      const newDoc = await createDocument(activeProjectId, 'Untitled Document');
      
      // Set active document ID in Zustand
      useWorkspaceStore.getState().setActiveDocumentId(newDoc.id);
      
      logger.log('‚úÖ Created new document:', newDoc.id);
      router.push('/worxspace?action=new');
    } catch (error) {
      logger.error('‚ùå Failed to create document:', error);
      // Still navigate to workspace
      router.push('/worxspace?action=new');
    }
  };

  const handleAITemplate = () => {
    // Mark daily visit as complete before showing modal
    markDailyVisitComplete();
    logger.log('üé® Opening Templates Modal from Splash Page');
    setTemplatesModalOpen(true);
  };

  /**
   * Handle template selection from modal
   * Creates document immediately and navigates to workspace
   */
  const handleTemplateSelect = async (templateId: string) => {
    // Mark daily visit as complete before navigating
    markDailyVisitComplete();
    
    logger.log('üé® Template selected from splash page:', templateId);
    
    // Get template details to use its name for the document
    const template = getTemplateById(templateId);
    if (!template) {
      logger.error('‚ùå Template not found:', templateId);
      return;
    }
    
    // Check for active project
    if (!activeProjectId) {
      logger.warn('‚ö†Ô∏è No active project, cannot create document');
      router.push('/worxspace?template=' + templateId);
      return;
    }
    
    try {
      // Create document immediately with template name
      const newDoc = await createDocument(activeProjectId, template.name);
      logger.log('‚úÖ Created document for template:', newDoc.id, newDoc.title);
      
      // Set as active document in store
      useWorkspaceStore.getState().setActiveDocumentId(newDoc.id);
      
      // Navigate to workspace with both template and document IDs
      router.push(`/worxspace?template=${templateId}&document=${newDoc.id}`);
    } catch (error) {
      logger.error('‚ùå Failed to create document for template:', error);
      // Still navigate to workspace with just template ID
      router.push('/worxspace?template=' + templateId);
    }
  };

  /**
   * Handle import button click - opens file picker
   */
  const handleImport = () => {
    // Mark daily visit as complete before opening file picker
    markDailyVisitComplete();
    
    // Set accept attribute to allow common document formats
    if (fileInputRef.current) {
      fileInputRef.current.accept = '.docx,.txt,.md';
    }
    
    // Trigger the hidden file input
    fileInputRef.current?.click();
  };

  /**
   * Handle direct navigation to workspace
   */
  const handleGoToWorxspace = () => {
    // Mark daily visit as complete before navigating
    markDailyVisitComplete();
    logger.log('üöÄ Navigating directly to Worxspace');
    router.push('/worxspace');
  };

  /**
   * Handle file selection for import
   * Creates document and navigates to workspace with file stored temporarily
   */
  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !activeProjectId) {
      logger.warn('‚ö†Ô∏è No file selected or no active project');
      return;
    }

    try {
      // Extract filename without extension for document title
      const fileName = file.name;
      const lastDotIndex = fileName.lastIndexOf('.');
      const documentTitle = lastDotIndex === -1 
        ? fileName 
        : fileName.substring(0, lastDotIndex);

      // Create a new document for the import
      const newDoc = await createDocument(activeProjectId, documentTitle);
      logger.log('‚úÖ Created document for import:', newDoc.id, newDoc.title);

      // Set as active document
      useWorkspaceStore.getState().setActiveDocumentId(newDoc.id);

      // Store file data in localStorage temporarily
      // We'll read it as ArrayBuffer for binary files (docx) or text for txt/md
      const reader = new FileReader();
      
      reader.onload = async (e) => {
        try {
          const result = e.target?.result;
          
          // Store file metadata and content
          localStorage.setItem('pendingFileImport', JSON.stringify({
            documentId: newDoc.id,
            fileName: file.name,
            fileType: file.type,
            timestamp: Date.now()
          }));

          // Store the actual file content separately
          // For text files, store as text; for binary (docx), store as base64
          if (file.name.endsWith('.docx')) {
            // Convert ArrayBuffer to base64
            const base64 = btoa(
              new Uint8Array(result as ArrayBuffer)
                .reduce((data, byte) => data + String.fromCharCode(byte), '')
            );
            localStorage.setItem('pendingFileContent', base64);
          } else {
            // Store text directly
            localStorage.setItem('pendingFileContent', result as string);
          }

          // Navigate to workspace
          router.push(`/worxspace?document=${newDoc.id}&import=true`);
        } catch (error) {
          logger.error('‚ùå Failed to store file:', error);
          // Navigate anyway, document is created
          router.push(`/worxspace?document=${newDoc.id}`);
        }
      };

      reader.onerror = () => {
        logger.error('‚ùå Failed to read file');
        // Still navigate, workspace can handle empty document
        router.push(`/workspace?document=${newDoc.id}`);
      };

      // Read file appropriately based on type
      if (file.name.endsWith('.docx')) {
        reader.readAsArrayBuffer(file);
      } else {
        reader.readAsText(file);
      }

      // Clear the file input for next use
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    } catch (error) {
      logger.error('‚ùå Failed to handle file import:', error);
    }
  };

  return (
    <div className="min-h-screen w-full bg-apple-gray-bg flex flex-col">
      {/* Main content */}
      <div className="flex-1 flex flex-col items-center justify-center px-8 py-16">
        {/* Logo & Subtitle */}
        <div className="text-center mb-12 animate-fade-in">
          {/* CopyWorx Studio Logo */}
          <div className="mb-6 flex justify-center">
            <Image
              src="/copyworx-studio-logo.png"
              alt="CopyWorx Studio"
              width={256}
              height={256}
              className="object-contain"
              priority
              unoptimized
            />
          </div>

          {/* Subtitle */}
          <p className="text-xl sm:text-2xl text-[#58595b] font-medium">
            AI-Powered Writing Suite
          </p>
        </div>

        {/* Action buttons */}
        <div
          className={cn(
            'flex flex-row items-center justify-center',
            'gap-6',
            'animate-fade-in-up'
          )}
        >
          <ActionButton
            icon={<FilePlus className="w-8 h-8" strokeWidth={1.5} />}
            label="New"
            description="Start fresh project"
            onClick={handleNewDocument}
          />

          <ActionButton
            icon={<Sparkles className="w-8 h-8" strokeWidth={1.5} />}
            label="AI@Worx‚Ñ¢"
            description="Start from AI template"
            onClick={handleAITemplate}
          />

          <ActionButton
            icon={<Upload className="w-8 h-8" strokeWidth={1.5} />}
            label="Import"
            description="Open text file"
            onClick={handleImport}
          />

          <ActionButton
            icon={<Rocket className="w-8 h-8" strokeWidth={1.5} />}
            label="Worxspace"
            description="Take me to my Worxspace"
            onClick={handleGoToWorxspace}
          />
        </div>

        {/* Quick access hint */}
        <div className="mt-16 text-center text-sm text-gray-500 animate-fade-in animation-delay-300">
          <p>
            Press <kbd className="px-2 py-1 bg-white border border-gray-300 rounded shadow-sm font-mono text-xs">‚åò</kbd> +{' '}
            <kbd className="px-2 py-1 bg-white border border-gray-300 rounded shadow-sm font-mono text-xs">N</kbd>{' '}
            for new document
          </p>
        </div>
      </div>

      {/* Footer */}
      <footer className="py-8 text-center text-sm text-gray-500 border-t border-gray-200">
        <p>
          ¬© 2026 CopyWorx‚Ñ¢ Studio LLC. All rights reserved.
        </p>
        <p className="mt-1">
          CopyWorx‚Ñ¢ and AI@Worx‚Ñ¢ are trademarks of CopyWorx‚Ñ¢ Studio LLC.
        </p>
      </footer>

      {/* Templates Modal */}
      <TemplatesModal
        isOpen={templatesModalOpen}
        onClose={() => setTemplatesModalOpen(false)}
        onTemplateSelect={handleTemplateSelect}
      />

      {/* Hidden file input for importing documents */}
      <input
        ref={fileInputRef}
        type="file"
        accept=".docx,.txt,.md"
        className="hidden"
        onChange={handleFileSelect}
      />
    </div>
  );
}



=== FILE: components/ui/AIWorxLoader.tsx ===

/**
 * @file components/ui/AIWorxLoader.tsx
 * @description Branded loading components for AI generation processes
 * 
 * Features:
 * - Shimmer animation on Sparkles icon
 * - Spinning outer ring
 * - Bouncing dots with staggered timing
 * - Consistent AI@Worx‚Ñ¢ branding
 * - Button and full-width variants
 * 
 * Design:
 * - Apple blue color palette
 * - Smooth 60fps animations
 * - Accessible (aria-live regions)
 * 
 * @example
 * ```tsx
 * // Full-width loader
 * <AIWorxLoader message="Generating with AI@Worx‚Ñ¢..." />
 * 
 * // Button loader
 * <AIWorxButtonLoader />
 * ```
 */

'use client';

import React from 'react';
import { Sparkles } from 'lucide-react';

interface AIWorxLoaderProps {
  /** Custom loading message */
  message?: string;
}

/**
 * Full-width branded loader for AI generation processes
 * Use in tool panels when waiting for API responses
 */
export function AIWorxLoader({ 
  message = "Generating with AI@Worx‚Ñ¢..." 
}: AIWorxLoaderProps) {
  return (
    <div 
      className="flex items-center justify-center gap-3 py-8"
      role="status"
      aria-live="polite"
      aria-label={message}
    >
      {/* Animated Sparkles Icon with Shimmer and Spinning Ring */}
      <div className="relative">
        {/* Sparkles icon with shimmer effect */}
        <Sparkles 
          className="w-6 h-6 text-white animate-shimmer" 
          fill="currentColor"
          aria-hidden="true"
        />
        
        {/* Spinning outer ring */}
        <div className="absolute inset-0 -m-2" aria-hidden="true">
          <div className="w-10 h-10 border-2 border-white/30 border-t-white rounded-full animate-spin" />
        </div>
      </div>
      
      {/* Loading Message */}
      <div className="flex items-center gap-1">
        <span className="text-white font-medium">
          {message}
        </span>
        
        {/* Animated bouncing dots */}
        <span className="flex gap-1" aria-hidden="true">
          <span 
            className="w-1 h-1 bg-white rounded-full animate-bounce" 
            style={{ animationDelay: '0ms' }} 
          />
          <span 
            className="w-1 h-1 bg-white rounded-full animate-bounce" 
            style={{ animationDelay: '150ms' }} 
          />
          <span 
            className="w-1 h-1 bg-white rounded-full animate-bounce" 
            style={{ animationDelay: '300ms' }} 
          />
        </span>
      </div>
    </div>
  );
}

/**
 * Inline button loader for AI generation processes
 * Use inside buttons when user triggers AI operations
 */
export function AIWorxButtonLoader() {
  return (
    <div 
      className="flex items-center gap-2"
      role="status"
      aria-live="polite"
      aria-label="Generating with AI@Worx‚Ñ¢"
    >
      {/* Sparkles icon with shimmer */}
      <Sparkles 
        className="w-4 h-4 animate-shimmer" 
        fill="currentColor"
        aria-hidden="true"
      />
      
      {/* Text */}
      <span>Generating with AI@Worx‚Ñ¢</span>
      
      {/* Animated bouncing dots */}
      <span className="flex gap-0.5" aria-hidden="true">
        <span 
          className="w-1 h-1 bg-current rounded-full animate-bounce" 
          style={{ animationDelay: '0ms' }} 
        />
        <span 
          className="w-1 h-1 bg-current rounded-full animate-bounce" 
          style={{ animationDelay: '150ms' }} 
        />
        <span 
          className="w-1 h-1 bg-current rounded-full animate-bounce" 
          style={{ animationDelay: '300ms' }} 
        />
      </span>
    </div>
  );
}


=== FILE: components/ui/AutoExpandTextarea.tsx ===

/**
 * @file components/ui/AutoExpandTextarea.tsx
 * @description Auto-expanding textarea component that adjusts height based on content
 * 
 * Features:
 * - Automatically expands as user types
 * - Shrinks when content is deleted
 * - Respects min/max height constraints
 * - Smooth transitions
 * - Works with controlled components
 * 
 * @example
 * ```tsx
 * <AutoExpandTextarea
 *   value={text}
 *   onChange={(e) => setText(e.target.value)}
 *   minHeight={80}
 *   maxHeight={400}
 *   placeholder="Enter text..."
 * />
 * ```
 */

'use client';

import React, { useEffect, useRef } from 'react';
import { cn } from '@/lib/utils';

interface AutoExpandTextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  /** Minimum height in pixels (default: 80) */
  minHeight?: number;
  
  /** Maximum height before scrolling kicks in (default: 400) */
  maxHeight?: number;
}

/**
 * AutoExpandTextarea component - Textarea that grows/shrinks with content
 */
export function AutoExpandTextarea({ 
  minHeight = 80,
  maxHeight = 400,
  className,
  value,
  onChange,
  ...props 
}: AutoExpandTextareaProps) {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  
  /**
   * Adjust textarea height based on content
   */
  const adjustHeight = React.useCallback(() => {
    const textarea = textareaRef.current;
    if (!textarea) return;
    
    // Reset height to minHeight to get accurate scrollHeight
    textarea.style.height = `${minHeight}px`;
    
    // Calculate new height based on content
    const scrollHeight = textarea.scrollHeight;
    const newHeight = Math.min(Math.max(scrollHeight, minHeight), maxHeight);
    
    // Set new height
    textarea.style.height = `${newHeight}px`;
    
    // Enable/disable overflow based on whether we've hit maxHeight
    if (scrollHeight > maxHeight) {
      textarea.style.overflowY = 'auto';
    } else {
      textarea.style.overflowY = 'hidden';
    }
  }, [minHeight, maxHeight]);
  
  /**
   * Adjust height on mount and when value changes
   */
  useEffect(() => {
    adjustHeight();
  }, [value, adjustHeight]);
  
  /**
   * Also adjust on window resize
   */
  useEffect(() => {
    const handleResize = () => adjustHeight();
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [adjustHeight]);
  
  /**
   * Handle change event and adjust height
   */
  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    if (onChange) {
      onChange(e);
    }
    // Adjust height immediately
    requestAnimationFrame(() => adjustHeight());
  };
  
  return (
    <textarea
      ref={textareaRef}
      value={value}
      onChange={handleChange}
      className={cn(
        'resize-none transition-[height] duration-150 ease-out',
        'overflow-x-hidden', // Prevent horizontal scrolling
        'whitespace-pre-wrap', // Wrap text properly
        'break-words', // Break long words
        className
      )}
      style={{ 
        minHeight: `${minHeight}px`,
        maxHeight: `${maxHeight}px`,
        height: `${minHeight}px`, // Set initial height
      }}
      {...props}
    />
  );
}


=== FILE: components/ui/badge.tsx ===

/**
 * @file components/ui/badge.tsx
 * @description Badge component for labels and status indicators
 */

import * as React from 'react';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

const badgeVariants = cva(
  'inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2',
  {
    variants: {
      variant: {
        default:
          'border-transparent bg-primary text-primary-foreground hover:bg-primary/80',
        secondary:
          'border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80',
        destructive:
          'border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80',
        outline: 'text-foreground',
        amber:
          'border-transparent bg-amber-100 text-amber-800 hover:bg-amber-200',
        ink:
          'border-transparent bg-ink-100 text-ink-800 hover:bg-ink-200',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  }
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

/**
 * Badge component for displaying labels and status
 * 
 * @example
 * <Badge variant="amber">New</Badge>
 */
function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };



=== FILE: components/ui/button.tsx ===

/**
 * @file components/ui/button.tsx
 * @description Button component with multiple variants using class-variance-authority
 * Based on shadcn/ui button with CopyWorx customizations
 */

import * as React from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';

/**
 * Button variants configuration
 * Defines all visual styles for the button component
 */
const buttonVariants = cva(
  'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-all duration-200 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
  {
    variants: {
      variant: {
        default:
          'bg-primary text-primary-foreground hover:bg-primary/90 active:scale-[0.98]',
        destructive:
          'bg-destructive text-destructive-foreground hover:bg-destructive/90 active:scale-[0.98]',
        outline:
          'border border-input bg-background hover:bg-accent hover:text-accent-foreground active:scale-[0.98]',
        secondary:
          'bg-secondary text-secondary-foreground hover:bg-secondary/80 active:scale-[0.98]',
        ghost: 
          'hover:bg-accent hover:text-accent-foreground',
        link: 
          'text-primary underline-offset-4 hover:underline',
        amber:
          'bg-amber-500 text-ink-900 hover:bg-amber-400 active:scale-[0.98] shadow-lg hover:shadow-xl glow-amber',
        ink:
          'bg-ink-900 text-white hover:bg-ink-800 active:scale-[0.98] shadow-lg hover:shadow-xl',
        brand:
          'bg-[#006EE6] text-white hover:bg-[#0062CC] active:bg-[#7A3991] active:scale-[0.98] shadow-sm hover:shadow transition-all duration-200',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8 text-base',
        xl: 'h-14 rounded-lg px-10 text-lg',
        icon: 'h-10 w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
);

/**
 * Button component props
 */
export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  /** Render as a Slot component for composition */
  asChild?: boolean;
  /** Loading state */
  isLoading?: boolean;
}

/**
 * Button component
 * 
 * A versatile button component with multiple variants and sizes.
 * Supports loading state and can be composed with other components using asChild.
 * 
 * @example
 * <Button variant="amber" size="lg">Get Started</Button>
 */
const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, isLoading = false, children, disabled, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button';
    
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        disabled={disabled || isLoading}
        {...props}
      >
        {isLoading ? (
          <>
            <svg
              className="mr-2 h-4 w-4 animate-spin"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
            >
              <circle
                className="opacity-25"
                cx="12"
                cy="12"
                r="10"
                stroke="currentColor"
                strokeWidth="4"
              />
              <path
                className="opacity-75"
                fill="currentColor"
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              />
            </svg>
            Loading...
          </>
        ) : (
          children
        )}
      </Comp>
    );
  }
);
Button.displayName = 'Button';

export { Button, buttonVariants };



=== FILE: components/ui/card.tsx ===

/**
 * @file components/ui/card.tsx
 * @description Card component with header, content, and footer sections
 * Based on shadcn/ui card with CopyWorx styling
 */

import * as React from 'react';
import { cn } from '@/lib/utils';

/**
 * Card container component
 */
const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      'rounded-xl border bg-card text-card-foreground shadow-sm transition-all duration-300',
      className
    )}
    {...props}
  />
));
Card.displayName = 'Card';

/**
 * Card header section
 */
const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex flex-col space-y-1.5 p-6', className)}
    {...props}
  />
));
CardHeader.displayName = 'CardHeader';

/**
 * Card title element
 */
const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      'text-2xl font-semibold leading-none tracking-tight font-sans',
      className
    )}
    {...props}
  />
));
CardTitle.displayName = 'CardTitle';

/**
 * Card description element
 */
const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
CardDescription.displayName = 'CardDescription';

/**
 * Card content section
 */
const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
));
CardContent.displayName = 'CardContent';

/**
 * Card footer section
 */
const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex items-center p-6 pt-0', className)}
    {...props}
  />
));
CardFooter.displayName = 'CardFooter';

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent };



=== FILE: components/ui/ConfirmationModal.tsx ===

/**
 * @file components/ui/ConfirmationModal.tsx
 * @description Reusable confirmation modal for destructive actions
 * 
 * Features:
 * - Clear warning message
 * - Customizable title and content
 * - Destructive action styling (red button)
 * - ESC key to cancel, click outside to cancel
 * - Loading state support
 * 
 * @example
 * ```tsx
 * <ConfirmationModal
 *   isOpen={showModal}
 *   title="Delete Item"
 *   message="Delete 'Item Name'?"
 *   description="This will permanently remove this item. This cannot be undone."
 *   confirmLabel="Delete Item"
 *   onClose={() => setShowModal(false)}
 *   onConfirm={() => handleDelete()}
 *   isConfirming={isDeleting}
 * />
 * ```
 */

'use client';

import React, { useEffect, useState, useCallback } from 'react';
import { createPortal } from 'react-dom';
import { AlertTriangle, X, Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';

// ============================================================================
// Types
// ============================================================================

export interface ConfirmationModalProps {
  /** Whether the modal is open */
  isOpen: boolean;
  /** Modal title */
  title: string;
  /** Main message (can include item name) */
  message: string;
  /** Additional description/warning */
  description?: string;
  /** Label for confirm button */
  confirmLabel?: string;
  /** Label for cancel button */
  cancelLabel?: string;
  /** Callback when modal should close (cancel) */
  onClose: () => void;
  /** Callback when action is confirmed */
  onConfirm: () => void;
  /** Whether confirmation action is in progress */
  isConfirming?: boolean;
  /** Icon to show (defaults to AlertTriangle) */
  icon?: React.ReactNode;
  /** Whether this is a destructive action (red button) */
  isDestructive?: boolean;
}

// ============================================================================
// Component
// ============================================================================

/**
 * ConfirmationModal - Reusable confirmation dialog for important actions
 * 
 * Shows a clear warning with customizable message.
 * Uses portal to render above all other content.
 */
export function ConfirmationModal({
  isOpen,
  title,
  message,
  description,
  confirmLabel = 'Confirm',
  cancelLabel = 'Cancel',
  onClose,
  onConfirm,
  isConfirming = false,
  icon,
  isDestructive = true,
}: ConfirmationModalProps) {
  const [isMounted, setIsMounted] = useState(false);
  
  // Handle mount state for SSR compatibility
  useEffect(() => {
    setIsMounted(true);
  }, []);
  
  // Handle ESC key to close
  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (e.key === 'Escape' && isOpen && !isConfirming) {
      onClose();
    }
  }, [isOpen, isConfirming, onClose]);
  
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);
  
  // Prevent body scroll when modal is open
  useEffect(() => {
    if (isOpen) {
      const originalOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
      return () => {
        document.body.style.overflow = originalOverflow;
      };
    }
  }, [isOpen]);
  
  // Handle backdrop click
  const handleBackdropClick = useCallback((e: React.MouseEvent) => {
    if (e.target === e.currentTarget && !isConfirming) {
      onClose();
    }
  }, [isConfirming, onClose]);
  
  // Don't render on server or when not mounted/closed
  if (!isMounted || !isOpen) {
    return null;
  }
  
  const defaultIcon = (
    <div className={cn(
      'p-2 rounded-lg',
      isDestructive ? 'bg-red-100' : 'bg-yellow-100'
    )}>
      <AlertTriangle className={cn(
        'h-5 w-5',
        isDestructive ? 'text-red-600' : 'text-yellow-600'
      )} />
    </div>
  );
  
  const modalContent = (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center"
      onClick={handleBackdropClick}
      role="dialog"
      aria-modal="true"
      aria-labelledby="confirmation-modal-title"
    >
      {/* Backdrop */}
      <div 
        className="absolute inset-0 bg-black/50 transition-opacity"
        aria-hidden="true"
      />
      
      {/* Modal */}
      <div
        className={cn(
          'relative bg-white rounded-xl shadow-2xl',
          'w-full max-w-md mx-4',
          'transform transition-all duration-200',
          'animate-in fade-in-0 zoom-in-95'
        )}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200">
          <div className="flex items-center gap-3">
            {icon || defaultIcon}
            <h2 
              id="confirmation-modal-title"
              className="text-lg font-semibold text-gray-900"
            >
              {title}
            </h2>
          </div>
          <button
            onClick={onClose}
            disabled={isConfirming}
            className={cn(
              'p-2 rounded-lg text-gray-400',
              'hover:text-gray-600 hover:bg-gray-100',
              'transition-colors',
              'disabled:opacity-50 disabled:cursor-not-allowed'
            )}
            aria-label="Close"
          >
            <X className="h-5 w-5" />
          </button>
        </div>
        
        {/* Content */}
        <div className="px-6 py-5">
          <p className="text-gray-700 mb-2">
            {message}
          </p>
          {description && (
            <p className="text-sm text-gray-500 mb-6">
              {description}
            </p>
          )}
          
          {/* Action buttons */}
          <div className="flex gap-3 justify-end">
            <Button
              variant="outline"
              onClick={onClose}
              disabled={isConfirming}
              className="px-4"
            >
              {cancelLabel}
            </Button>
            <Button
              onClick={onConfirm}
              disabled={isConfirming}
              className={cn(
                'px-4',
                isDestructive 
                  ? 'bg-red-600 hover:bg-red-700 text-white focus:ring-red-500'
                  : 'bg-apple-blue hover:bg-apple-blue/90',
                'disabled:opacity-50 disabled:cursor-not-allowed'
              )}
            >
              {isConfirming ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Processing...
                </>
              ) : (
                confirmLabel
              )}
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
  
  return createPortal(modalContent, document.body);
}

export default ConfirmationModal;


=== FILE: components/ui/index.ts ===

/**
 * @file components/ui/index.ts
 * @description Barrel export for UI components
 */

export { Button, buttonVariants, type ButtonProps } from './button';
export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent } from './card';
export { Badge, badgeVariants, type BadgeProps } from './badge';
export { Input, type InputProps } from './input';
export { AutoExpandTextarea } from './AutoExpandTextarea';
export { AIWorxLoader, AIWorxButtonLoader } from './AIWorxLoader';
export { SlideOutPanel, type SlideOutPanelProps } from './SlideOutPanel';



=== FILE: components/ui/input.tsx ===

/**
 * @file components/ui/input.tsx
 * @description Input component with consistent styling
 */

import * as React from 'react';
import { cn } from '@/lib/utils';

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

/**
 * Input component
 * 
 * A styled input field with focus states and accessibility support.
 * 
 * @example
 * <Input type="email" placeholder="Enter your email" />
 */
const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          'flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 transition-colors',
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = 'Input';

export { Input };



=== FILE: components/ui/SlideOutPanel.tsx ===

/**
 * @file components/ui/SlideOutPanel.tsx
 * @description Reusable slide-out panel component for navigation and forms
 * 
 * Features:
 * - Slides from left or right side of screen
 * - Left panels: 450px width (navigation/browsing)
 * - Right panels: 550px width (forms/configuration)
 * - Smooth 300ms slide animation
 * - Dark backdrop overlay (50% opacity)
 * - Click backdrop or ESC to close
 * - Header with title and close button
 * - Scrollable content area
 * - Optional footer for action buttons
 * - React Portal for proper z-index stacking
 * 
 * @example
 * ```tsx
 * <SlideOutPanel
 *   isOpen={isOpen}
 *   onClose={() => setIsOpen(false)}
 *   side="left"
 *   title="Navigation"
 *   footer={<Button onClick={handleSave}>Save</Button>}
 * >
 *   <div>Panel content here</div>
 * </SlideOutPanel>
 * ```
 */

'use client';

import React, { useEffect, useCallback, useRef } from 'react';
import { createPortal } from 'react-dom';
import { X } from 'lucide-react';
import { cn } from '@/lib/utils';

/**
 * Panel width configuration by side
 */
const PANEL_WIDTHS = {
  left: 450,
  right: 550,
} as const;

/**
 * SlideOutPanel component props
 */
export interface SlideOutPanelProps {
  /** Whether the panel is currently open */
  isOpen: boolean;
  
  /** Callback when panel should close */
  onClose: () => void;
  
  /** Which side the panel slides from */
  side: 'left' | 'right';
  
  /** Panel header title */
  title: string;
  
  /** Panel content */
  children: React.ReactNode;
  
  /** Optional footer content (e.g., action buttons) */
  footer?: React.ReactNode;
  
  /** Optional additional CSS classes for the panel container */
  className?: string;
  
  /** Optional subtitle under the title */
  subtitle?: string;
  
  /** Optional custom width override (in pixels) */
  width?: number;
}

/**
 * SlideOutPanel - A reusable slide-out panel component
 * 
 * Renders a slide-out panel from either the left or right side of the screen.
 * Uses React Portal to render outside the normal DOM hierarchy for proper
 * z-index stacking.
 */
export function SlideOutPanel({
  isOpen,
  onClose,
  side,
  title,
  children,
  footer,
  className,
  subtitle,
  width,
}: SlideOutPanelProps) {
  const panelRef = useRef<HTMLDivElement>(null);
  const [isMounted, setIsMounted] = React.useState(false);
  const [isAnimating, setIsAnimating] = React.useState(false);
  
  // Get panel width
  const panelWidth = width ?? PANEL_WIDTHS[side];
  
  // Handle mount state for SSR compatibility
  useEffect(() => {
    setIsMounted(true);
  }, []);
  
  // Handle animation state
  useEffect(() => {
    if (isOpen) {
      // Trigger animation on next frame for CSS transition
      requestAnimationFrame(() => {
        setIsAnimating(true);
      });
    } else {
      setIsAnimating(false);
    }
  }, [isOpen]);
  
  // Handle ESC key to close
  const handleKeyDown = useCallback((event: KeyboardEvent) => {
    if (event.key === 'Escape' && isOpen) {
      onClose();
    }
  }, [isOpen, onClose]);
  
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);
  
  // Prevent body scroll when panel is open
  useEffect(() => {
    if (isOpen) {
      const originalOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
      return () => {
        document.body.style.overflow = originalOverflow;
      };
    }
  }, [isOpen]);
  
  // Focus trap - focus panel when opened
  useEffect(() => {
    if (isOpen && panelRef.current) {
      panelRef.current.focus();
    }
  }, [isOpen]);
  
  // Handle backdrop click
  const handleBackdropClick = useCallback((event: React.MouseEvent) => {
    // Only close if clicking the backdrop itself, not the panel
    if (event.target === event.currentTarget) {
      onClose();
    }
  }, [onClose]);
  
  // Don't render on server or when not mounted
  if (!isMounted) {
    return null;
  }
  
  // Don't render anything if closed and not animating
  if (!isOpen && !isAnimating) {
    return null;
  }
  
  const panelContent = (
    <div
      className={cn(
        'fixed inset-0 z-50',
        // Backdrop transition
        'transition-opacity duration-300 ease-out',
        isAnimating ? 'opacity-100' : 'opacity-0'
      )}
      onClick={handleBackdropClick}
      aria-hidden={!isOpen}
    >
      {/* Backdrop overlay */}
      <div
        className={cn(
          'absolute inset-0 bg-black/50',
          'transition-opacity duration-300 ease-out',
          isAnimating ? 'opacity-100' : 'opacity-0'
        )}
        aria-hidden="true"
      />
      
      {/* Panel */}
      <div
        ref={panelRef}
        role="dialog"
        aria-modal="true"
        aria-labelledby="slideout-panel-title"
        tabIndex={-1}
        className={cn(
          'fixed top-0 bottom-0 flex flex-col',
          'bg-white shadow-2xl',
          'transition-transform duration-300 ease-out',
          // Position based on side
          side === 'left' ? 'left-0 rounded-r-2xl' : 'right-0 rounded-l-2xl',
          // Slide animation
          side === 'left'
            ? (isAnimating ? 'translate-x-0' : '-translate-x-full')
            : (isAnimating ? 'translate-x-0' : 'translate-x-full'),
          className
        )}
        style={{ width: `${panelWidth}px` }}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="flex-shrink-0 px-6 py-5 border-b border-gray-200">
          <div className="flex items-start justify-between">
            <div className="flex-1 min-w-0 pr-4">
              <h2
                id="slideout-panel-title"
                className="text-lg font-semibold text-gray-900 truncate"
              >
                {title}
              </h2>
              {subtitle && (
                <p className="mt-1 text-sm text-gray-500 truncate">
                  {subtitle}
                </p>
              )}
            </div>
            <button
              onClick={onClose}
              className={cn(
                'flex-shrink-0 p-2 rounded-lg',
                'text-gray-400 hover:text-gray-600',
                'hover:bg-gray-100 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2'
              )}
              aria-label="Close panel"
            >
              <X className="w-5 h-5" />
            </button>
          </div>
        </div>
        
        {/* Content - scrollable */}
        <div className="flex-1 overflow-y-auto px-6 py-5 custom-scrollbar">
          {children}
        </div>
        
        {/* Footer - optional */}
        {footer && (
          <div className="flex-shrink-0 px-6 py-4 border-t border-gray-200 bg-gray-50">
            {footer}
          </div>
        )}
      </div>
    </div>
  );
  
  // Render using portal to document.body
  return createPortal(panelContent, document.body);
}

/**
 * Default export for convenience
 */
export default SlideOutPanel;


=== FILE: components/ui/slider.tsx ===

"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }


=== FILE: components/workspace/BrandAlignmentTool.tsx ===

/**
 * @file components/workspace/BrandAlignmentTool.tsx
 * @description Standalone Brand Alignment checking tool
 * 
 * Features:
 * - Check selected copy against saved brand voice
 * - Display alignment score, matches, violations, and recommendations
 * - Requires brand voice to be set up first
 * - Apple-style design aesthetic
 * 
 * @example
 * ```tsx
 * <BrandAlignmentTool editor={editorInstance} />
 * ```
 */

'use client';

import React, { useMemo } from 'react';
import { 
  Zap,
  CheckCircle,
  AlertTriangle,
  X,
  ThumbsUp,
  ThumbsDown,
  Lightbulb,
  Sparkles,
  Folder,
  Volume2,
  Wand2
} from 'lucide-react';
import { 
  useWorkspaceStore,
  useProjects, 
  useActiveProjectId, 
  useSelectedText,
  useBrandAlignmentResult,
  useBrandAlignmentLoading,
  useBrandAlignmentError,
  useBrandAlignmentActions,
  useBrandAlignmentAnalyzedText,
  useOptimizeAlignmentLoading,
  useOptimizeAlignmentActions,
} from '@/lib/stores/workspaceStore';
import { AIWorxButtonLoader } from '@/components/ui/AIWorxLoader';
import type { Editor } from '@tiptap/react';
import { cn } from '@/lib/utils';

interface BrandAlignmentToolProps {
  /** TipTap editor instance */
  editor: Editor | null;
  
  /** Optional CSS classes */
  className?: string;
}

/**
 * BrandAlignmentTool component - Standalone brand alignment checking
 */
export function BrandAlignmentTool({ editor, className }: BrandAlignmentToolProps) {
  // Optimized selectors
  const selectedText = useSelectedText();
  const brandAlignmentResult = useBrandAlignmentResult();
  const brandAlignmentLoading = useBrandAlignmentLoading();
  const brandAlignmentError = useBrandAlignmentError();
  const brandAlignmentAnalyzedText = useBrandAlignmentAnalyzedText();
  const { runBrandAlignment, clearBrandAlignmentResult } = useBrandAlignmentActions();
  
  // Optimize alignment state
  const optimizeLoading = useOptimizeAlignmentLoading();
  const { runOptimizeAlignment } = useOptimizeAlignmentActions();
  
  // Get active project
  const activeProjectId = useActiveProjectId();
  const projects = useProjects();
  const activeProject = useMemo(
    () => projects.find((p) => p.id === activeProjectId),
    [projects, activeProjectId]
  );

  // Check states
  const hasSelection = selectedText && selectedText.trim().length > 0;
  const hasBrandVoice = !!activeProject?.brandVoice;
  const canCheck = hasSelection && hasBrandVoice && !brandAlignmentLoading;

  /**
   * Handle check brand alignment
   */
  const handleCheckAlignment = async () => {
    if (!activeProject?.brandVoice || !selectedText) return;
    await runBrandAlignment(selectedText, activeProject.brandVoice);
  };

  /**
   * Navigate to Brand Voice setup
   */
  const handleGoToBrandVoice = () => {
    useWorkspaceStore.getState().setActiveTool('brand-voice');
  };

  /**
   * Handle rewrite to optimize for brand voice
   * Uses the analysis results to guide the rewrite
   */
  const handleRewriteToOptimize = async () => {
    if (!activeProject?.brandVoice || !brandAlignmentResult) return;
    
    // Use the stored analyzed text (from when analysis was run)
    // This allows rewriting even if user has deselected the text
    const textToOptimize = brandAlignmentAnalyzedText;
    if (!textToOptimize) return;

    await runOptimizeAlignment(
      textToOptimize,
      'brand',
      brandAlignmentResult,
      activeProject.brandVoice
    );
  };

  return (
    <div className={cn('flex flex-col gap-6', className)}>
      {/* Header */}
      <div className="flex flex-col gap-2">
        <div className="flex items-center gap-2">
          <Zap className="w-5 h-5 text-apple-blue" />
          <h2 className="text-lg font-semibold text-apple-text-dark">
            Check Brand Alignment
          </h2>
        </div>
        <p className="text-sm text-apple-text-light">
          Analyze how well your copy aligns with your brand voice
        </p>
      </div>

      {/* Brand Voice Status */}
      {hasBrandVoice ? (
        <div className="flex items-start gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
          <CheckCircle className="w-4 h-4 text-blue-600 flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <p className="text-sm font-medium text-blue-900">
              Brand Voice: {activeProject?.brandVoice?.brandName}
            </p>
            <p className="text-xs text-blue-700 mt-0.5">
              Ready to check copy alignment
            </p>
          </div>
        </div>
      ) : (
        <div className="flex flex-col gap-3 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
          <div className="flex items-start gap-2">
            <AlertTriangle className="w-4 h-4 text-yellow-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-sm font-medium text-yellow-900">
                No Brand Voice Set
              </p>
              <p className="text-xs text-yellow-700 mt-0.5">
                Set up your brand voice first to check alignment
              </p>
            </div>
          </div>
          <button
            onClick={handleGoToBrandVoice}
            className={cn(
              'w-full py-2 px-3 rounded-lg',
              'bg-yellow-600 text-white text-sm font-medium',
              'hover:bg-yellow-700 transition-colors duration-200',
              'focus:outline-none focus:ring-2 focus:ring-yellow-600 focus:ring-offset-2',
              'flex items-center justify-center gap-2'
            )}
          >
            <Volume2 className="w-4 h-4" />
            Set Up Brand Voice
          </button>
        </div>
      )}

      {/* Active Project Indicator */}
      {activeProject && (
        <div className="flex items-center gap-2 px-3 py-2 bg-gray-50 border border-gray-200 rounded-lg">
          <Folder className="w-4 h-4 text-gray-600 flex-shrink-0" />
          <p className="text-xs text-gray-700 truncate">
            Project: <span className="font-medium">{activeProject.name}</span>
          </p>
        </div>
      )}

      {/* Selected Text Preview */}
      {hasSelection ? (
        <div className="flex flex-col gap-2">
          <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide flex items-center gap-1.5">
            <Sparkles className="w-3.5 h-3.5 text-apple-blue" />
            Selected Text ({selectedText?.length || 0} characters)
          </label>
          <div className="bg-apple-gray-bg border border-apple-gray-light rounded-lg p-3 max-h-32 overflow-y-auto custom-scrollbar">
            <p className="text-sm text-apple-text-dark whitespace-pre-wrap">
              {selectedText}
            </p>
          </div>
        </div>
      ) : (
        <div className="flex items-center gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
          <Sparkles className="w-4 h-4 text-blue-600 flex-shrink-0" />
          <p className="text-xs text-blue-700">
            Highlight text in the editor to check brand alignment
          </p>
        </div>
      )}

      {/* Check Alignment Button */}
      <button
        onClick={handleCheckAlignment}
        disabled={!canCheck}
        className={cn(
          'w-full py-3 px-4 rounded-lg',
          'font-medium text-sm text-white',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          // Animated gradient when loading
          brandAlignmentLoading && 'aiworx-gradient-animated cursor-wait',
          // Brand button with blue‚Üípurple active when not loading
          !brandAlignmentLoading && (hasSelection && hasBrandVoice) && 'bg-[#006EE6] hover:bg-[#0062CC] active:bg-[#7A3991] active:scale-[0.98] shadow-sm hover:shadow transition-all duration-200',
          // Gray background when truly disabled (not loading)
          (!hasSelection || !hasBrandVoice) && !brandAlignmentLoading && 'bg-apple-gray-light text-apple-text-light cursor-not-allowed'
        )}
      >
        {brandAlignmentLoading ? (
          <AIWorxButtonLoader />
        ) : (
          'Check Brand Alignment'
        )}
      </button>

      {/* Helper Text */}
      {!hasSelection && hasBrandVoice && (
        <p className="text-xs text-apple-text-light text-center">
          Select text in the editor to check brand alignment
        </p>
      )}

      {/* Error Display */}
      {brandAlignmentError && (
        <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
          <X className="w-4 h-4 text-red-600 flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <p className="text-sm font-medium text-red-900">Error</p>
            <p className="text-xs text-red-700 mt-1">{brandAlignmentError}</p>
          </div>
          <button
            onClick={clearBrandAlignmentResult}
            className="text-red-600 hover:text-red-800 focus:outline-none"
            aria-label="Dismiss error"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
      )}

      {/* Results Display */}
      {brandAlignmentResult && (
        <div className="flex flex-col gap-4">
          {/* Analyzing Against Banner */}
          <div className="flex items-center gap-2 px-3 py-2.5 bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-lg">
            <Volume2 className="w-4 h-4 text-blue-600 flex-shrink-0" />
            <div className="flex-1 min-w-0">
              <p className="text-xs font-medium text-blue-900 truncate">
                Analyzing against: <span className="font-semibold">{activeProject?.brandVoice?.brandName}</span>
              </p>
            </div>
          </div>

          {/* Overall Score */}
          <div className="flex flex-col gap-3 p-4 bg-blue-50 border border-blue-200 rounded-lg">
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium text-blue-900">
                Alignment Score
              </span>
              <span className="text-2xl font-bold text-blue-600">
                {brandAlignmentResult.score}%
              </span>
            </div>
            <p className="text-sm text-blue-700">
              {brandAlignmentResult.assessment}
            </p>
          </div>

          {/* Matches */}
          {brandAlignmentResult.matches.length > 0 && (
            <div className="flex flex-col gap-2 p-3 bg-green-50 border border-green-200 rounded-lg">
              <div className="flex items-center gap-2">
                <ThumbsUp className="w-4 h-4 text-green-600" />
                <span className="text-sm font-medium text-green-900">
                  What Matches
                </span>
              </div>
              <ul className="ml-6 space-y-1">
                {brandAlignmentResult.matches.map((match: string, index: number) => (
                  <li key={index} className="text-sm text-green-700">
                    {match}
                  </li>
                ))}
              </ul>
            </div>
          )}

          {/* Violations */}
          {brandAlignmentResult.violations.length > 0 && (
            <div className="flex flex-col gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
              <div className="flex items-center gap-2">
                <ThumbsDown className="w-4 h-4 text-red-600" />
                <span className="text-sm font-medium text-red-900">
                  What Violates
                </span>
              </div>
              <ul className="ml-6 space-y-1">
                {brandAlignmentResult.violations.map((violation: string, index: number) => (
                  <li key={index} className="text-sm text-red-700">
                    {violation}
                  </li>
                ))}
              </ul>
            </div>
          )}

          {/* Recommendations */}
          {brandAlignmentResult.recommendations.length > 0 && (
            <div className="flex flex-col gap-2 p-3 bg-purple-50 border border-purple-200 rounded-lg">
              <div className="flex items-center gap-2">
                <Lightbulb className="w-4 h-4 text-purple-600" />
                <span className="text-sm font-medium text-purple-900">
                  Recommendations
                </span>
              </div>
              <ul className="ml-6 space-y-1">
                {brandAlignmentResult.recommendations.map((rec: string, index: number) => (
                  <li key={index} className="text-sm text-purple-700">
                    {rec}
                  </li>
                ))}
              </ul>
            </div>
          )}

          {/* Rewrite to Optimize Button - Always show when there's a result */}
          <button
            onClick={handleRewriteToOptimize}
            disabled={optimizeLoading || !brandAlignmentAnalyzedText}
            className={cn(
              'w-full py-3 px-4 rounded-lg',
              'font-medium text-sm text-white',
              'focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-offset-2',
              'flex items-center justify-center gap-2',
              'transition-all duration-200',
              optimizeLoading 
                ? 'aiworx-gradient-animated cursor-wait'
                : 'bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 shadow-sm hover:shadow'
            )}
          >
            <Wand2 className="w-4 h-4" />
            {optimizeLoading 
              ? 'Rewriting...' 
              : `Rewrite to Optimize for ${activeProject?.brandVoice?.brandName}`
            }
          </button>

          {/* Clear Button */}
          <button
            onClick={clearBrandAlignmentResult}
            className="w-full py-2 px-4 rounded-lg bg-gray-100 text-gray-700 text-sm font-medium hover:bg-gray-200 transition-colors duration-200"
          >
            Clear Results
          </button>
        </div>
      )}
    </div>
  );
}


=== FILE: components/workspace/BrandVoiceSection.tsx ===

/**
 * @file components/workspace/BrandVoiceSection.tsx
 * @description Brand Voice list section for the My Projects slide-out
 * 
 * Features:
 * - Displays brand voices for a project
 * - Click to open brand voice in slide-out panel
 * - Collapsible section
 * - Shows brand name and tone preview
 */

'use client';

import React, { useState, useMemo } from 'react';
import {
  Volume2,
  ChevronRight,
  ChevronDown,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import type { Project } from '@/lib/types/project';
import { useSlideOutActions } from '@/lib/stores/slideOutStore';
import { usePendingEditActions } from '@/lib/stores/workspaceStore';
import { BRAND_VOICE_PANEL_ID } from '@/components/workspace/BrandVoiceSlideOut';

// ============================================================================
// Types
// ============================================================================

interface BrandVoiceSectionProps {
  /** Project to display brand voices for */
  project: Project;
  /** Whether this project section is expanded */
  isExpanded: boolean;
  /** Search query for filtering */
  searchQuery?: string;
}

interface BrandVoiceRowProps {
  brandName: string;
  brandTone: string;
  isCurrent: boolean;
  onSelect: () => void;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Truncate text with ellipsis
 */
function truncateText(text: string, maxLength: number): string {
  if (!text || text.length <= maxLength) return text;
  return text.substring(0, maxLength).trim() + '...';
}

// ============================================================================
// BrandVoiceRow Component
// ============================================================================

function BrandVoiceRow({ brandName, brandTone, isCurrent, onSelect }: BrandVoiceRowProps) {
  return (
    <div
      className={cn(
        'group flex items-start gap-1.5 px-2 py-1.5 rounded-md cursor-pointer',
        'transition-colors duration-150',
        'hover:bg-gray-50'
      )}
      onClick={onSelect}
      title={`Click to view/edit "${brandName}"`}
    >
      <Volume2 className={cn(
        'h-3.5 w-3.5 flex-shrink-0 mt-px',
        'text-blue-500'
      )} />
      
      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2">
          <span className={cn(
            'text-xs font-medium truncate',
            'text-gray-900'
          )}>
            {brandName}
          </span>
        </div>
        {brandTone && (
          <p className="text-[10px] text-gray-500 truncate mt-0.5">
            {truncateText(brandTone, 60)}
          </p>
        )}
      </div>
    </div>
  );
}

// ============================================================================
// BrandVoiceSection Component
// ============================================================================

export function BrandVoiceSection({
  project,
  isExpanded,
  searchQuery = '',
}: BrandVoiceSectionProps) {
  const [sectionExpanded, setSectionExpanded] = useState(true);
  const { openSlideOut } = useSlideOutActions();
  const { setPendingBrandVoiceEdit } = usePendingEditActions();
  
  // Get brand voice from project
  const brandVoice = project.brandVoice;
  const hasBrandVoice = brandVoice !== null;
  
  // Filter by search query if provided
  const matchesSearch = useMemo(() => {
    if (!searchQuery.trim() || !brandVoice) return true;
    
    const query = searchQuery.toLowerCase();
    return (
      brandVoice.brandName.toLowerCase().includes(query) ||
      brandVoice.brandTone.toLowerCase().includes(query)
    );
  }, [brandVoice, searchQuery]);
  
  // Don't render if project section is collapsed
  if (!isExpanded) {
    return null;
  }
  
  // Hide if search doesn't match
  const shouldShowBrandVoice = hasBrandVoice && matchesSearch;
  
  // Toggle section expanded state
  const toggleSection = () => {
    setSectionExpanded(prev => !prev);
  };
  
  // Handle brand voice selection - set pending edit then open
  const handleBrandVoiceClick = () => {
    if (brandVoice) {
      // Set the brand name to edit
      setPendingBrandVoiceEdit(brandVoice.brandName);
    }
    openSlideOut(BRAND_VOICE_PANEL_ID);
  };
  
  return (
    <div className="mt-2 ml-2 pl-2 border-l-2 border-blue-200">
      {/* Section header */}
      <div
        className={cn(
          'flex items-center gap-2 px-3 py-2 rounded-lg cursor-pointer',
          'hover:bg-blue-50 transition-colors duration-150'
        )}
        onClick={toggleSection}
      >
        {sectionExpanded ? (
          <ChevronDown className="h-4 w-4 text-blue-400 flex-shrink-0" />
        ) : (
          <ChevronRight className="h-4 w-4 text-blue-400 flex-shrink-0" />
        )}
        
        <Volume2 className="h-4 w-4 text-blue-500 flex-shrink-0" />
        
        <span className="flex-1 text-sm font-semibold text-blue-900">
          Brand Voice
        </span>
        
        {hasBrandVoice && (
          <span className="text-xs text-blue-500 px-2 py-0.5 bg-blue-100 rounded-full">
            1
          </span>
        )}
      </div>
      
      {/* Brand voice display */}
      {sectionExpanded && (
        <div className="mt-1 space-y-1">
          {shouldShowBrandVoice && brandVoice ? (
            <BrandVoiceRow
              brandName={brandVoice.brandName}
              brandTone={brandVoice.brandTone}
              isCurrent={true}
              onSelect={handleBrandVoiceClick}
            />
          ) : !hasBrandVoice ? (
            <div className="text-center py-4">
              <p className="text-xs text-gray-400">
                No brand voice set
              </p>
              <button
                onClick={handleBrandVoiceClick}
                className="mt-2 text-xs text-blue-600 hover:text-blue-700 font-medium"
              >
                + Set brand voice
              </button>
            </div>
          ) : (
            <div className="text-xs text-gray-400 italic py-2 px-3">
              No brand voice matches &quot;{searchQuery}&quot;
            </div>
          )}
        </div>
      )}
    </div>
  );
}

export default BrandVoiceSection;


=== FILE: components/workspace/BrandVoiceSlideOut.tsx ===

/**
 * @file components/workspace/BrandVoiceSlideOut.tsx
 * @description Brand Voice management slide-out panel
 * 
 * Features:
 * - List all brand voices for the user
 * - Create new brand voices
 * - Edit existing brand voices
 * - Delete brand voices with confirmation
 * - Assign brand voice to current project
 */

'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { logger } from '@/lib/utils/logger';
import {
  Volume2,
  Save,
  CheckCircle,
  AlertTriangle,
  Trash2,
  Plus,
  Pencil,
  ArrowLeft,
  Loader2,
  Star,
} from 'lucide-react';
import { SlideOutPanel } from '@/components/ui/SlideOutPanel';
import { Button } from '@/components/ui/button';
import { AutoExpandTextarea } from '@/components/ui/AutoExpandTextarea';
import { ConfirmationModal } from '@/components/ui/ConfirmationModal';
import { cn } from '@/lib/utils';
import { useWorkspaceStore, useActiveProjectId, useProjects, usePendingBrandVoiceEdit, usePendingEditActions } from '@/lib/stores/workspaceStore';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/** Unique ID for the brand voice slide-out panel */
export const BRAND_VOICE_PANEL_ID = 'brand-voice-setup';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TYPES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

interface BrandVoiceSlideOutProps {
  /** Whether the slide-out is open */
  isOpen: boolean;
  
  /** Callback when slide-out should close */
  onClose: () => void;
}

/**
 * Brand voice data from the API
 */
interface BrandVoiceData {
  id: string;
  project_id: string | null;
  brand_name: string;
  brand_tone: string;
  approved_phrases: string[];
  forbidden_words: string[];
  brand_values: string[];
  mission_statement: string;
  created_at: string;
  updated_at: string;
}

type ViewMode = 'list' | 'create' | 'edit';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export function BrandVoiceSlideOut({
  isOpen,
  onClose,
}: BrandVoiceSlideOutProps) {
  // Store state
  const activeProjectId = useActiveProjectId();
  const projects = useProjects();
  const pendingBrandVoiceEdit = usePendingBrandVoiceEdit();
  const { setPendingBrandVoiceEdit } = usePendingEditActions();
  
  // Get active project
  const activeProject = React.useMemo(
    () => projects.find((p) => p.id === activeProjectId),
    [projects, activeProjectId]
  );
  
  // View state
  const [viewMode, setViewMode] = useState<ViewMode>('list');
  const [editingBrandVoice, setEditingBrandVoice] = useState<BrandVoiceData | null>(null);
  
  // Brand voices list state
  const [brandVoices, setBrandVoices] = useState<BrandVoiceData[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [loadError, setLoadError] = useState<string | null>(null);
  
  // Migration state
  const [showMigrationNeeded, setShowMigrationNeeded] = useState(false);
  const [migrationSql, setMigrationSql] = useState<string | null>(null);
  const [isRunningMigration, setIsRunningMigration] = useState(false);
  
  // Form state
  const [brandName, setBrandName] = useState('');
  const [brandTone, setBrandTone] = useState('');
  const [approvedPhrases, setApprovedPhrases] = useState('');
  const [forbiddenWords, setForbiddenWords] = useState('');
  const [brandValues, setBrandValues] = useState('');
  const [missionStatement, setMissionStatement] = useState('');
  
  // UI state
  const [isSaving, setIsSaving] = useState(false);
  const [saveSuccess, setSaveSuccess] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);
  
  // Delete confirmation state
  const [showDeleteModal, setShowDeleteModal] = useState(false);
  const [deletingBrandVoice, setDeletingBrandVoice] = useState<BrandVoiceData | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // DATA FETCHING
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  /**
   * Fetch all brand voices for the user
   */
  const fetchBrandVoices = useCallback(async () => {
    try {
      setIsLoading(true);
      setLoadError(null);
      
      const response = await fetch('/api/db/all-brand-voices');
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || 'Failed to fetch brand voices');
      }
      
      const data = await response.json();
      
      // Transform the data to match our expected format
      const transformedData: BrandVoiceData[] = data.map((bv: any) => ({
        id: bv.id,
        project_id: bv.projectId,
        brand_name: bv.brandName,
        brand_tone: bv.brandTone || '',
        approved_phrases: bv.approvedPhrases || [],
        forbidden_words: bv.forbiddenWords || [],
        brand_values: bv.brandValues || [],
        mission_statement: bv.missionStatement || '',
        created_at: bv.createdAt,
        updated_at: bv.updatedAt,
      }));
      
      setBrandVoices(transformedData);
    } catch (error) {
      logger.error('Failed to fetch brand voices:', error);
      setLoadError(error instanceof Error ? error.message : 'Failed to load brand voices');
    } finally {
      setIsLoading(false);
    }
  }, []);
  
  // Fetch brand voices when panel opens
  useEffect(() => {
    if (isOpen) {
      fetchBrandVoices();
      setViewMode('list');
    }
  }, [isOpen, fetchBrandVoices]);
  
  // Check for pending brand voice edit and automatically switch to edit mode
  useEffect(() => {
    if (isOpen && pendingBrandVoiceEdit && brandVoices.length > 0) {
      // Find the brand voice by name
      const brandVoiceToEdit = brandVoices.find(bv => bv.brand_name === pendingBrandVoiceEdit);
      
      if (brandVoiceToEdit) {
        // Load into edit mode
        handleEdit(brandVoiceToEdit);
        
        // Clear the pending edit
        setPendingBrandVoiceEdit(null);
      }
    }
  }, [isOpen, pendingBrandVoiceEdit, brandVoices, setPendingBrandVoiceEdit]);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // FORM HANDLERS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  /**
   * Reset form to empty state
   */
  const resetForm = useCallback(() => {
    setBrandName('');
    setBrandTone('');
    setApprovedPhrases('');
    setForbiddenWords('');
    setBrandValues('');
    setMissionStatement('');
    setSaveError(null);
    setSaveSuccess(false);
  }, []);
  
  /**
   * Load brand voice data into form
   */
  const loadBrandVoiceIntoForm = useCallback((bv: BrandVoiceData) => {
    setBrandName(bv.brand_name);
    setBrandTone(bv.brand_tone);
    setApprovedPhrases(bv.approved_phrases.join('\n'));
    setForbiddenWords(bv.forbidden_words.join('\n'));
    setBrandValues(bv.brand_values.join('\n'));
    setMissionStatement(bv.mission_statement);
    setSaveError(null);
    setSaveSuccess(false);
  }, []);
  
  /**
   * Handle creating a new brand voice
   */
  const handleCreateNew = useCallback(() => {
    resetForm();
    setEditingBrandVoice(null);
    setViewMode('create');
  }, [resetForm]);
  
  /**
   * Handle editing a brand voice
   */
  const handleEdit = useCallback((bv: BrandVoiceData) => {
    loadBrandVoiceIntoForm(bv);
    setEditingBrandVoice(bv);
    setViewMode('edit');
  }, [loadBrandVoiceIntoForm]);
  
  /**
   * Handle back to list
   */
  const handleBackToList = useCallback(() => {
    setViewMode('list');
    setEditingBrandVoice(null);
    resetForm();
  }, [resetForm]);
  
  /**
   * Handle save brand voice (create or update)
   */
  const handleSave = useCallback(async () => {
    setSaveError(null);
    setSaveSuccess(false);
    
    // Validate required fields
    if (!brandName.trim()) {
      setSaveError('Brand Name is required');
      return;
    }
    
    // For creating new brand voices, we need a project (until migration is run)
    if (viewMode === 'create' && !activeProjectId) {
      setSaveError('Please select a project first. Brand voices need to be associated with a project.');
      return;
    }
    
    setIsSaving(true);
    
    try {
      const brandVoiceData: Record<string, unknown> = {
        brand_name: brandName.trim(),
        brand_tone: brandTone.trim(),
        approved_phrases: approvedPhrases
          .split('\n')
          .map(p => p.trim())
          .filter(Boolean),
        forbidden_words: forbiddenWords
          .split('\n')
          .map(w => w.trim())
          .filter(Boolean),
        brand_values: brandValues
          .split('\n')
          .map(v => v.trim())
          .filter(Boolean),
        mission_statement: missionStatement.trim(),
      };
      
      let response: Response;
      
      if (viewMode === 'edit' && editingBrandVoice) {
        // Update existing brand voice
        response = await fetch('/api/db/brand-voices', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            id: editingBrandVoice.id,
            ...brandVoiceData,
          }),
        });
      } else {
        // Create new brand voice - include project_id for database compatibility
        // Note: Once the migration is run, project_id becomes optional
        response = await fetch('/api/db/brand-voices', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...brandVoiceData,
            project_id: activeProjectId, // Required until migration is run
          }),
        });
      }
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        
        // Provide helpful error messages
        if (response.status === 409) {
          // Show migration needed UI instead of error
          setShowMigrationNeeded(true);
          setMigrationSql(`-- Run this in Supabase SQL Editor
ALTER TABLE brand_voices DROP CONSTRAINT IF EXISTS brand_voices_project_id_key;
ALTER TABLE brand_voices ALTER COLUMN project_id DROP NOT NULL;`);
          throw new Error(
            'A brand voice already exists for this project. Click "Enable Multiple Brand Voices" below to fix this.'
          );
        }
        
        throw new Error(errorData.details || errorData.error || 'Failed to save brand voice');
      }
      
      setSaveSuccess(true);
      logger.log(`‚úÖ Brand voice ${viewMode === 'edit' ? 'updated' : 'created'}`);
      
      // Refresh the list and go back after a short delay
      await fetchBrandVoices();
      
      setTimeout(() => {
        setSaveSuccess(false);
        handleBackToList();
      }, 1000);
      
    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : 'Failed to save brand voice. Please try again.';
      setSaveError(errorMessage);
      logger.error('‚ùå Failed to save brand voice:', error);
    } finally {
      setIsSaving(false);
    }
  }, [
    brandName, brandTone, approvedPhrases, forbiddenWords, brandValues, missionStatement,
    viewMode, editingBrandVoice, fetchBrandVoices, handleBackToList
  ]);
  
  /**
   * Handle delete button click - show confirmation
   */
  const handleDeleteClick = useCallback((bv: BrandVoiceData) => {
    setDeletingBrandVoice(bv);
    setShowDeleteModal(true);
  }, []);
  
  /**
   * Confirm delete brand voice
   */
  const confirmDelete = useCallback(async () => {
    if (!deletingBrandVoice) return;
    
    setIsDeleting(true);
    
    try {
      const response = await fetch(`/api/db/brand-voices?id=${deletingBrandVoice.id}`, {
        method: 'DELETE',
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || 'Failed to delete brand voice');
      }
      
      logger.log('‚úÖ Brand voice deleted');
      
      // Refresh the list
      await fetchBrandVoices();
      
      // Also update Zustand store if this brand voice was assigned to any project
      const { projects } = useWorkspaceStore.getState();
      const updatedProjects = projects.map(p => {
        if (p.brandVoice && (p.brandVoice as any).id === deletingBrandVoice.id) {
          return { ...p, brandVoice: null };
        }
        return p;
      });
      useWorkspaceStore.setState({ projects: updatedProjects });
      
      setShowDeleteModal(false);
      setDeletingBrandVoice(null);
      
    } catch (error) {
      logger.error('‚ùå Failed to delete brand voice:', error);
      setSaveError(error instanceof Error ? error.message : 'Failed to delete brand voice');
    } finally {
      setIsDeleting(false);
    }
  }, [deletingBrandVoice, fetchBrandVoices]);
  
  /**
   * Cancel delete
   */
  const cancelDelete = useCallback(() => {
    setShowDeleteModal(false);
    setDeletingBrandVoice(null);
  }, []);
  
  /**
   * Run database migration to enable multiple brand voices
   */
  const handleRunMigration = useCallback(async () => {
    setIsRunningMigration(true);
    
    try {
      const response = await fetch('/api/db/run-migration', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ migration: 'multiple-brand-voices' }),
      });
      
      const data = await response.json();
      
      if (data.success) {
        // Migration succeeded
        setShowMigrationNeeded(false);
        setMigrationSql(null);
        setSaveError(null);
        // User can now click save again
      } else {
        // Migration failed, show the SQL to copy
        setMigrationSql(data.sql);
        setSaveError('Automatic migration failed. Please copy and run the SQL below in your Supabase SQL Editor, then try saving again.');
      }
    } catch (error) {
      setSaveError('Failed to run migration. Please copy the SQL below and run it manually in Supabase SQL Editor.');
    } finally {
      setIsRunningMigration(false);
    }
  }, []);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // RENDER HELPERS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  /**
   * Render the list view
   */
  const renderListView = () => (
    <div className="space-y-4">
      {/* Create New Button */}
      <Button
        variant="brand"
        size="default"
        onClick={handleCreateNew}
        className="w-full"
      >
        <Plus className="w-4 h-4 mr-2" />
        New Brand Voice
      </Button>
      
      {/* Loading State */}
      {isLoading && (
        <div className="flex items-center justify-center py-8">
          <Loader2 className="w-6 h-6 animate-spin text-apple-blue" />
          <span className="ml-2 text-sm text-gray-600">Loading brand voices...</span>
        </div>
      )}
      
      {/* Error State */}
      {loadError && (
        <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
          <AlertTriangle className="w-4 h-4 text-red-600 flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <p className="text-sm font-medium text-red-900">Error</p>
            <p className="text-xs text-red-700 mt-1">{loadError}</p>
          </div>
        </div>
      )}
      
      {/* Empty State */}
      {!isLoading && !loadError && brandVoices.length === 0 && (
        <div className="text-center py-8">
          <Volume2 className="w-12 h-12 text-gray-300 mx-auto mb-3" />
          <p className="text-gray-600 font-medium">No brand voices yet</p>
          <p className="text-sm text-gray-500 mt-1">
            Create your first brand voice to get started
          </p>
        </div>
      )}
      
      {/* Brand Voices List */}
      {!isLoading && !loadError && brandVoices.length > 0 && (
        <div className="space-y-2">
          {brandVoices.map((bv) => {
            // Check if this brand voice is currently assigned to the active project
            const isCurrentBrandVoice = activeProject?.brandVoice?.brandName === bv.brand_name;
            
            return (
              <div
                key={bv.id}
                className={cn(
                  'flex items-center justify-between p-3 rounded-lg border',
                  'bg-white hover:bg-gray-50 transition-colors duration-200',
                  isCurrentBrandVoice && 'border-apple-blue bg-blue-50'
                )}
              >
                <div className="flex-1 min-w-0">
                  <div className="flex items-center gap-2">
                    <Volume2 className="w-4 h-4 text-apple-blue flex-shrink-0" />
                    <span className="font-medium text-gray-900 truncate">
                      {bv.brand_name}
                    </span>
                    {isCurrentBrandVoice && (
                      <span className="text-xs px-2 py-0.5 bg-apple-blue text-white rounded-full">
                        Current
                      </span>
                    )}
                  </div>
                {bv.brand_tone && (
                  <p className="text-xs text-gray-500 mt-1 truncate pl-6">
                    {bv.brand_tone.substring(0, 50)}
                    {bv.brand_tone.length > 50 ? '...' : ''}
                  </p>
                )}
              </div>
              
              <div className="flex items-center gap-1 ml-2">
                <button
                  onClick={() => handleEdit(bv)}
                  className="p-2 text-gray-400 hover:text-apple-blue rounded-lg hover:bg-gray-100 transition-colors"
                  title="Edit brand voice"
                >
                  <Pencil className="w-4 h-4" />
                </button>
                <button
                  onClick={() => handleDeleteClick(bv)}
                  className="p-2 text-gray-400 hover:text-red-600 rounded-lg hover:bg-red-50 transition-colors"
                  title="Delete brand voice"
                >
                  <Trash2 className="w-4 h-4" />
                </button>
              </div>
            </div>
            );
          })}
        </div>
      )}
    </div>
  );
  
  /**
   * Render the form view (create or edit)
   */
  const renderFormView = () => (
    <div className="space-y-6">
      {/* Back Button */}
      <button
        onClick={handleBackToList}
        className="flex items-center gap-2 text-sm text-gray-600 hover:text-gray-900 transition-colors"
      >
        <ArrowLeft className="w-4 h-4" />
        Back to Brand Voices
      </button>
      
      {/* Success Message */}
      {saveSuccess && (
        <div className="flex items-center gap-2 p-3 bg-green-50 border border-green-200 rounded-lg">
          <CheckCircle className="w-4 h-4 text-green-600 flex-shrink-0" />
          <p className="text-sm text-green-700">
            Brand voice {viewMode === 'edit' ? 'updated' : 'created'} successfully!
          </p>
        </div>
      )}
      
      {/* Error Message */}
      {saveError && (
        <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
          <AlertTriangle className="w-4 h-4 text-red-600 flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <p className="text-sm font-medium text-red-900">Error</p>
            <p className="text-xs text-red-700 mt-1 whitespace-pre-wrap">{saveError}</p>
          </div>
        </div>
      )}
      
      {/* Migration Needed UI */}
      {showMigrationNeeded && (
        <div className="space-y-3 p-4 bg-amber-50 border border-amber-200 rounded-lg">
          <div className="flex items-start gap-2">
            <AlertTriangle className="w-5 h-5 text-amber-600 flex-shrink-0 mt-0.5" />
            <div>
              <p className="font-medium text-amber-900">Database Update Required</p>
              <p className="text-sm text-amber-700 mt-1">
                To enable multiple brand voices, the database needs to be updated.
              </p>
            </div>
          </div>
          
          <Button
            variant="brand"
            size="default"
            onClick={handleRunMigration}
            disabled={isRunningMigration}
            className="w-full"
          >
            {isRunningMigration ? (
              <>
                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                Running Migration...
              </>
            ) : (
              'Enable Multiple Brand Voices'
            )}
          </Button>
          
          {migrationSql && (
            <div className="mt-3">
              <p className="text-xs text-amber-700 mb-2">
                Or copy this SQL and run it in your Supabase SQL Editor:
              </p>
              <pre className="text-xs bg-gray-900 text-green-400 p-3 rounded-lg overflow-x-auto whitespace-pre-wrap">
                {migrationSql}
              </pre>
            </div>
          )}
        </div>
      )}
      
      {/* Form Fields */}
      <div className="space-y-5">
        {/* Brand Name */}
        <div className="space-y-2">
          <label htmlFor="brandName" className="block text-sm font-medium text-gray-900">
            Brand Name <span className="text-red-600">*</span>
          </label>
          <input
            id="brandName"
            type="text"
            value={brandName}
            onChange={(e) => setBrandName(e.target.value)}
            placeholder="e.g., Acme Corporation, Nike, My Startup"
            disabled={isSaving || saveSuccess}
            className={cn(
              'w-full px-3 py-2 rounded-lg border transition-all duration-200',
              'text-sm text-gray-900 bg-white',
              'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
              'disabled:bg-gray-50 disabled:opacity-50',
              'placeholder:text-gray-400'
            )}
          />
          <p className="text-xs text-gray-500">
            Give this brand voice a name so you can identify it
          </p>
        </div>
        
        {/* Brand Tone Description */}
        <div className="space-y-2">
          <label htmlFor="brandTone" className="block text-sm font-medium text-gray-900">
            Brand Tone Description
          </label>
          <AutoExpandTextarea
            id="brandTone"
            value={brandTone}
            onChange={(e) => setBrandTone(e.target.value)}
            placeholder="e.g., Professional yet approachable, innovative, customer-focused"
            minHeight={100}
            maxHeight={300}
            disabled={isSaving || saveSuccess}
            className={cn(
              'w-full px-3 py-2 rounded-lg border transition-all duration-200',
              'text-sm text-gray-900 bg-white',
              'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
              'disabled:bg-gray-50 disabled:opacity-50',
              'placeholder:text-gray-400'
            )}
          />
        </div>
        
        {/* Approved Phrases */}
        <div className="space-y-2">
          <label htmlFor="approvedPhrases" className="block text-sm font-medium text-gray-900">
            Approved Phrases
          </label>
          <AutoExpandTextarea
            id="approvedPhrases"
            value={approvedPhrases}
            onChange={(e) => setApprovedPhrases(e.target.value)}
            placeholder="world-class&#10;industry-leading&#10;trusted partner"
            minHeight={100}
            maxHeight={300}
            disabled={isSaving || saveSuccess}
            className={cn(
              'w-full px-3 py-2 rounded-lg border transition-all duration-200',
              'text-sm text-gray-900 bg-white',
              'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
              'disabled:bg-gray-50 disabled:opacity-50',
              'placeholder:text-gray-400'
            )}
          />
          <p className="text-xs text-gray-500">One per line</p>
        </div>
        
        {/* Forbidden Words */}
        <div className="space-y-2">
          <label htmlFor="forbiddenWords" className="block text-sm font-medium text-red-600">
            Forbidden Words
          </label>
          <AutoExpandTextarea
            id="forbiddenWords"
            value={forbiddenWords}
            onChange={(e) => setForbiddenWords(e.target.value)}
            placeholder="cheap&#10;discount&#10;limited time"
            minHeight={100}
            maxHeight={300}
            disabled={isSaving || saveSuccess}
            className={cn(
              'w-full px-3 py-2 rounded-lg border border-red-200 transition-all duration-200',
              'text-sm text-gray-900 bg-white',
              'focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2',
              'disabled:bg-gray-50 disabled:opacity-50',
              'placeholder:text-gray-400'
            )}
          />
          <p className="text-xs text-gray-500">One per line</p>
        </div>
        
        {/* Brand Values */}
        <div className="space-y-2">
          <label htmlFor="brandValues" className="block text-sm font-medium text-gray-900">
            Brand Values
          </label>
          <AutoExpandTextarea
            id="brandValues"
            value={brandValues}
            onChange={(e) => setBrandValues(e.target.value)}
            placeholder="Innovation&#10;Customer Success&#10;Integrity"
            minHeight={100}
            maxHeight={300}
            disabled={isSaving || saveSuccess}
            className={cn(
              'w-full px-3 py-2 rounded-lg border transition-all duration-200',
              'text-sm text-gray-900 bg-white',
              'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
              'disabled:bg-gray-50 disabled:opacity-50',
              'placeholder:text-gray-400'
            )}
          />
          <p className="text-xs text-gray-500">One per line</p>
        </div>
        
        {/* Mission Statement */}
        <div className="space-y-2">
          <label htmlFor="missionStatement" className="block text-sm font-medium text-gray-900">
            Mission Statement
          </label>
          <AutoExpandTextarea
            id="missionStatement"
            value={missionStatement}
            onChange={(e) => setMissionStatement(e.target.value)}
            placeholder="Our mission is to..."
            minHeight={100}
            maxHeight={300}
            disabled={isSaving || saveSuccess}
            className={cn(
              'w-full px-3 py-2 rounded-lg border transition-all duration-200',
              'text-sm text-gray-900 bg-white',
              'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
              'disabled:bg-gray-50 disabled:opacity-50',
              'placeholder:text-gray-400'
            )}
          />
        </div>
      </div>
      
      {/* Action Buttons */}
      <div className="flex gap-3 pt-4">
        <Button
          variant="outline"
          size="default"
          onClick={handleBackToList}
          disabled={isSaving || saveSuccess}
          className="flex-1"
        >
          Cancel
        </Button>
        <Button
          variant="brand"
          size="default"
          onClick={handleSave}
          disabled={isSaving || saveSuccess}
          className="flex-1"
        >
          {isSaving ? (
            <>
              <Loader2 className="w-4 h-4 mr-2 animate-spin" />
              Saving...
            </>
          ) : saveSuccess ? (
            <>
              <CheckCircle className="w-4 h-4 mr-2" />
              Saved!
            </>
          ) : (
            <>
              <Save className="w-4 h-4 mr-2" />
              {viewMode === 'edit' ? 'Update' : 'Create'} Brand Voice
            </>
          )}
        </Button>
      </div>
    </div>
  );
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // RENDER
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  return (
    <>
      <SlideOutPanel
        isOpen={isOpen}
        onClose={onClose}
        side="right"
        title={
          viewMode === 'list' ? 'Brand Voices' :
          viewMode === 'create' ? 'New Brand Voice' :
          `Edit: ${editingBrandVoice?.brand_name || 'Brand Voice'}`
        }
        subtitle={
          viewMode === 'list' ? 'Manage your brand voice profiles' :
          viewMode === 'create' ? 'Define a new brand voice' :
          'Update brand voice settings'
        }
      >
        {viewMode === 'list' ? renderListView() : renderFormView()}
      </SlideOutPanel>
      
      {/* Delete Confirmation Modal */}
      <ConfirmationModal
        isOpen={showDeleteModal}
        title="Delete Brand Voice"
        message={`Delete "${deletingBrandVoice?.brand_name}" brand voice?`}
        description="This will permanently remove this brand voice. This cannot be undone."
        confirmLabel="Delete Brand Voice"
        onClose={cancelDelete}
        onConfirm={confirmDelete}
        isConfirming={isDeleting}
        isDestructive={true}
      />
    </>
  );
}


=== FILE: components/workspace/BrandVoiceTool.tsx ===

/**
 * @file components/workspace/BrandVoiceTool.tsx
 * @description Brand Voice setup and alignment checking tool
 * 
 * Features:
 * - Two-tab interface: Setup | Check Copy
 * - Setup: Form to define brand voice
 * - Check Copy: Analyze text alignment with brand voice
 * - Local storage persistence
 * - Apple-style design aesthetic
 * 
 * @example
 * ```tsx
 * <BrandVoiceTool editor={editorInstance} />
 * ```
 */

'use client';

import React, { useState, useEffect } from 'react';
import { logger } from '@/lib/utils/logger';
import { 
  Volume2,
  Save,
  CheckCircle,
  Check, 
  X,
  AlertTriangle,
  ThumbsUp,
  ThumbsDown,
  Lightbulb,
  Sparkles,
  Folder
} from 'lucide-react';
import { 
  useWorkspaceStore,
  useProjects, 
  useActiveProjectId, 
  useSelectedText,
  useSelectionRange,
  useBrandAlignmentResult,
  useBrandAlignmentLoading,
  useBrandAlignmentError,
  useBrandAlignmentActions,
  useProjectActions,
} from '@/lib/stores/workspaceStore';
import { insertTextAtSelection } from '@/lib/editor-utils';
import { saveBrandVoiceToProject } from '@/lib/storage/unified-storage';
import { AutoExpandTextarea } from '@/components/ui/AutoExpandTextarea';
import { AIWorxButtonLoader } from '@/components/ui/AIWorxLoader';
import type { Editor } from '@tiptap/react';
import type { BrandVoice } from '@/lib/types/brand';
import { cn } from '@/lib/utils';

interface BrandVoiceToolProps {
  /** TipTap editor instance */
  editor: Editor | null;
  
  /** Optional CSS classes */
  className?: string;
}

type TabType = 'setup' | 'check';

/**
 * BrandVoiceTool component - Brand voice setup and alignment checking
 */
export function BrandVoiceTool({ editor, className }: BrandVoiceToolProps) {
  // Optimized selectors - only re-render when these specific values change
  const selectedText = useSelectedText();
  const selectionRange = useSelectionRange();
  const brandAlignmentResult = useBrandAlignmentResult();
  const brandAlignmentLoading = useBrandAlignmentLoading();
  const brandAlignmentError = useBrandAlignmentError();
  const { runBrandAlignment, clearBrandAlignmentResult } = useBrandAlignmentActions();
  const { updateProject } = useProjectActions();
  
  // Get active project - use projects array and ID separately to control re-renders
  const activeProjectId = useActiveProjectId();
  const projects = useProjects();
  // Memoize the find operation to avoid creating new references
  const activeProject = React.useMemo(
    () => projects.find((p) => p.id === activeProjectId),
    [projects, activeProjectId]
  );

  // Tab state
  const [activeTab, setActiveTab] = useState<TabType>('setup');

  // Form state
  const [brandName, setBrandName] = useState('');
  const [brandTone, setBrandTone] = useState('');
  const [approvedPhrases, setApprovedPhrases] = useState('');
  const [forbiddenWords, setForbiddenWords] = useState('');
  const [brandValues, setBrandValues] = useState('');
  const [missionStatement, setMissionStatement] = useState('');
  
  // UI state
  const [saveSuccess, setSaveSuccess] = useState(false);
  const [saveError, setSaveError] = useState<string | null>(null);

  // Load brand voice from active project
  // IMPORTANT: Only use activeProjectId in dependency array to prevent cascading re-renders
  useEffect(() => {
    // Get fresh project data inside the effect
    const currentProjects = useWorkspaceStore.getState().projects;
    const currentProject = currentProjects.find((p) => p.id === activeProjectId);
    
    if (!currentProject) {
      // No active project - clear form
      setBrandName('');
      setBrandTone('');
      setApprovedPhrases('');
      setForbiddenWords('');
      setBrandValues('');
      setMissionStatement('');
      logger.log('‚ö†Ô∏è No active project');
      return;
    }

    // Load brand voice from project
    const brandVoice = currentProject.brandVoice;
    
    if (brandVoice) {
      // Populate form with project's brand voice
      setBrandName(brandVoice.brandName);
      setBrandTone(brandVoice.brandTone);
      setApprovedPhrases(brandVoice.approvedPhrases.join('\n'));
      setForbiddenWords(brandVoice.forbiddenWords.join('\n'));
      setBrandValues(brandVoice.brandValues.join('\n'));
      setMissionStatement(brandVoice.missionStatement);
      
      logger.log('‚úÖ Loaded brand voice from project:', currentProject.name);
    } else {
      // No brand voice in project - clear form
      setBrandName('');
      setBrandTone('');
      setApprovedPhrases('');
      setForbiddenWords('');
      setBrandValues('');
      setMissionStatement('');
      
      logger.log('‚ÑπÔ∏è No brand voice set for project:', currentProject.name);
    }
  }, [activeProjectId]); // Only depend on primitive ID, not derived objects

  /**
   * Handle save brand voice
   */
  const handleSaveBrandVoice = (): void => {
    // Clear previous errors
    setSaveError(null);
    setSaveSuccess(false);

    // Check if project exists
    if (!activeProject || !activeProjectId) {
      setSaveError('No active project. Please create a project first.');
      return;
    }

    // Validate required fields
    if (!brandName.trim()) {
      setSaveError('Brand Name is required');
      return;
    }

    // Create brand voice object
    const brandVoice: BrandVoice = {
      brandName: brandName.trim(),
      brandTone: brandTone.trim(),
      approvedPhrases: approvedPhrases
        .split('\n')
        .map(p => p.trim())
        .filter(Boolean),
      forbiddenWords: forbiddenWords
        .split('\n')
        .map(w => w.trim())
        .filter(Boolean),
      brandValues: brandValues
        .split('\n')
        .map(v => v.trim())
        .filter(Boolean),
      missionStatement: missionStatement.trim(),
      savedAt: new Date(),
    };

    // Save to active project
    try {
      saveBrandVoiceToProject(activeProjectId, brandVoice);
      
      // Update Zustand store
      updateProject(activeProjectId, { brandVoice });
      
      setSaveSuccess(true);
      
      logger.log('‚úÖ Brand voice saved to project:', activeProject.name);
      
      // Clear success message after 3 seconds
      setTimeout(() => setSaveSuccess(false), 3000);
    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : 'Failed to save brand voice. Please try again.';
      setSaveError(errorMessage);
      logger.error('‚ùå Failed to save brand voice:', error);
    }
  };

  /**
   * Handle check brand alignment
   */
  const handleCheckAlignment = async () => {
    if (!activeProject?.brandVoice) {
      // Error is already shown in UI via the warning banner
      return;
    }

    if (!selectedText) {
      return;
    }

    await runBrandAlignment(selectedText, activeProject.brandVoice);
  };

  // Check if user has text selected
  const hasSelection = selectedText && selectedText.trim().length > 0;
  const canCheck = hasSelection && activeProject?.brandVoice && !brandAlignmentLoading;

  return (
    <div className={cn('flex flex-col gap-6', className)}>
      {/* Header */}
      <div className="flex flex-col gap-2">
        <div className="flex items-center gap-2">
          <Volume2 className="w-5 h-5 text-apple-blue" />
          <h2 className="text-lg font-semibold text-apple-text-dark">
            Brand Voice
          </h2>
        </div>
        <p className="text-sm text-apple-text-light">
          Define your brand voice and check copy alignment
        </p>
        
        {/* Active Project Indicator */}
        {activeProject ? (
          <div className="flex items-center gap-2 px-3 py-2 bg-blue-50 border border-blue-200 rounded-lg">
            <Folder className="w-4 h-4 text-blue-600 flex-shrink-0" />
            <div className="flex-1 min-w-0">
              <p className="text-xs font-medium text-blue-900">
                Brand Voice for:
              </p>
              <p className="text-sm font-semibold text-blue-700 truncate">
                {activeProject.name}
              </p>
            </div>
          </div>
        ) : (
          <div className="flex items-start gap-2 px-3 py-2 bg-yellow-50 border border-yellow-200 rounded-lg">
            <AlertTriangle className="w-4 h-4 text-yellow-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-xs font-medium text-yellow-900">
                No Active Project
              </p>
              <p className="text-xs text-yellow-700 mt-0.5">
                Please create or select a project to set up brand voice
              </p>
            </div>
          </div>
        )}
      </div>

      {/* Tab Navigation */}
      <div className="flex gap-2 border-b border-gray-200">
        <button
          onClick={() => setActiveTab('setup')}
          className={cn(
            'px-4 py-2 text-sm font-medium transition-all duration-200',
            'border-b-2 focus:outline-none',
            activeTab === 'setup'
              ? 'border-apple-blue text-apple-blue'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          )}
        >
          Setup
        </button>
        <button
          onClick={() => setActiveTab('check')}
          className={cn(
            'px-4 py-2 text-sm font-medium transition-all duration-200',
            'border-b-2 focus:outline-none',
            activeTab === 'check'
              ? 'border-apple-blue text-apple-blue'
              : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
          )}
        >
          Check Copy
        </button>
      </div>

      {/* Setup Tab */}
      {activeTab === 'setup' && (
        <div className="flex flex-col gap-4">
          {/* Brand Name */}
          <div className="flex flex-col gap-1.5">
            <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide">
              Brand Name <span className="text-red-600">*</span>
            </label>
            <input
              type="text"
              value={brandName}
              onChange={(e) => setBrandName(e.target.value)}
              placeholder="Enter your brand name"
              className="px-3 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-apple-blue focus:border-transparent"
            />
          </div>

          {/* Brand Tone Description */}
          <div className="flex flex-col gap-1.5">
            <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide">
              Brand Tone Description
            </label>
            <AutoExpandTextarea
              value={brandTone}
              onChange={(e) => setBrandTone(e.target.value)}
              placeholder="e.g., Professional, friendly, innovative, approachable"
              minHeight={80}
              className="px-3 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-apple-blue focus:border-transparent"
            />
          </div>

          {/* Approved Phrases */}
          <div className="flex flex-col gap-1.5">
            <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide">
              Approved Phrases
            </label>
            <AutoExpandTextarea
              value={approvedPhrases}
              onChange={(e) => setApprovedPhrases(e.target.value)}
              placeholder="One per line"
              minHeight={80}
              className="px-3 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-apple-blue focus:border-transparent"
            />
            <p className="text-xs text-gray-500">(one per line)</p>
          </div>

          {/* Forbidden Words */}
          <div className="flex flex-col gap-1.5">
            <label className="text-xs font-medium text-red-600 uppercase tracking-wide">
              Forbidden Words
            </label>
            <AutoExpandTextarea
              value={forbiddenWords}
              onChange={(e) => setForbiddenWords(e.target.value)}
              placeholder="One per line"
              minHeight={80}
              className="px-3 py-2 text-sm border border-red-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent"
            />
            <p className="text-xs text-gray-500">(one per line)</p>
          </div>

          {/* Brand Values */}
          <div className="flex flex-col gap-1.5">
            <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide">
              Brand Values
            </label>
            <AutoExpandTextarea
              value={brandValues}
              onChange={(e) => setBrandValues(e.target.value)}
              placeholder="One per line"
              minHeight={80}
              className="px-3 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-apple-blue focus:border-transparent"
            />
            <p className="text-xs text-gray-500">(one per line)</p>
          </div>

          {/* Mission Statement */}
          <div className="flex flex-col gap-1.5">
            <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide">
              Mission Statement
            </label>
            <AutoExpandTextarea
              value={missionStatement}
              onChange={(e) => setMissionStatement(e.target.value)}
              placeholder="Our mission is to..."
              minHeight={100}
              maxHeight={300}
              className="px-3 py-2 text-sm border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-apple-blue focus:border-transparent"
            />
          </div>

          {/* Save Button */}
          <button
            onClick={handleSaveBrandVoice}
            className={cn(
              'w-full py-3 px-4 rounded-lg',
              'font-medium text-sm',
              'bg-apple-blue text-white hover:bg-blue-600',
              'transition-all duration-200 shadow-sm hover:shadow',
              'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
              'flex items-center justify-center gap-2'
            )}
          >
            <Save className="w-4 h-4" />
            Save Brand Voice
          </button>

          {/* Error Message */}
          {saveError && (
            <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
              <X className="w-4 h-4 text-red-600 flex-shrink-0 mt-0.5" />
              <div className="flex-1">
                <p className="text-sm font-medium text-red-900">Error</p>
                <p className="text-xs text-red-700 mt-1">{saveError}</p>
              </div>
              <button
                onClick={() => setSaveError(null)}
                className="text-red-600 hover:text-red-800 focus:outline-none"
                aria-label="Dismiss error"
              >
                <X className="w-4 h-4" />
              </button>
            </div>
          )}

          {/* Success Message */}
          {saveSuccess && (
            <div className="flex items-center gap-2 p-3 bg-green-50 border border-green-200 rounded-lg">
              <CheckCircle className="w-4 h-4 text-green-600 flex-shrink-0" />
              <p className="text-sm text-green-700">
                Brand voice saved successfully!
              </p>
            </div>
          )}
        </div>
      )}

      {/* Check Copy Tab */}
      {activeTab === 'check' && (
        <div className="flex flex-col gap-6">
          {/* Brand Voice Status */}
          {activeProject?.brandVoice ? (
            <div className="flex items-start gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
              <CheckCircle className="w-4 h-4 text-blue-600 flex-shrink-0 mt-0.5" />
              <div className="flex-1">
                <p className="text-sm font-medium text-blue-900">
                  Brand Voice: {activeProject.brandVoice.brandName}
                </p>
                <p className="text-xs text-blue-700 mt-0.5">
                  Ready to check copy alignment
                </p>
              </div>
            </div>
          ) : (
            <div className="flex items-start gap-2 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
              <AlertTriangle className="w-4 h-4 text-yellow-600 flex-shrink-0 mt-0.5" />
              <div className="flex-1">
                <p className="text-sm font-medium text-yellow-900">
                  No Brand Voice Set
                </p>
                <p className="text-xs text-yellow-700 mt-0.5">
                  Please set up your brand voice in the Setup tab first
                </p>
              </div>
            </div>
          )}

          {/* Selected Text Preview */}
          {hasSelection ? (
            <div className="flex flex-col gap-2">
              <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide flex items-center gap-1.5">
                <Sparkles className="w-3.5 h-3.5 text-apple-blue" />
                Selected Text ({selectedText?.length || 0} characters)
              </label>
              <div className="bg-apple-gray-bg border border-apple-gray-light rounded-lg p-3 max-h-32 overflow-y-auto custom-scrollbar">
                <p className="text-sm text-apple-text-dark whitespace-pre-wrap">
                  {selectedText}
                </p>
              </div>
            </div>
          ) : (
            <div className="flex items-center gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
              <Sparkles className="w-4 h-4 text-blue-600 flex-shrink-0" />
              <p className="text-xs text-blue-700">
                Highlight text in the editor to check alignment
              </p>
            </div>
          )}

          {/* Check Alignment Button */}
          <button
            onClick={handleCheckAlignment}
            disabled={!canCheck}
            className={cn(
              'w-full py-3 px-4 rounded-lg',
              'font-medium text-sm text-white',
              'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
              // Animated gradient when loading
              brandAlignmentLoading && 'aiworx-gradient-animated cursor-wait',
              // Brand button with blue‚Üípurple active when not loading
              !brandAlignmentLoading && (hasSelection && activeProject?.brandVoice) && 'bg-[#006EE6] hover:bg-[#0062CC] active:bg-[#7A3991] active:scale-[0.98] shadow-sm hover:shadow transition-all duration-200',
              // Gray background when truly disabled (not loading)
              (!hasSelection || !activeProject?.brandVoice) && !brandAlignmentLoading && 'bg-apple-gray-light text-apple-text-light cursor-not-allowed'
            )}
          >
            {brandAlignmentLoading ? (
              <AIWorxButtonLoader />
            ) : (
              'Check Brand Alignment'
            )}
          </button>

          {/* Error Display */}
          {brandAlignmentError && (
            <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
              <X className="w-4 h-4 text-red-600 flex-shrink-0 mt-0.5" />
              <div className="flex-1">
                <p className="text-sm font-medium text-red-900">Error</p>
                <p className="text-xs text-red-700 mt-1">{brandAlignmentError}</p>
              </div>
              <button
                onClick={clearBrandAlignmentResult}
                className="text-red-600 hover:text-red-800 focus:outline-none"
                aria-label="Dismiss error"
              >
                <X className="w-4 h-4" />
              </button>
            </div>
          )}

          {/* Results Display */}
          {brandAlignmentResult && (
            <div className="flex flex-col gap-4">
              {/* Overall Score */}
              <div className="flex flex-col gap-3 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium text-blue-900">
                    Alignment Score
                  </span>
                  <span className="text-2xl font-bold text-blue-600">
                    {brandAlignmentResult.score}%
                  </span>
                </div>
                <p className="text-sm text-blue-700">
                  {brandAlignmentResult.assessment}
                </p>
              </div>

              {/* Matches */}
              {brandAlignmentResult.matches.length > 0 && (
                <div className="flex flex-col gap-2 p-3 bg-green-50 border border-green-200 rounded-lg">
                  <div className="flex items-center gap-2">
                    <ThumbsUp className="w-4 h-4 text-green-600" />
                    <span className="text-sm font-medium text-green-900">
                      What Matches
                    </span>
                  </div>
                  <ul className="ml-6 space-y-1">
                    {brandAlignmentResult.matches.map((match: string, index: number) => (
                      <li key={index} className="text-sm text-green-700">
                        {match}
                      </li>
                    ))}
                  </ul>
                </div>
              )}

              {/* Violations */}
              {brandAlignmentResult.violations.length > 0 && (
                <div className="flex flex-col gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
                  <div className="flex items-center gap-2">
                    <ThumbsDown className="w-4 h-4 text-red-600" />
                    <span className="text-sm font-medium text-red-900">
                      What Violates
                    </span>
                  </div>
                  <ul className="ml-6 space-y-1">
                    {brandAlignmentResult.violations.map((violation: string, index: number) => (
                      <li key={index} className="text-sm text-red-700">
                        {violation}
                      </li>
                    ))}
                  </ul>
                </div>
              )}

              {/* Recommendations */}
              {brandAlignmentResult.recommendations.length > 0 && (
                <div className="flex flex-col gap-2 p-3 bg-purple-50 border border-purple-200 rounded-lg">
                  <div className="flex items-center gap-2">
                    <Lightbulb className="w-4 h-4 text-purple-600" />
                    <span className="text-sm font-medium text-purple-900">
                      Recommendations
                    </span>
                  </div>
                  <ul className="ml-6 space-y-1">
                    {brandAlignmentResult.recommendations.map((rec: string, index: number) => (
                      <li key={index} className="text-sm text-purple-700">
                        {rec}
                      </li>
                    ))}
                  </ul>
                </div>
              )}

              {/* Clear Button */}
              <button
                onClick={clearBrandAlignmentResult}
                className="w-full py-2 px-4 rounded-lg bg-gray-100 text-gray-700 text-sm font-medium hover:bg-gray-200 transition-colors duration-200"
              >
                Clear Results
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
}


=== FILE: components/workspace/BrochureMultiSectionTemplate.tsx ===

/**
 * @file components/workspace/BrochureMultiSectionTemplate.tsx
 * @description Multi-section brochure template component with progress persistence
 * 
 * Features:
 * - Section-by-section generation with context
 * - Progress persistence across sessions
 * - Resume functionality for incomplete templates
 * - Section management (view, regenerate, skip)
 * - Brand voice and persona integration
 * - Visual progress indicator
 * 
 * This component renders inline in the right sidebar, similar to TemplateGenerator.
 */

'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { logger } from '@/lib/utils/logger';
import {
  BookOpen,
  ChevronLeft,
  Sparkles,
  CheckCircle,
  Circle,
  SkipForward,
  AlertCircle,
  Play,
  RotateCcw,
  X,
  ListChecks,
  Eye,
  Clock,
} from 'lucide-react';
import { AIWorxButtonLoader } from '@/components/ui/AIWorxLoader';
import { cn } from '@/lib/utils';
import { formatGeneratedContent } from '@/lib/utils/content-formatting';
import { updateDocument as updateDocumentInStorage, getDocument, getProjectPersonas } from '@/lib/storage/unified-storage';
import { useWorkspaceStore } from '@/lib/stores/workspaceStore';
import { 
  BROCHURE_SECTIONS, 
  SECTION_SEPARATOR,
  getSectionById,
  BROCHURE_MULTI_SECTION_TEMPLATE
} from '@/lib/templates/brochure-multi-section-config';
import type { 
  TemplateProgress, 
  CompletedSection,
  TemplateSectionField 
} from '@/lib/types/template-progress';
import { createInitialProgress, generateContentHash } from '@/lib/types/template-progress';
import type { Project, Persona } from '@/lib/types/project';
import type { Editor } from '@tiptap/react';
import { AutoExpandTextarea } from '@/components/ui/AutoExpandTextarea';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/** Panel ID for slide-out */
export const BROCHURE_TEMPLATE_PANEL_ID = 'brochure-multi-section';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TYPES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

interface BrochureMultiSectionTemplateProps {
  /** Callback when template should close */
  onClose: () => void;
  
  /** TipTap editor instance */
  editor: Editor | null;
  
  /** Active project for brand voice and personas */
  activeProject: Project | null;
}

type ViewState = 'section-form' | 'section-list' | 'completed';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HELPER COMPONENTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Progress indicator showing section completion status
 */
function ProgressIndicator({ 
  currentSection, 
  totalSections, 
  completedSections 
}: { 
  currentSection: number; 
  totalSections: number;
  completedSections: string[];
}) {
  return (
    <div className="flex items-center gap-2 mb-4">
      {BROCHURE_SECTIONS.map((section, index) => {
        const isCompleted = completedSections.includes(section.id);
        const isCurrent = index === currentSection;
        const isPending = !isCompleted && index > currentSection;
        
        return (
          <React.Fragment key={section.id}>
            <div
              className={cn(
                'w-8 h-8 rounded-full flex items-center justify-center text-xs font-medium transition-all',
                isCompleted && 'bg-green-100 text-green-700 border-2 border-green-500',
                isCurrent && !isCompleted && 'bg-apple-blue text-white border-2 border-apple-blue',
                isPending && 'bg-gray-100 text-gray-400 border-2 border-gray-200'
              )}
              title={section.name}
            >
              {isCompleted ? (
                <CheckCircle className="w-4 h-4" />
              ) : (
                index + 1
              )}
            </div>
            {index < totalSections - 1 && (
              <div
                className={cn(
                  'w-8 h-0.5 transition-colors',
                  isCompleted ? 'bg-green-500' : 'bg-gray-200'
                )}
              />
            )}
          </React.Fragment>
        );
      })}
    </div>
  );
}

/**
 * Section form field renderer
 */
function SectionFormField({
  field,
  value,
  onChange,
  disabled,
  formData,
}: {
  field: TemplateSectionField;
  value: string;
  onChange: (value: string) => void;
  disabled: boolean;
  formData: Record<string, string>;
}) {
  // Handle conditional visibility
  if (field.conditionalOn) {
    const conditionValue = formData[field.conditionalOn.fieldId];
    const conditionMet = Array.isArray(field.conditionalOn.value)
      ? field.conditionalOn.value.includes(conditionValue)
      : conditionValue === field.conditionalOn.value;
    
    if (!conditionMet) return null;
  }

  const baseInputClasses = cn(
    'w-full px-3 py-2 rounded-lg border transition-all duration-200',
    'text-sm text-gray-900 bg-white',
    'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
    'disabled:bg-gray-50 disabled:opacity-50 disabled:cursor-not-allowed'
  );

  return (
    <div className="space-y-1.5">
      <label className="text-sm font-medium text-gray-900">
        {field.label}
        {field.required && <span className="text-red-500 ml-1">*</span>}
      </label>
      
      {field.type === 'textarea' ? (
        <AutoExpandTextarea
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={field.placeholder}
          disabled={disabled}
          className={baseInputClasses}
          minHeight={80}
          maxHeight={200}
          maxLength={field.maxLength}
        />
      ) : field.type === 'select' ? (
        <select
          value={value}
          onChange={(e) => onChange(e.target.value)}
          disabled={disabled}
          className={baseInputClasses}
        >
          <option value="">Select an option...</option>
          {field.options?.map((option) => (
            <option key={option} value={option}>
              {option}
            </option>
          ))}
        </select>
      ) : (
        <input
          type={field.type === 'number' ? 'number' : 'text'}
          value={value}
          onChange={(e) => onChange(e.target.value)}
          placeholder={field.placeholder}
          disabled={disabled}
          className={baseInputClasses}
          maxLength={field.maxLength}
        />
      )}
      
      {field.helperText && (
        <p className="text-xs text-gray-500">{field.helperText}</p>
      )}
      
      {field.maxLength && value.length > 0 && (
        <p className={cn(
          'text-xs text-right',
          value.length > field.maxLength * 0.9 ? 'text-amber-500' : 'text-gray-400'
        )}>
          {value.length}/{field.maxLength}
        </p>
      )}
    </div>
  );
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export function BrochureMultiSectionTemplate({
  onClose,
  editor,
  activeProject,
}: BrochureMultiSectionTemplateProps) {
  const activeDocumentId = useWorkspaceStore((state) => state.activeDocumentId);
  const activeProjectId = useWorkspaceStore((state) => state.activeProjectId);
  
  // Template state
  const [progress, setProgress] = useState<TemplateProgress | null>(null);
  const [formData, setFormData] = useState<Record<string, string>>({});
  const [viewState, setViewState] = useState<ViewState>('section-form');
  
  // Settings state
  const [applyBrandVoice, setApplyBrandVoice] = useState(false);
  const [selectedPersonaId, setSelectedPersonaId] = useState<string | null>(null);
  
  // Generation state
  const [isGenerating, setIsGenerating] = useState(false);
  const [generationError, setGenerationError] = useState<string | null>(null);
  
  // Personas state
  const [personas, setPersonas] = useState<Persona[]>([]);
  
  const hasBrandVoice = activeProject?.brandVoice?.brandName ? true : false;
  
  // Current section
  const currentSection = progress ? BROCHURE_SECTIONS[progress.currentSection] : BROCHURE_SECTIONS[0];
  
  /**
   * Load or initialize template progress from document
   */
  useEffect(() => {
    const loadProgress = async () => {
      logger.log('üîÑ BrochureMultiSectionTemplate: Checking progress...', {
        activeDocumentId,
        activeProjectId,
        hasProgress: !!progress
      });
      
      if (!activeDocumentId || !activeProjectId) {
        logger.warn('‚ö†Ô∏è Missing activeDocumentId or activeProjectId', {
          activeDocumentId,
          activeProjectId
        });
        return;
      }
      
      const doc = await getDocument(activeProjectId, activeDocumentId);
      if (!doc) {
        logger.error('‚ùå Document not found:', activeDocumentId);
        return;
      }
      
      logger.log('üìÑ Document loaded:', {
        id: doc.id,
        title: doc.title,
        hasTemplateProgress: !!doc.templateProgress
      });
    
    if (doc.templateProgress && doc.templateProgress.templateId === 'brochure-multi-section') {
      // Resume existing progress
      logger.log('üîÑ Resuming existing template progress');
      const loadedProgress = doc.templateProgress;
      setProgress(loadedProgress);
      setApplyBrandVoice(loadedProgress.applyBrandVoice || false);
      setSelectedPersonaId(loadedProgress.selectedPersonaId || null);
      
      // If complete, show completion view
      if (loadedProgress.isComplete) {
        logger.log('‚úÖ Template is complete');
        setViewState('completed');
      }
      
      // Load form data for current section
      const currentSectionIndex = loadedProgress.currentSection;
      const section = BROCHURE_SECTIONS[currentSectionIndex];
      
      if (section) {
        logger.log('üìù Loading form data for section:', section.name);
        // Check if we have saved form data for this section
        if (loadedProgress.sectionData[section.id]?.formData) {
          setFormData(loadedProgress.sectionData[section.id].formData);
        } else {
          // Initialize with empty values
          const initialData: Record<string, string> = {};
          section.fields.forEach((field) => {
            initialData[field.id] = '';
          });
          setFormData(initialData);
        }
      }
    } else {
      // Initialize new progress
      logger.log('‚ú® Initializing new template progress');
      const newProgress = createInitialProgress(
        'brochure-multi-section',
        BROCHURE_SECTIONS.length
      );
      setProgress(newProgress);
      logger.log('‚úÖ Progress initialized:', newProgress);
      
      // Initialize form data for first section
      const section = BROCHURE_SECTIONS[0];
      if (section) {
        logger.log('üìù Initializing empty form data for first section:', section.name);
        const initialData: Record<string, string> = {};
        section.fields.forEach((field) => {
          initialData[field.id] = '';
        });
        setFormData(initialData);
      }
    }
    };
    
    loadProgress();
  }, [activeDocumentId, activeProjectId]);
  
  /**
   * Load personas for current project
   */
  useEffect(() => {
    const loadPersonas = async () => {
      if (!activeProject) {
        setPersonas([]);
        return;
      }
      
      try {
        const projectPersonas = await getProjectPersonas(activeProject.id);
        setPersonas(projectPersonas);
      } catch (error) {
        logger.error('‚ùå Failed to load personas:', error);
        setPersonas([]);
      }
    };
    
    loadPersonas();
  }, [activeProject]);
  
  /**
   * Initialize form data for a section
   * Loads saved data if available, otherwise initializes with empty values
   */
  const initializeFormData = useCallback((sectionIndex: number, currentProgress: TemplateProgress | null) => {
    const section = BROCHURE_SECTIONS[sectionIndex];
    if (!section) {
      logger.warn('‚ö†Ô∏è Section not found for index:', sectionIndex);
      return;
    }
    
    // Check if we have saved form data for this section
    if (currentProgress?.sectionData[section.id]?.formData) {
      logger.log('‚úÖ Loading saved form data for section:', section.name);
      setFormData(currentProgress.sectionData[section.id].formData);
    } else {
      logger.log('üìù Initializing empty form data for section:', section.name);
      // Initialize with empty values
      const initialData: Record<string, string> = {};
      section.fields.forEach((field) => {
        initialData[field.id] = '';
      });
      setFormData(initialData);
    }
  }, []);
  
  /**
   * Save progress to document storage
   */
  const saveProgress = useCallback((updatedProgress: TemplateProgress) => {
    if (!activeProjectId || !activeDocumentId) return;
    
    try {
      updateDocumentInStorage(activeProjectId, activeDocumentId, {
        templateProgress: updatedProgress,
      });
      setProgress(updatedProgress);
    } catch (error) {
      logger.error('‚ùå Failed to save template progress:', error);
    }
  }, [activeProjectId, activeDocumentId]);
  
  /**
   * Update document content with all generated sections
   */
  const updateDocumentContent = useCallback((updatedProgress: TemplateProgress) => {
    if (!activeProjectId || !activeDocumentId || !editor) return;
    
    // Build content from all completed sections
    const contentParts: string[] = [];
    
    BROCHURE_SECTIONS.forEach((section) => {
      const sectionData = updatedProgress.sectionData[section.id];
      if (sectionData?.generatedContent) {
        // Add section header
        contentParts.push(`<h2>${section.name}</h2>`);
        contentParts.push(sectionData.generatedContent);
      }
    });
    
    const fullContent = contentParts.join(SECTION_SEPARATOR);
    
    // Update editor
    editor.commands.setContent(fullContent);
    
    // Save to storage
    try {
      updateDocumentInStorage(activeProjectId, activeDocumentId, {
        content: fullContent,
      });
    } catch (error) {
      logger.error('‚ùå Failed to save document content:', error);
    }
  }, [activeProjectId, activeDocumentId, editor]);
  
  /**
   * Get previous content for context
   */
  const getPreviousContent = useCallback((): string => {
    if (!progress) return '';
    
    const contentParts: string[] = [];
    
    BROCHURE_SECTIONS.forEach((section, index) => {
      if (index < (progress.currentSection || 0)) {
        const sectionData = progress.sectionData[section.id];
        if (sectionData?.generatedContent) {
          contentParts.push(`=== ${section.name} ===\n${sectionData.generatedContent}`);
        }
      }
    });
    
    return contentParts.join('\n\n');
  }, [progress]);
  
  /**
   * Handle form field change
   */
  const handleFieldChange = useCallback((fieldId: string, value: string) => {
    setFormData((prev) => ({ ...prev, [fieldId]: value }));
    setGenerationError(null);
  }, []);
  
  /**
   * Validate current section form
   */
  const validateForm = useCallback((): boolean => {
    if (!currentSection) return false;
    
    for (const field of currentSection.fields) {
      if (!field.required) continue;
      
      // Handle conditional fields
      if (field.conditionalOn) {
        const conditionValue = formData[field.conditionalOn.fieldId];
        const conditionMet = Array.isArray(field.conditionalOn.value)
          ? field.conditionalOn.value.includes(conditionValue)
          : conditionValue === field.conditionalOn.value;
        
        if (!conditionMet) continue;
      }
      
      const value = formData[field.id]?.trim();
      if (!value) {
        setGenerationError(`Please fill in: ${field.label}`);
        return false;
      }
    }
    
    return true;
  }, [currentSection, formData]);
  
  /**
   * Generate current section
   */
  const handleGenerate = useCallback(async () => {
    if (!progress || !currentSection || !editor || !activeProjectId || !activeDocumentId) return;
    
    if (!validateForm()) return;
    
    setIsGenerating(true);
    setGenerationError(null);
    
    try {
      // Get persona data if selected
      const selectedPersona = selectedPersonaId 
        ? personas.find((p) => p.id === selectedPersonaId) 
        : undefined;
      
      // Build request
      const requestBody = {
        templateId: 'brochure-multi-section',
        sectionId: currentSection.id,
        sectionIndex: progress.currentSection,
        formData,
        previousContent: getPreviousContent(),
        applyBrandVoice,
        brandVoice: applyBrandVoice && activeProject?.brandVoice ? {
          brandName: activeProject.brandVoice.brandName,
          brandTone: activeProject.brandVoice.brandTone,
          approvedPhrases: activeProject.brandVoice.approvedPhrases,
          forbiddenWords: activeProject.brandVoice.forbiddenWords,
          brandValues: activeProject.brandVoice.brandValues,
          missionStatement: activeProject.brandVoice.missionStatement,
        } : undefined,
        persona: selectedPersona ? {
          name: selectedPersona.name,
          demographics: selectedPersona.demographics,
          psychographics: selectedPersona.psychographics,
          painPoints: selectedPersona.painPoints,
          languagePatterns: selectedPersona.languagePatterns,
          goals: selectedPersona.goals,
        } : undefined,
      };
      
      // Call API
      const response = await fetch('/api/generate-section', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to generate section');
      }
      
      const data = await response.json();
      const generatedContent = formatGeneratedContent(data.generatedContent);
      
      // Create completed section data
      const completedSection: CompletedSection = {
        sectionId: currentSection.id,
        formData: { ...formData },
        generatedContent,
        completedAt: new Date().toISOString(),
        wasModified: false,
        contentHash: generateContentHash(generatedContent),
      };
      
      // Update progress
      const updatedProgress: TemplateProgress = {
        ...progress,
        completedSections: [...progress.completedSections, currentSection.id],
        sectionData: {
          ...progress.sectionData,
          [currentSection.id]: completedSection,
        },
        currentSection: progress.currentSection + 1,
        applyBrandVoice,
        selectedPersonaId: selectedPersonaId || undefined,
      };
      
      // Check if complete
      if (updatedProgress.currentSection >= BROCHURE_SECTIONS.length) {
        updatedProgress.isComplete = true;
        updatedProgress.completedAt = new Date().toISOString();
      }
      
      // Save progress and update document
      saveProgress(updatedProgress);
      updateDocumentContent(updatedProgress);
      
      // Move to next section or show completion
      if (updatedProgress.isComplete) {
        setViewState('completed');
      } else {
        initializeFormData(updatedProgress.currentSection, updatedProgress);
      }
      
    } catch (error) {
      logger.error('‚ùå Section generation error:', error);
      setGenerationError(
        error instanceof Error ? error.message : 'Failed to generate section'
      );
    } finally {
      setIsGenerating(false);
    }
  }, [
    progress, 
    currentSection, 
    editor, 
    activeProjectId, 
    activeDocumentId,
    validateForm, 
    formData, 
    selectedPersonaId, 
    personas, 
    applyBrandVoice, 
    activeProject,
    getPreviousContent,
    saveProgress,
    updateDocumentContent,
    initializeFormData
  ]);
  
  /**
   * Skip current section
   */
  const handleSkip = useCallback(() => {
    if (!progress) return;
    
    const nextSection = progress.currentSection + 1;
    
    const updatedProgress: TemplateProgress = {
      ...progress,
      currentSection: nextSection,
    };
    
    if (nextSection >= BROCHURE_SECTIONS.length) {
      updatedProgress.isComplete = true;
      updatedProgress.completedAt = new Date().toISOString();
      setViewState('completed');
    } else {
      initializeFormData(nextSection, updatedProgress);
    }
    
    saveProgress(updatedProgress);
  }, [progress, saveProgress, initializeFormData]);
  
  /**
   * Go to previous section
   */
  const handlePrevious = useCallback(() => {
    if (!progress || progress.currentSection === 0) return;
    
    const prevSection = progress.currentSection - 1;
    
    const updatedProgress: TemplateProgress = {
      ...progress,
      currentSection: prevSection,
      isComplete: false,
      completedAt: undefined,
    };
    
    saveProgress(updatedProgress);
    initializeFormData(prevSection, updatedProgress);
    setViewState('section-form');
  }, [progress, saveProgress, initializeFormData]);
  
  /**
   * Regenerate a specific section
   */
  const handleRegenerateSection = useCallback(async (sectionId: string) => {
    if (!progress) return;
    
    const sectionIndex = BROCHURE_SECTIONS.findIndex(s => s.id === sectionId);
    if (sectionIndex === -1) return;
    
    // Update progress to that section
    const updatedProgress: TemplateProgress = {
      ...progress,
      currentSection: sectionIndex,
      isComplete: false,
      completedAt: undefined,
    };
    
    saveProgress(updatedProgress);
    
    // Load the section's form data (will load saved data if available)
    initializeFormData(sectionIndex, updatedProgress);
    
    setViewState('section-form');
  }, [progress, saveProgress, initializeFormData]);
  
  /**
   * Exit template mode - closes UI but KEEPS progress for resume
   */
  const handleExitTemplate = useCallback(() => {
    const confirmed = window.confirm(
      'Close template? Your progress will be saved and you can resume later from the document.'
    );
    
    if (!confirmed) return;
    
    // Just close the template UI - progress stays in document
    logger.log('üö™ Closing template UI - progress saved for resume');
    
    // Clear selectedTemplateId so resume banner can show
    useWorkspaceStore.getState().setSelectedTemplateId(null);
    
    onClose();
  }, [onClose]);
  
  /**
   * Delete template progress completely
   */
  const handleDeleteProgress = useCallback(() => {
    if (!activeProjectId || !activeDocumentId) return;
    
    const confirmed = window.confirm(
      'Delete template progress? Your generated sections will be kept, but you won\'t be able to continue the template workflow.'
    );
    
    if (!confirmed) return;
    
    try {
      updateDocumentInStorage(activeProjectId, activeDocumentId, {
        templateProgress: undefined,
      });
      logger.log('üóëÔ∏è Template progress deleted');
    } catch (error) {
      logger.error('‚ùå Failed to delete template progress:', error);
    }
    
    onClose();
  }, [activeProjectId, activeDocumentId, onClose]);
  
  /**
   * Finish and close
   */
  const handleFinish = useCallback(() => {
    if (!progress) return;
    
    const updatedProgress: TemplateProgress = {
      ...progress,
      isComplete: true,
      completedAt: new Date().toISOString(),
    };
    
    saveProgress(updatedProgress);
    
    // Clear template state from store
    useWorkspaceStore.getState().setSelectedTemplateId(null);
    
    onClose();
  }, [progress, saveProgress, onClose]);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // RENDER HELPERS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  /**
   * Render section list view
   */
  const renderSectionList = () => (
    <div className="space-y-3">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold text-gray-900">Template Sections</h3>
        <button
          onClick={() => setViewState('section-form')}
          className="text-sm text-apple-blue hover:underline"
        >
          Back to Form
        </button>
      </div>
      
      {BROCHURE_SECTIONS.map((section, index) => {
        const isCompleted = progress?.completedSections.includes(section.id);
        const isCurrent = index === progress?.currentSection;
        
        return (
          <div
            key={section.id}
            className={cn(
              'p-4 rounded-lg border transition-colors',
              isCompleted && 'bg-green-50 border-green-200',
              isCurrent && !isCompleted && 'bg-blue-50 border-blue-200',
              !isCompleted && !isCurrent && 'bg-gray-50 border-gray-200'
            )}
          >
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                {isCompleted ? (
                  <CheckCircle className="w-5 h-5 text-green-600" />
                ) : isCurrent ? (
                  <Play className="w-5 h-5 text-apple-blue" />
                ) : (
                  <Circle className="w-5 h-5 text-gray-400" />
                )}
                <div>
                  <p className="font-medium text-gray-900">{section.name}</p>
                  <p className="text-xs text-gray-500">
                    {isCompleted ? 'Completed' : isCurrent ? 'Current' : 'Pending'}
                  </p>
                </div>
              </div>
              
              {isCompleted && (
                <button
                  onClick={() => handleRegenerateSection(section.id)}
                  className={cn(
                    'px-3 py-1.5 rounded-md text-sm font-medium',
                    'border border-gray-300 text-gray-700 bg-white',
                    'hover:bg-gray-50 transition-colors duration-200',
                    'flex items-center gap-1'
                  )}
                >
                  <RotateCcw className="w-3.5 h-3.5" />
                  Regenerate
                </button>
              )}
            </div>
          </div>
        );
      })}
    </div>
  );
  
  /**
   * Render completion view
   */
  const renderCompletion = () => (
    <div className="text-center py-8">
      <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-green-100 flex items-center justify-center">
        <CheckCircle className="w-8 h-8 text-green-600" />
      </div>
      <h3 className="text-xl font-semibold text-gray-900 mb-2">
        Brochure Complete!
      </h3>
      <p className="text-gray-600 mb-6">
        All sections have been generated. Your brochure is ready for review and editing.
      </p>
      
      <div className="space-y-3">
        <button
          onClick={handleFinish}
          className={cn(
            'w-full py-2.5 px-4 rounded-lg font-medium text-sm text-white',
            'bg-green-500 hover:bg-green-600 transition-colors duration-200',
            'focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2'
          )}
        >
          Finish & Close
        </button>
        <button
          onClick={() => setViewState('section-list')}
          className={cn(
            'w-full py-2.5 px-4 rounded-lg font-medium text-sm',
            'border border-gray-300 text-gray-700 bg-white',
            'hover:bg-gray-50 transition-colors duration-200',
            'flex items-center justify-center gap-2'
          )}
        >
          <Eye className="w-4 h-4" />
          View Sections
        </button>
      </div>
    </div>
  );
  
  /**
   * Render section form
   */
  const renderSectionForm = () => {
    if (!currentSection || !progress) return null;
    
    return (
      <div className="space-y-6">
        {/* Section header */}
        <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
          <div className="flex items-start gap-3">
            <div className="flex-shrink-0 w-10 h-10 rounded-lg bg-apple-blue flex items-center justify-center">
              <BookOpen className="w-5 h-5 text-white" />
            </div>
            <div className="flex-1">
              <h3 className="font-semibold text-gray-900">
                Section {progress.currentSection + 1} of {BROCHURE_SECTIONS.length}: {currentSection.name}
              </h3>
              {currentSection.description && (
                <p className="text-sm text-blue-700 mt-1">
                  {currentSection.description}
                </p>
              )}
            </div>
          </div>
        </div>
        
        {/* Progress indicator */}
        <ProgressIndicator
          currentSection={progress.currentSection}
          totalSections={BROCHURE_SECTIONS.length}
          completedSections={progress.completedSections}
        />
        
        {/* Error display */}
        {generationError && (
          <div className="p-4 bg-red-50 border border-red-200 rounded-lg flex items-start gap-3">
            <AlertCircle className="w-5 h-5 text-red-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-sm font-medium text-red-900">Generation Failed</p>
              <p className="text-sm text-red-700">{generationError}</p>
            </div>
            <button onClick={() => setGenerationError(null)}>
              <X className="w-4 h-4 text-red-600" />
            </button>
          </div>
        )}
        
        {/* Brand voice toggle (first section only) */}
        {progress.currentSection === 0 && hasBrandVoice && (
          <div className="p-4 border border-gray-200 rounded-lg">
            <label className="flex items-start gap-3 cursor-pointer group">
              <input
                type="checkbox"
                checked={applyBrandVoice}
                onChange={(e) => setApplyBrandVoice(e.target.checked)}
                disabled={isGenerating}
                className="mt-0.5 h-4 w-4 rounded border-gray-300 text-apple-blue focus:ring-apple-blue"
              />
              <div className="flex-1">
                <span className="text-sm font-medium text-gray-900">
                  Apply Brand Voice
                </span>
                <p className="text-xs text-gray-500 mt-0.5">
                  Use {activeProject?.brandVoice?.brandName}'s guidelines for all sections
                </p>
              </div>
            </label>
          </div>
        )}
        
        {/* Persona selector (first section only) */}
        {progress.currentSection === 0 && personas.length > 0 && (
          <div className="space-y-2">
            <label className="text-sm font-medium text-gray-900">
              Target Persona (Optional)
            </label>
            <select
              value={selectedPersonaId || ''}
              onChange={(e) => setSelectedPersonaId(e.target.value || null)}
              disabled={isGenerating}
              className={cn(
                'w-full px-3 py-2 rounded-lg border transition-all duration-200',
                'text-sm text-gray-900 bg-white',
                'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2'
              )}
            >
              <option value="">No specific persona</option>
              {personas.map((persona) => (
                <option key={persona.id} value={persona.id}>
                  {persona.name}
                </option>
              ))}
            </select>
          </div>
        )}
        
        {/* Section form fields */}
        <div className="space-y-4">
          {currentSection.fields.map((field) => (
            <SectionFormField
              key={field.id}
              field={field}
              value={formData[field.id] || ''}
              onChange={(value) => handleFieldChange(field.id, value)}
              disabled={isGenerating}
              formData={formData}
            />
          ))}
        </div>
      </div>
    );
  };

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // MAIN RENDER
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  return (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div className="flex-shrink-0 bg-gradient-to-r from-purple-500 to-purple-600 text-white p-4 rounded-t-lg">
        <div className="flex items-start justify-between mb-3">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 bg-white/20 rounded-lg flex items-center justify-center">
              <BookOpen className="w-6 h-6" />
            </div>
            <div>
              <h2 className="text-lg font-semibold">{BROCHURE_MULTI_SECTION_TEMPLATE.name}</h2>
              <p className="text-sm text-purple-100 mt-0.5">{BROCHURE_MULTI_SECTION_TEMPLATE.description}</p>
            </div>
          </div>
          <button
            onClick={() => {
              logger.log('‚ùå Closing template - progress will be saved');
              // Clear selectedTemplateId so resume banner can show
              useWorkspaceStore.getState().setSelectedTemplateId(null);
              onClose();
            }}
            className="p-1 hover:bg-white/20 rounded transition-colors"
            aria-label="Close"
            title="Close template (progress saved)"
          >
            <X className="w-5 h-5" />
          </button>
        </div>
        
        {/* Meta info */}
        <div className="flex items-center gap-3 text-sm">
          <span className="px-2 py-0.5 rounded border bg-white/10 border-white/20">
            {BROCHURE_MULTI_SECTION_TEMPLATE.complexity}
          </span>
          <div className="flex items-center gap-1.5">
            <Clock className="w-4 h-4" />
            <span>{BROCHURE_MULTI_SECTION_TEMPLATE.estimatedTime}</span>
          </div>
        </div>
      </div>
      
      {/* Content - scrollable */}
      <div className="flex-1 overflow-y-auto custom-scrollbar p-4">
        {/* Show message if no document is open */}
        {!activeDocumentId ? (
          <div className="text-center py-12">
            <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-amber-100 flex items-center justify-center">
              <AlertCircle className="w-8 h-8 text-amber-600" />
            </div>
            <h3 className="text-lg font-semibold text-gray-900 mb-2">
              No Document Selected
            </h3>
            <p className="text-sm text-gray-600 mb-4 max-w-xs mx-auto">
              Please create or select a document first to use the multi-section brochure template.
            </p>
            <button
              onClick={onClose}
              className={cn(
                'px-4 py-2 rounded-lg font-medium text-sm',
                'border border-gray-300 text-gray-700 bg-white',
                'hover:bg-gray-50 transition-colors duration-200'
              )}
            >
              Close
            </button>
          </div>
        ) : !progress ? (
          <div className="text-center py-12">
            <div className="w-8 h-8 mx-auto mb-4 border-2 border-purple-500 border-t-transparent rounded-full animate-spin" />
            <p className="text-sm text-gray-600">Loading template...</p>
          </div>
        ) : (
          <>
            {viewState === 'section-list' && renderSectionList()}
            {viewState === 'completed' && renderCompletion()}
            {viewState === 'section-form' && renderSectionForm()}
          </>
        )}
      </div>
      
      {/* Footer with action buttons */}
      <div className="flex-shrink-0 p-4 border-t border-gray-200 space-y-2">
        {viewState === 'completed' ? (
          <button
            onClick={handleFinish}
            className={cn(
              'w-full py-3 px-4 rounded-lg font-medium text-sm text-white',
              'bg-green-500 hover:bg-green-600',
              'focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2',
              'flex items-center justify-center gap-2'
            )}
          >
            <CheckCircle className="w-5 h-5" />
            Finish & Close
          </button>
        ) : viewState === 'section-list' ? (
          <button
            onClick={() => setViewState('section-form')}
            className={cn(
              'w-full py-2 px-4 rounded-lg font-medium text-sm',
              'border border-gray-300 text-gray-700 bg-white',
              'hover:bg-gray-50 transition-colors duration-200'
            )}
          >
            Back to Current Section
          </button>
        ) : (
          <>
            <div className="flex gap-2">
              {progress && progress.currentSection > 0 && (
                <button
                  onClick={handlePrevious}
                  disabled={isGenerating}
                  className={cn(
                    'px-3 py-2.5 rounded-lg font-medium text-sm flex-shrink-0',
                    'border border-gray-300 text-gray-700 bg-white',
                    'hover:bg-gray-50 transition-colors duration-200',
                    'disabled:opacity-50 disabled:cursor-not-allowed',
                    'flex items-center gap-1'
                  )}
                >
                  <ChevronLeft className="w-4 h-4" />
                  Prev
                </button>
              )}
              
              <button
                onClick={handleGenerate}
                disabled={isGenerating || !editor || !activeProject}
                className={cn(
                  'flex-1 py-2.5 px-4 rounded-lg font-medium text-sm text-white',
                  'focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2',
                  'flex items-center justify-center gap-2',
                  isGenerating && 'aiworx-gradient-animated cursor-wait',
                  !isGenerating && 'bg-purple-500 hover:bg-purple-600 transition-colors duration-200'
                )}
              >
                {isGenerating ? (
                  <AIWorxButtonLoader />
                ) : (
                  <>
                    <Sparkles className="w-4 h-4" />
                    Generate Section
                  </>
                )}
              </button>
              
              <button
                onClick={handleSkip}
                disabled={isGenerating}
                className={cn(
                  'px-3 py-2.5 rounded-lg font-medium text-sm flex-shrink-0',
                  'border border-gray-300 text-gray-700 bg-white',
                  'hover:bg-gray-50 transition-colors duration-200',
                  'disabled:opacity-50 disabled:cursor-not-allowed'
                )}
                title="Skip this section"
              >
                <SkipForward className="w-4 h-4" />
              </button>
            </div>
            
            <div className="flex gap-2">
              <button
                onClick={() => setViewState('section-list')}
                className="flex-1 text-xs text-gray-600 hover:text-gray-800 py-1.5 flex items-center justify-center gap-1"
              >
                <ListChecks className="w-3 h-3" />
                View All Sections
              </button>
              <button
                onClick={handleExitTemplate}
                className="flex-1 text-xs text-red-600 hover:text-red-700 py-1.5 flex items-center justify-center gap-1"
              >
                <X className="w-3 h-3" />
                Exit Template Mode
              </button>
            </div>
          </>
        )}
      </div>
    </div>
  );
}


=== FILE: components/workspace/DeleteProjectModal.tsx ===

/**
 * @file components/workspace/DeleteProjectModal.tsx
 * @description Confirmation modal for deleting a project
 * 
 * Features:
 * - Clear warning about permanent deletion
 * - Shows project name in confirmation message
 * - Destructive action styling (red Delete button)
 * - Prevents deletion while save operation is in progress
 * - ESC key to cancel, click outside to cancel
 * 
 * @example
 * ```tsx
 * <DeleteProjectModal
 *   isOpen={showDeleteModal}
 *   projectName="Marketing Campaign"
 *   onClose={() => setShowDeleteModal(false)}
 *   onConfirm={() => handleDeleteProject()}
 *   isDeleting={isDeleting}
 * />
 * ```
 */

'use client';

import React, { useEffect, useState, useCallback } from 'react';
import { createPortal } from 'react-dom';
import { AlertTriangle, X, Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';

// ============================================================================
// Types
// ============================================================================

export interface DeleteProjectModalProps {
  /** Whether the modal is open */
  isOpen: boolean;
  /** Name of the project being deleted */
  projectName: string;
  /** Callback when modal should close (cancel) */
  onClose: () => void;
  /** Callback when delete is confirmed */
  onConfirm: () => void;
  /** Whether deletion is in progress */
  isDeleting?: boolean;
  /** Whether a save operation is in progress (prevents deletion) */
  isSaving?: boolean;
}

// ============================================================================
// Component
// ============================================================================

/**
 * DeleteProjectModal - Confirmation dialog for project deletion
 * 
 * Shows a clear warning about permanent deletion with the project name.
 * Uses portal to render above all other content.
 */
export function DeleteProjectModal({
  isOpen,
  projectName,
  onClose,
  onConfirm,
  isDeleting = false,
  isSaving = false,
}: DeleteProjectModalProps) {
  const [isMounted, setIsMounted] = useState(false);
  
  // Handle mount state for SSR compatibility
  useEffect(() => {
    setIsMounted(true);
  }, []);
  
  // Handle ESC key to close
  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (e.key === 'Escape' && isOpen && !isDeleting) {
      onClose();
    }
  }, [isOpen, isDeleting, onClose]);
  
  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleKeyDown]);
  
  // Prevent body scroll when modal is open
  useEffect(() => {
    if (isOpen) {
      const originalOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
      return () => {
        document.body.style.overflow = originalOverflow;
      };
    }
  }, [isOpen]);
  
  // Handle backdrop click
  const handleBackdropClick = useCallback((e: React.MouseEvent) => {
    if (e.target === e.currentTarget && !isDeleting) {
      onClose();
    }
  }, [isDeleting, onClose]);
  
  // Don't render on server or when not mounted/closed
  if (!isMounted || !isOpen) {
    return null;
  }
  
  const modalContent = (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center"
      onClick={handleBackdropClick}
      role="dialog"
      aria-modal="true"
      aria-labelledby="delete-modal-title"
    >
      {/* Backdrop */}
      <div 
        className="absolute inset-0 bg-black/50 transition-opacity"
        aria-hidden="true"
      />
      
      {/* Modal */}
      <div
        className={cn(
          'relative bg-white rounded-xl shadow-2xl',
          'w-full max-w-md mx-4',
          'transform transition-all duration-200',
          'animate-in fade-in-0 zoom-in-95'
        )}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-red-100 rounded-lg">
              <AlertTriangle className="h-5 w-5 text-red-600" />
            </div>
            <h2 
              id="delete-modal-title"
              className="text-lg font-semibold text-gray-900"
            >
              Delete Project
            </h2>
          </div>
          <button
            onClick={onClose}
            disabled={isDeleting}
            className={cn(
              'p-2 rounded-lg text-gray-400',
              'hover:text-gray-600 hover:bg-gray-100',
              'transition-colors',
              'disabled:opacity-50 disabled:cursor-not-allowed'
            )}
            aria-label="Close"
          >
            <X className="h-5 w-5" />
          </button>
        </div>
        
        {/* Content */}
        <div className="px-6 py-5">
          <p className="text-gray-700 mb-2">
            Delete <span className="font-semibold text-gray-900">"{projectName}"</span>?
          </p>
          <p className="text-sm text-gray-500 mb-6">
            This will permanently delete this project and all its documents. 
            This cannot be undone.
          </p>
          
          {/* Save in progress warning */}
          {isSaving && (
            <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
              <p className="text-sm text-yellow-800 flex items-center gap-2">
                <Loader2 className="h-4 w-4 animate-spin" />
                Please wait for the save operation to complete before deleting.
              </p>
            </div>
          )}
          
          {/* Action buttons */}
          <div className="flex gap-3 justify-end">
            <Button
              variant="outline"
              onClick={onClose}
              disabled={isDeleting}
              className="px-4"
            >
              Cancel
            </Button>
            <Button
              onClick={onConfirm}
              disabled={isDeleting || isSaving}
              className={cn(
                'px-4 bg-red-600 hover:bg-red-700 text-white',
                'focus:ring-red-500',
                'disabled:opacity-50 disabled:cursor-not-allowed'
              )}
            >
              {isDeleting ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Deleting...
                </>
              ) : (
                'Delete Project'
              )}
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
  
  return createPortal(modalContent, document.body);
}

export default DeleteProjectModal;


=== FILE: components/workspace/DocumentList.tsx ===

/**
 * @file components/workspace/DocumentList.tsx
 * @description Context-aware document list with folder tree view and version control
 * 
 * Features:
 * - Folder tree view with collapsible folders and highly visible tree connector lines
 * - Nested folder support (folders within folders)
 * - Clear visual hierarchy with proper indentation
 * - Dynamic header showing active project name
 * - Full document titles (baseTitle + version)
 * - Collapsible version groups (shows latest by default)
 * - Individual document rename (creates new document family)
 * - Hover-to-reveal actions
 * - Selected document highlighting
 * - Auto-refresh after all operations
 */

'use client';

import React, { useState, useEffect, useCallback, useRef } from 'react';
import type { ProjectDocument, Folder, Project } from '@/lib/types/project';
import { useActiveProjectId, useProjects } from '@/lib/stores/workspaceStore';
import {
  DndContext,
  DragEndEvent,
  DragOverlay,
  DragStartEvent,
  PointerSensor,
  useSensor,
  useSensors,
  useDraggable,
  useDroppable,
} from '@dnd-kit/core';
import {
  getAllDocuments,
  createDocument,
  deleteDocument,
  renameDocument,
  updateDocument,
  getAllFolders,
  createFolder,
  deleteFolder,
  moveFolder,
  updateFolder,
} from '@/lib/storage/unified-storage';
import { 
  FileText, 
  FilePlus,
  Trash2, 
  ChevronRight, 
  Pencil, 
  Folder as FolderIcon,
  FolderPlus,
  FolderInput,
  Home,
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';
import { logger } from '@/lib/utils/logger';

// ============================================================================
// Types
// ============================================================================

interface DocumentListProps {
  /** Callback when user clicks a document to load it in the editor */
  onDocumentClick: (doc: ProjectDocument) => void;
}

// ============================================================================
// DraggableDocumentRow - Standalone Component (extracted to prevent re-renders)
// ============================================================================

interface DraggableDocumentRowProps {
  doc: ProjectDocument;
  showConnector?: boolean;
  selectedDocId: string | null;
  onSaveRename: (newTitle: string) => void;
  onSelect: (doc: ProjectDocument) => void;
  onDelete: (doc: ProjectDocument) => void;
  onMoveToRoot: (docId: string) => void;
}

/**
 * Individual draggable document row - simplified with window.prompt for rename
 */
const DraggableDocumentRow = React.memo(({
  doc,
  showConnector = false,
  selectedDocId,
  onSaveRename,
  onSelect,
  onDelete,
  onMoveToRoot,
}: DraggableDocumentRowProps) => {
  const { attributes, listeners, setNodeRef, isDragging } = useDraggable({
    id: `document:${doc.id}`,
  });
  
  const isSelected = doc.id === selectedDocId;
  
  return (
    <div
      ref={setNodeRef}
      style={{ opacity: isDragging ? 0.5 : 1 }}
      className={cn(
        'group flex items-start gap-1.5 px-2 py-1.5 rounded cursor-pointer',
        'transition-colors duration-100',
        isSelected
          ? 'bg-primary/10 text-primary'
          : 'hover:bg-accent/60'
      )}
      onClick={(e) => {
        e.stopPropagation();
        onSelect(doc);
      }}
    >
      {/* Horizontal connector line */}
      {showConnector && (
        <div className="w-3 h-px bg-foreground/30 -ml-2 flex-shrink-0" />
      )}
      
      {/* Drag handle */}
      <div {...attributes} {...listeners} className="cursor-grab active:cursor-grabbing">
        <FileText className={cn(
          'h-3 w-3 flex-shrink-0',
          isSelected ? 'text-primary' : 'text-muted-foreground'
        )} />
      </div>
      
      {/* Title */}
      <span
        className={cn(
          'flex-1 text-xs leading-tight line-clamp-2',
          isSelected ? 'font-medium text-primary' : 'text-foreground'
        )}
        title={doc.title}
      >
        {doc.title}
      </span>
      
      {/* Action buttons - visible on hover */}
      <>
        {/* Rename button */}
        <button
          className={cn(
            'flex-shrink-0 p-0.5 rounded',
            'opacity-0 group-hover:opacity-100',
            'hover:bg-accent',
            'transition-opacity duration-100'
          )}
          onClick={(e) => {
            e.stopPropagation();
            console.log('üñäÔ∏è PENCIL CLICKED FOR DOC:', doc.id, doc.title);
            const newTitle = window.prompt('Rename document:', doc.title);
            if (newTitle && newTitle.trim() && newTitle.trim() !== doc.title) {
              console.log('üñäÔ∏è CALLING onSaveRename with:', newTitle.trim());
              onSaveRename(newTitle.trim());
            }
          }}
          title="Rename"
        >
          <Pencil className="h-2.5 w-2.5 text-muted-foreground" />
        </button>
        
        {/* Move to root button - only for docs in folders */}
        {doc.folderId && (
          <button
            className={cn(
              'flex-shrink-0 p-0.5 rounded',
              'opacity-0 group-hover:opacity-100',
              'hover:bg-accent',
              'transition-opacity duration-100'
            )}
            onClick={(e) => {
              e.stopPropagation();
              onMoveToRoot(doc.id);
            }}
            title="Move to root"
          >
            <Home className="h-3 w-3 text-muted-foreground" />
          </button>
        )}
        
        {/* Delete button */}
        <button
          className={cn(
            'flex-shrink-0 p-0.5 rounded',
            'opacity-0 group-hover:opacity-100',
            'hover:bg-destructive/10 hover:text-destructive',
            'transition-opacity duration-100'
          )}
          onClick={(e) => {
            e.stopPropagation();
            onDelete(doc);
          }}
          title="Delete"
        >
          <Trash2 className="h-3 w-3" />
        </button>
      </>
    </div>
  );
});

DraggableDocumentRow.displayName = 'DraggableDocumentRow';

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Groups documents by baseTitle and sorts versions within each group
 */
function groupDocumentsByBaseTitle(
  docs: ProjectDocument[]
): Map<string, ProjectDocument[]> {
  const grouped = new Map<string, ProjectDocument[]>();
  
  for (const doc of docs) {
    const existing = grouped.get(doc.baseTitle) || [];
    existing.push(doc);
    grouped.set(doc.baseTitle, existing);
  }
  
  // Sort versions ascending (latest at end)
  for (const [baseTitle, versions] of grouped) {
    versions.sort((a, b) => a.version - b.version);
    grouped.set(baseTitle, versions);
  }
  
  return grouped;
}

// ============================================================================
// Main Component
// ============================================================================

export default function DocumentList({ onDocumentClick }: DocumentListProps) {
  // ---------------------------------------------------------------------------
  // State
  // ---------------------------------------------------------------------------
  
  const [documents, setDocuments] = useState<ProjectDocument[]>([]);
  const [groupedDocs, setGroupedDocs] = useState<Map<string, ProjectDocument[]>>(new Map());
  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(new Set());
  const [selectedDocId, setSelectedDocId] = useState<string | null>(null);
  
  // Folder state
  const [folders, setFolders] = useState<Folder[]>([]);
  const [currentFolderId, setCurrentFolderId] = useState<string | null>(null);
  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set());
  
  // Folder editing state
  const [editingFolderId, setEditingFolderId] = useState<string | null>(null);
  const [editingFolderName, setEditingFolderName] = useState('');
  
  const [isLoading, setIsLoading] = useState(false);
  
  // Drag-and-drop state
  const [dragActiveId, setDragActiveId] = useState<string | null>(null);
  const [dragActiveType, setDragActiveType] = useState<'folder' | 'document' | null>(null);
  
  const activeProjectId = useActiveProjectId();
  const projects = useProjects();
  
  // ---------------------------------------------------------------------------
  // Drag-and-Drop Configuration
  // ---------------------------------------------------------------------------
  
  /** Configure sensors for drag detection - requires 8px movement to start drag */
  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    })
  );
  
  // ---------------------------------------------------------------------------
  // Derived State - Dynamic Labels
  // ---------------------------------------------------------------------------
  
  // Get active project for dynamic button text
  const activeProject = projects.find(p => p.id === activeProjectId);
  
  // Dynamic button text - shortened to fit sidebar width
  // Shows "{Project} Doc" instead of "New {Project} Doc"
  const newDocButtonText = activeProject
    ? `${activeProject.name} Doc`
    : 'New Doc';
  
  // Dynamic folder button text - shortened to fit sidebar width
  // Shows "{Project} Folder" instead of "New {Project} Folder"
  const newFolderButtonText = activeProject
    ? `${activeProject.name} Folder`
    : 'New Folder';
  
  // ---------------------------------------------------------------------------
  // Data Loading
  // ---------------------------------------------------------------------------
  
  /** Load documents from storage */
  const loadDocuments = useCallback(async () => {
    if (!activeProjectId) {
      setDocuments([]);
      setGroupedDocs(new Map());
      return;
    }
    
    try {
      const docs = await getAllDocuments(activeProjectId);
      setDocuments(docs);
      setGroupedDocs(groupDocumentsByBaseTitle(docs));
    } catch (error) {
      logger.error('‚ùå Failed to load documents:', error);
      setDocuments([]);
      setGroupedDocs(new Map());
    }
  }, [activeProjectId]);
  
  /** Load folders from storage */
  const loadFolders = useCallback(async () => {
    if (!activeProjectId) {
      setFolders([]);
      return;
    }
    
    try {
      const projectFolders = await getAllFolders(activeProjectId);
      setFolders(projectFolders);
    } catch (error) {
      logger.error('‚ùå Failed to load folders:', error);
      setFolders([]);
    }
  }, [activeProjectId]);
  
  /** Refresh all data (documents and folders) - fixes auto-refresh issues */
  const refreshAll = useCallback(async () => {
    await Promise.all([loadDocuments(), loadFolders()]);
  }, [loadDocuments, loadFolders]);
  
  // Load data on mount and when active project changes
  useEffect(() => {
    if (activeProjectId) {
      loadDocuments();
      loadFolders();
    } else {
      setDocuments([]);
      setFolders([]);
      setGroupedDocs(new Map());
    }
  }, [activeProjectId, loadDocuments, loadFolders]);
  
  // ---------------------------------------------------------------------------
  // Folder Handlers
  // ---------------------------------------------------------------------------
  
  /** Toggle folder expansion */
  const toggleFolder = useCallback((folderId: string) => {
    setExpandedFolders(prev => {
      const next = new Set(prev);
      if (next.has(folderId)) {
        next.delete(folderId);
      } else {
        next.add(folderId);
      }
      return next;
    });
  }, []);
  
  /** Create a new folder */
  const handleCreateFolder = useCallback(() => {
    if (!activeProjectId) return;
    
    const name = window.prompt('Folder name:');
    if (!name?.trim()) return;
    
    try {
      createFolder(activeProjectId, name.trim(), currentFolderId || undefined);
      refreshAll();
    } catch (error) {
      logger.error('‚ùå Failed to create folder:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to create folder');
    }
  }, [activeProjectId, currentFolderId, refreshAll]);
  
  /** Delete a folder */
  const handleDeleteFolder = useCallback((folder: Folder) => {
    if (!activeProjectId) return;
    
    const confirmed = window.confirm(
      `Delete folder "${folder.name}"?\n\nNote: Folders must be empty before deletion.`
    );
    
    if (!confirmed) return;
    
    try {
      deleteFolder(activeProjectId, folder.id);
      refreshAll();
    } catch (error) {
      logger.error('‚ùå Failed to delete folder:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to delete folder');
    }
  }, [activeProjectId, refreshAll]);
  
  /** Start inline rename for a folder */
  const startFolderRename = useCallback((folder: Folder) => {
    setEditingFolderId(folder.id);
    setEditingFolderName(folder.name);
  }, []);
  
  /** Save folder rename */
  const saveFolderRename = useCallback((folderId: string) => {
    if (!activeProjectId || !editingFolderName.trim()) {
      setEditingFolderId(null);
      setEditingFolderName('');
      return;
    }
    
    try {
      updateFolder(activeProjectId, folderId, { name: editingFolderName.trim() });
      refreshAll();
    } catch (error) {
      logger.error('‚ùå Failed to rename folder:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to rename folder');
    } finally {
      setEditingFolderId(null);
      setEditingFolderName('');
    }
  }, [activeProjectId, editingFolderName, refreshAll]);
  
  /** Cancel folder rename */
  const cancelFolderRename = useCallback(() => {
    setEditingFolderId(null);
    setEditingFolderName('');
  }, []);
  
  /** Move folder to another folder */
  const handleMoveFolder = useCallback(async (folderId: string) => {
    if (!activeProjectId) return;
    
    // Get all folders except the one being moved
    const allFolders = (await getAllFolders(activeProjectId)).filter(f => f.id !== folderId);
    
    if (allFolders.length === 0) {
      const moveToRoot = window.confirm('No other folders. Move to root level?');
      if (moveToRoot) {
        try {
          moveFolder(activeProjectId, folderId, null);
          refreshAll();
        } catch (error) {
          window.alert(error instanceof Error ? error.message : 'Failed to move folder');
        }
      }
      return;
    }
    
    // Build prompt with folder options
    const folderOptions = allFolders.map((f, i) => `${i + 1}. ${f.name}`).join('\n');
    const choice = window.prompt(
      `Move folder into:\n\n${folderOptions}\n\n0. Move to root\n\nEnter number:`
    );
    
    if (choice === null) return; // Cancelled
    
    const index = parseInt(choice) - 1;
    
    try {
      if (choice === '0') {
        moveFolder(activeProjectId, folderId, null);
      } else if (index >= 0 && index < allFolders.length) {
        moveFolder(activeProjectId, folderId, allFolders[index].id);
      } else {
        window.alert('Invalid choice');
        return;
      }
      
      refreshAll();
    } catch (error) {
      window.alert(error instanceof Error ? error.message : 'Failed to move folder');
      logger.error('‚ùå Failed to move folder:', error);
    }
  }, [activeProjectId, refreshAll]);
  
  // ---------------------------------------------------------------------------
  // Document Handlers
  // ---------------------------------------------------------------------------
  
  /** Toggle version group expansion */
  const toggleGroup = useCallback((baseTitle: string) => {
    setExpandedGroups((prev) => {
      const next = new Set(prev);
      if (next.has(baseTitle)) {
        next.delete(baseTitle);
      } else {
        next.add(baseTitle);
      }
      return next;
    });
  }, []);
  
  /** 
   * Save rename - updates document title using proper storage layer
   * Now uses window.prompt, so we just need docId and newTitle
   */
  const saveRename = useCallback(async (docId: string, newTitle: string) => {
    logger.log('üíæ saveRename called:', { docId, newTitle, activeProjectId });
    
    if (!activeProjectId) {
      logger.log('‚ùå No activeProjectId');
      return;
    }
    
    try {
      logger.log('üîÑ Renaming document:', { docId, newTitle });
      
      // Call updateDocument - this updates BOTH Supabase and localStorage
      await updateDocument(activeProjectId, docId, { 
        title: newTitle 
      });
      
      logger.log('‚úÖ Document renamed successfully:', newTitle);
      
      // Refresh the document list to show new title
      await refreshAll();
      
    } catch (error) {
      logger.error('‚ùå Failed to rename document:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to rename document');
    }
  }, [activeProjectId, refreshAll]);
  
  /** Create new document */
  const handleCreateDocument = useCallback(async () => {
    if (!activeProjectId) return;
    
    const defaultName = activeProject ? `${activeProject.name} Doc` : 'New Document';
    const title = window.prompt('Document title:', defaultName);
    if (!title?.trim()) return;
    
    try {
      setIsLoading(true);
      const newDoc = await createDocument(activeProjectId, title.trim());
      
      // If currently viewing a folder, place document in that folder
      if (currentFolderId) {
        await updateDocument(activeProjectId, newDoc.id, { folderId: currentFolderId });
      }
      
      await refreshAll();
      onDocumentClick(newDoc);
      setSelectedDocId(newDoc.id);
    } catch (error) {
      logger.error('‚ùå Failed to create document:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to create document');
    } finally {
      setIsLoading(false);
    }
  }, [activeProjectId, activeProject, currentFolderId, refreshAll, onDocumentClick]);
  
  /** Delete a document */
  const handleDelete = useCallback(async (doc: ProjectDocument) => {
    if (!activeProjectId) return;
    
    // Get version count for this baseTitle
    const versions = groupedDocs.get(doc.baseTitle) || [];
    const versionInfo = versions.length > 1 
      ? `\n\nNote: This will only delete "${doc.title}". ${versions.length - 1} other version(s) will remain.`
      : '';
    
    const confirmed = window.confirm(
      `Delete "${doc.title}"?${versionInfo}\n\nThis cannot be undone.`
    );
    
    if (!confirmed) return;
    
    try {
      await deleteDocument(activeProjectId, doc.id);
      await refreshAll();
      if (selectedDocId === doc.id) {
        setSelectedDocId(null);
      }
    } catch (error) {
      logger.error('‚ùå Failed to delete document:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to delete document');
    }
  }, [activeProjectId, groupedDocs, refreshAll, selectedDocId]);
  
  /** Select and load document */
  const handleSelect = useCallback((doc: ProjectDocument) => {
    setSelectedDocId(doc.id);
    onDocumentClick(doc);
  }, [onDocumentClick]);
  
  /** Move document to a folder */
  const handleMoveDocument = useCallback(async (docId: string) => {
    if (!activeProjectId) return;
    
    // Get all folders for picker
    const allFolders = await getAllFolders(activeProjectId);
    
    if (allFolders.length === 0) {
      window.alert('No folders available. Create a folder first.');
      return;
    }
    
    // Build prompt with folder options
    const folderOptions = allFolders.map((f, i) => `${i + 1}. ${f.name}`).join('\n');
    const choice = window.prompt(
      `Move document to folder:\n\n${folderOptions}\n\n0. Move to root (no folder)\n\nEnter number:`
    );
    
    if (choice === null) return; // Cancelled
    
    const index = parseInt(choice) - 1;
    
    try {
      if (choice === '0') {
        // Move to root (remove from folder)
        await updateDocument(activeProjectId, docId, { folderId: undefined });
      } else if (index >= 0 && index < allFolders.length) {
        // Move to selected folder
        await updateDocument(activeProjectId, docId, { folderId: allFolders[index].id });
      } else {
        window.alert('Invalid choice');
        return;
      }
      
      await refreshAll();
      logger.log('‚úÖ Document moved');
    } catch (error) {
      logger.error('‚ùå Failed to move document:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to move document');
    }
  }, [activeProjectId, refreshAll]);
  
  /** Move a document directly to root (no folder) */
  const handleMoveDocumentToRoot = useCallback(async (docId: string) => {
    if (!activeProjectId) return;
    
    try {
      await updateDocument(activeProjectId, docId, { folderId: undefined });
      await refreshAll();
      logger.log('‚úÖ Document moved to root');
    } catch (error) {
      logger.error('‚ùå Failed to move document:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to move document');
    }
  }, [activeProjectId, refreshAll]);
  
  /** Move a folder directly to root (no parent) */
  const handleMoveFolderToRoot = useCallback(async (folderId: string) => {
    if (!activeProjectId) return;
    
    try {
      await moveFolder(activeProjectId, folderId, null);
      await refreshAll();
      logger.log('‚úÖ Folder moved to root');
    } catch (error) {
      logger.error('‚ùå Failed to move folder:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to move folder');
    }
  }, [activeProjectId, refreshAll]);
  
  // ---------------------------------------------------------------------------
  // Drag-and-Drop Handlers
  // ---------------------------------------------------------------------------
  
  /** Handle drag start - track what's being dragged */
  const handleDragStart = useCallback((event: DragStartEvent) => {
    const { active } = event;
    const idString = active.id as string;
    const [type, id] = idString.split(':');
    setDragActiveId(id);
    setDragActiveType(type as 'folder' | 'document');
  }, []);
  
  /** Handle drag end - perform the move operation */
  const handleDragEnd = useCallback(async (event: DragEndEvent) => {
    const { active, over } = event;
    
    if (!over || !activeProjectId) {
      setDragActiveId(null);
      setDragActiveType(null);
      return;
    }
    
    const activeIdString = active.id as string;
    const overIdString = over.id as string;
    const [activeType, activeId] = activeIdString.split(':');
    const [overType, overId] = overIdString.split(':');
    
    
    try {
      if (activeType === 'document') {
        // Dragging a document
        if (overType === 'folder') {
          // Drop document into folder
          await updateDocument(activeProjectId, activeId, { folderId: overId });
        } else if (overType === 'root') {
          // Drop document to root
          await updateDocument(activeProjectId, activeId, { folderId: undefined });
        }
      } else if (activeType === 'folder') {
        // Dragging a folder
        if (overType === 'folder' && overId !== activeId) {
          // Drop folder into another folder (nest it)
          await moveFolder(activeProjectId, activeId, overId);
        } else if (overType === 'root') {
          // Drop folder to root
          await moveFolder(activeProjectId, activeId, null);
        }
      }
      
      await refreshAll();
    } catch (error) {
      logger.error('‚ùå Failed to move item:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to move item');
    }
    
    setDragActiveId(null);
    setDragActiveType(null);
  }, [activeProjectId, refreshAll]);
  
  // ---------------------------------------------------------------------------
  // Root Drop Target - entire content area is droppable
  // ---------------------------------------------------------------------------
  
  /** Make the entire content area droppable for moving items to root */
  const { setNodeRef: setRootDropRef, isOver: isOverRoot } = useDroppable({
    id: 'root:root',
  });
  
  // ---------------------------------------------------------------------------
  // Draggable Folder Item Component
  // TODO: TECHNICAL DEBT - This component should be extracted as a standalone
  // React component (like DraggableDocumentRow) to properly follow Rules of Hooks.
  // The current implementation works because hooks are called consistently,
  // but violates React's rules-of-hooks lint rule.
  // ---------------------------------------------------------------------------
  
  /** Individual draggable/droppable folder item */
  const DraggableFolderItem = useCallback(({ 
    folder, 
    level,
  }: { 
    folder: Folder; 
    level: number;
  }) => {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const { attributes, listeners, setNodeRef: setDragRef, isDragging } = useDraggable({
      id: `folder:${folder.id}`,
    });
    
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const { setNodeRef: setDropRef, isOver } = useDroppable({
      id: `folder:${folder.id}`,
    });
    
    const isExpanded = expandedFolders.has(folder.id);
    const childFolders = folders.filter(f => f.parentFolderId === folder.id);
    const folderDocs = documents.filter(d => d.folderId === folder.id);
    const folderGroupedDocs = groupDocumentsByBaseTitle(folderDocs);
    const isEmpty = childFolders.length === 0 && folderDocs.length === 0;
    
    const groupEntries = Array.from(folderGroupedDocs.entries());
    
    // Root folders (level 0) have NO border or margin
    // Nested folders have tree line
    const isNested = level > 0;
    
    const isEditingThisFolder = editingFolderId === folder.id;
    
    return (
      <div 
        style={{ opacity: isDragging ? 0.5 : 1 }}
        className={cn(isNested && 'border-l-2 border-foreground/30 ml-2')}
      >
        {/* Folder header - draggable AND droppable */}
        <div 
          ref={(node) => {
            // Combine both refs - this div is both draggable and a drop target
            setDragRef(node);
            setDropRef(node);
          }}
          {...attributes}
          {...listeners}
          className={cn(
            'group flex items-center gap-1 px-2 py-1.5 hover:bg-accent rounded cursor-pointer',
            'transition-colors duration-100',
            isOver && 'bg-accent ring-2 ring-primary'
          )}
          onClick={() => !isEditingThisFolder && toggleFolder(folder.id)}
        >
          {/* Horizontal connector for nested folders - dark and visible */}
          {isNested && (
            <div className="w-3 h-px bg-foreground/30 -ml-2 flex-shrink-0" />
          )}
          
          {/* Chevron icon */}
          <ChevronRight 
            className={cn(
              'h-3 w-3 transition-transform duration-150 text-muted-foreground flex-shrink-0 cursor-grab active:cursor-grabbing',
              isExpanded && 'rotate-90'
            )} 
          />
          
          {/* Blue folder icon */}
          <FolderIcon className="h-3.5 w-3.5 text-blue-500 flex-shrink-0" />
          
          {/* Folder name - editable or display */}
          {isEditingThisFolder ? (
            <input
              type="text"
              value={editingFolderName}
              onChange={(e) => setEditingFolderName(e.target.value)}
              onBlur={() => saveFolderRename(folder.id)}
              onKeyDown={(e) => {
                if (e.key === 'Enter') {
                  e.preventDefault();
                  saveFolderRename(folder.id);
                } else if (e.key === 'Escape') {
                  e.preventDefault();
                  cancelFolderRename();
                }
              }}
              onClick={(e) => e.stopPropagation()}
              className={cn(
                'flex-1 text-xs font-semibold bg-background min-w-0',
                'border border-primary rounded px-1 py-0.5',
                'focus:outline-none focus:ring-1 focus:ring-primary'
              )}
              autoFocus
              placeholder="Folder name..."
            />
          ) : (
            <span 
              className="flex-1 truncate text-xs font-semibold text-foreground"
              onDoubleClick={(e) => {
                e.stopPropagation();
                startFolderRename(folder);
              }}
              title={folder.name}
            >
              {folder.name}
            </span>
          )}
          
          {/* Document count badge */}
          <span className="text-[10px] px-1.5 py-0.5 rounded-full bg-blue-500/10 text-blue-600 dark:text-blue-400 flex-shrink-0">
            {folderDocs.length}
          </span>
          
          {/* Action buttons - visible on hover */}
          {!isEditingThisFolder && (
            <>
              {/* Rename folder button */}
              <button
                className={cn(
                  'flex-shrink-0 p-0.5 rounded',
                  'opacity-0 group-hover:opacity-100',
                  'hover:bg-accent',
                  'transition-opacity duration-100'
                )}
                onClick={(e) => {
                  e.stopPropagation();
                  startFolderRename(folder);
                }}
                title="Rename folder"
              >
                <Pencil className="h-3 w-3 text-muted-foreground" />
              </button>
              
              {/* Delete folder button */}
              <button
                className={cn(
                  'flex-shrink-0 p-0.5 rounded',
                  'opacity-0 group-hover:opacity-100',
                  'hover:bg-destructive/10 hover:text-destructive',
                  'transition-opacity duration-100'
                )}
                onClick={(e) => {
                  e.stopPropagation();
                  handleDeleteFolder(folder);
                }}
                title="Delete folder"
              >
                <Trash2 className="h-3 w-3" />
              </button>
            </>
          )}
        </div>
        
        {/* Folder contents (when expanded) */}
        {isExpanded && (
          <div className="pl-4">
            {/* Empty folder message */}
            {isEmpty && (
              <div className="border-l-2 border-foreground/30 ml-2">
                <div className="flex items-center px-2 py-1.5">
                  <div className="w-3 h-px bg-foreground/30 -ml-2 flex-shrink-0" />
                  <span className="text-[10px] text-muted-foreground italic ml-1">
                    Drop documents here
                  </span>
                </div>
              </div>
            )}
            
            {/* Subfolders */}
            {childFolders.map((subfolder) => (
              <DraggableFolderItem 
                key={subfolder.id} 
                folder={subfolder} 
                level={level + 1}
              />
            ))}
            
            {/* Documents in this folder - grouped by baseTitle */}
            {groupEntries.map(([baseTitle, versions]) => (
              <DraggableDocumentGroup
                key={baseTitle}
                baseTitle={baseTitle}
                versions={versions}
                showTreeLine={true}
              />
            ))}
          </div>
        )}
      </div>
    );
  }, [
    expandedFolders, 
    folders, 
    documents, 
    editingFolderId,
    editingFolderName,
    toggleFolder, 
    handleDeleteFolder,
    handleMoveFolder,
    handleMoveFolderToRoot,
    startFolderRename,
    saveFolderRename,
    cancelFolderRename,
  ]);
  
  // ---------------------------------------------------------------------------
  // Draggable Document Group Component
  // ---------------------------------------------------------------------------
  
  /** Document group with draggable documents */
  const DraggableDocumentGroup = useCallback(({
    baseTitle,
    versions,
    showTreeLine = false,
  }: {
    baseTitle: string;
    versions: ProjectDocument[];
    showTreeLine?: boolean;
  }) => {
    const latestVersion = versions[versions.length - 1];
    const hasMultipleVersions = versions.length > 1;
    const isExpanded = expandedGroups.has(baseTitle);
    
    // Single version - just show the draggable document
    if (!hasMultipleVersions) {
      return (
        <div className={cn(showTreeLine && 'border-l-2 border-foreground/30 ml-2')}>
          <DraggableDocumentRow
            doc={latestVersion}
            showConnector={showTreeLine}
            selectedDocId={selectedDocId}
            onSaveRename={(newTitle) => saveRename(latestVersion.id, newTitle)}
            onSelect={handleSelect}
            onDelete={handleDelete}
            onMoveToRoot={handleMoveDocumentToRoot}
          />
        </div>
      );
    }
    
    // Multiple versions - show group header with expandable versions
    return (
      <div className={cn(showTreeLine && 'border-l-2 border-foreground/30 ml-2')}>
        {/* Group header */}
        <div
          className={cn(
            'flex items-center gap-1 px-2 py-1 rounded',
            'hover:bg-accent/40 cursor-pointer',
            'transition-colors duration-100'
          )}
          onClick={() => toggleGroup(baseTitle)}
        >
          {/* Horizontal connector - dark and visible */}
          {showTreeLine && (
            <div className="w-3 h-px bg-foreground/30 -ml-2 flex-shrink-0" />
          )}
          
          {/* Expand/collapse chevron */}
          <ChevronRight className={cn(
            'h-3 w-3 text-muted-foreground transition-transform duration-150',
            isExpanded && 'rotate-90'
          )} />
          
          {/* Group title - medium weight */}
          <span className="flex-1 text-xs font-medium truncate text-foreground">
            {baseTitle}
          </span>
          
          {/* Version count badge */}
          <span className="text-[10px] px-1.5 py-0.5 rounded-full bg-muted text-muted-foreground">
            {versions.length}v
          </span>
        </div>
        
        {/* Expanded versions - indented with dark tree line */}
        {isExpanded && (
          <div className="pl-4 border-l-2 border-foreground/30 ml-2">
            {versions.map((doc) => (
              <DraggableDocumentRow
                key={doc.id}
                doc={doc}
                showConnector={true}
                selectedDocId={selectedDocId}
                onSaveRename={(newTitle) => saveRename(doc.id, newTitle)}
                onSelect={handleSelect}
                onDelete={handleDelete}
                onMoveToRoot={handleMoveDocumentToRoot}
              />
            ))}
          </div>
        )}
      </div>
    );
  }, [expandedGroups, toggleGroup, selectedDocId, saveRename, handleSelect, handleDelete, handleMoveDocumentToRoot]);
  
  // ---------------------------------------------------------------------------
  // Derived Data for Render
  // ---------------------------------------------------------------------------
  
  // Get root-level folders
  const rootFolders = folders.filter(f => !f.parentFolderId);
  
  // Get root-level documents (not in any folder)
  const rootDocuments = documents.filter(d => !d.folderId);
  const rootGroupedDocs = groupDocumentsByBaseTitle(rootDocuments);
  const rootGroupEntries = Array.from(rootGroupedDocs.entries());
  
  // ---------------------------------------------------------------------------
  // Render
  // ---------------------------------------------------------------------------
  
  // Find active item for drag overlay
  const activeDragFolder = dragActiveType === 'folder' 
    ? folders.find(f => f.id === dragActiveId) 
    : null;
  const activeDragDocument = dragActiveType === 'document'
    ? documents.find(d => d.id === dragActiveId)
    : null;
  
  return (
    <DndContext
      sensors={sensors}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      <div className="flex flex-col h-full">
        {/* Header with New Folder and New Doc buttons - fixed at top, doesn't scroll */}
        <div className="shrink-0 px-2 py-2 border-b border-border">
          <div className="flex gap-1.5">
            <Button
              variant="ghost"
              size="sm"
              onClick={handleCreateFolder}
              disabled={!activeProjectId || isLoading}
              className="flex-1 justify-start text-xs h-7 px-2 min-w-0"
              title="Create new folder"
            >
              <FolderPlus className="h-3.5 w-3.5 mr-1.5 shrink-0" />
              <span className="truncate">{newFolderButtonText}</span>
            </Button>
            
            <Button
              variant="ghost"
              size="sm"
              onClick={handleCreateDocument}
              disabled={!activeProjectId || isLoading}
              className="flex-1 justify-start text-xs h-7 px-2 min-w-0"
              title="Create new document"
            >
              <FilePlus className="h-3.5 w-3.5 mr-1.5 shrink-0" />
              <span className="truncate">{newDocButtonText}</span>
            </Button>
          </div>
        </div>

        {/* Scrollable content area - ENTIRE AREA is droppable for root */}
        <div 
          ref={setRootDropRef}
          className={cn(
            'flex-1 overflow-y-auto overflow-x-hidden transition-colors duration-200',
            isOverRoot && 'bg-primary/5'
          )}
        >
          {/* No project selected */}
          {!activeProjectId && (
            <div className="text-center text-muted-foreground py-6 px-2">
              <FileText className="h-8 w-8 mx-auto mb-2 opacity-40" />
              <p className="text-xs">No project selected</p>
            </div>
          )}

          {activeProjectId && (
            <div className="px-2 pb-4 min-h-full">
              {/* Show hint when dragging over empty areas */}
              {isOverRoot && (
                <div className="sticky top-2 mb-3 p-2 bg-primary/10 border border-primary/20 rounded-lg text-xs text-center text-primary font-medium z-10">
                  üìÇ Release to move to root level
                </div>
              )}
              
              {/* Root-level folders - draggable and droppable */}
              {rootFolders.map((folder) => (
                <DraggableFolderItem 
                  key={folder.id}
                  folder={folder}
                  level={0}
                />
              ))}
              
              {/* Root-level documents (not in any folder) - draggable */}
              {rootGroupEntries.map(([baseTitle, versions]) => (
                <DraggableDocumentGroup
                  key={baseTitle}
                  baseTitle={baseTitle}
                  versions={versions}
                  showTreeLine={false}
                />
              ))}
              
              {/* Empty state */}
              {documents.length === 0 && folders.length === 0 && (
                <div className="text-center text-muted-foreground py-6">
                  <FileText className="h-8 w-8 mx-auto mb-2 opacity-40" />
                  <p className="text-xs">No documents yet</p>
                  <p className="text-[10px] mt-0.5 opacity-70">
                    Create a folder or document to get started
                  </p>
                </div>
              )}
            </div>
          )}
        </div>
      </div>
      
      {/* Drag overlay - shows what's being dragged */}
      <DragOverlay>
        {activeDragFolder && (
          <div className="flex items-center gap-2 px-3 py-2 bg-background border rounded-lg shadow-lg">
            <FolderIcon className="h-4 w-4 text-blue-500" />
            <span className="text-xs font-semibold">{activeDragFolder.name}</span>
          </div>
        )}
        {activeDragDocument && (
          <div className="flex items-center gap-2 px-3 py-2 bg-background border rounded-lg shadow-lg">
            <FileText className="h-4 w-4 text-muted-foreground" />
            <span className="text-xs">{activeDragDocument.title}</span>
          </div>
        )}
      </DragOverlay>
    </DndContext>
  );
}


=== FILE: components/workspace/EditorArea.tsx ===

/**
 * @file components/workspace/EditorArea.tsx
 * @description TipTap rich text editor with direct localStorage persistence
 * 
 * ARCHITECTURE (Simplified):
 * - Loads document content directly from localStorage (via document-storage.ts)
 * - Saves directly to localStorage on every change (debounced 500ms)
 * - NO Zustand caching of document content
 * - Zustand only provides activeDocumentId and activeProjectId
 * 
 * Features:
 * - TipTap editor with full formatting
 * - Automatic content persistence to localStorage
 * - Real-time word/character count
 * - Zoom controls for editor view (50%-200%)
 * - Two view modes: Scrolling (default) and Focus
 */

'use client';

import React, { useEffect, useCallback, useRef, useState, useImperativeHandle, forwardRef } from 'react';
import { useEditor, EditorContent, type Editor } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Placeholder from '@tiptap/extension-placeholder';
import CharacterCount from '@tiptap/extension-character-count';
import TextAlign from '@tiptap/extension-text-align';
import Underline from '@tiptap/extension-underline';
import Link from '@tiptap/extension-link';
import Typography from '@tiptap/extension-typography';
import Dropcursor from '@tiptap/extension-dropcursor';
import { TextStyle } from '@tiptap/extension-text-style';
import { FontFamily } from '@tiptap/extension-font-family';
import { Color } from '@tiptap/extension-color';
import Highlight from '@tiptap/extension-highlight';
import { FontSize } from '@/lib/tiptap/font-size';
import { useWorkspaceStore, useActiveProjectId, useActiveDocumentId, useViewMode } from '@/lib/stores/workspaceStore';
import { useSnippetStore } from '@/lib/stores/snippetStore';
import { getDocument, updateDocument, createDocumentVersion } from '@/lib/storage/unified-storage';
import { getEditorSelection } from '@/lib/editor-utils';
import { cn } from '@/lib/utils';
import type { ProjectDocument } from '@/lib/types/project';
import { ZoomIn, ZoomOut, Copy } from 'lucide-react';
import { toast } from 'sonner';
import { Slider } from '@/components/ui/slider';
import { TemplateResumeBanner } from './TemplateResumeBanner';
import { logger } from '@/lib/utils/logger';

interface EditorAreaProps {
  className?: string;
  /** Callback to pass the editor instance to parent component */
  onEditorReady?: (editor: Editor | null) => void;
}

/**
 * Ref handle for EditorArea - exposes loadDocument method
 */
export interface EditorAreaHandle {
  loadDocument: (doc: ProjectDocument) => void;
}

/** Debounce delay for auto-save (ms) */
const AUTO_SAVE_DELAY = 500;

/** Available zoom levels for the editor (percentages) */
const ZOOM_LEVELS = [50, 75, 90, 100, 110, 125, 150, 175, 200] as const;

/** Default zoom level */
const DEFAULT_ZOOM = 100;

/**
 * Main editor area with TipTap rich text editor
 * Document content is loaded/saved directly to localStorage
 */
export const EditorArea = forwardRef<EditorAreaHandle, EditorAreaProps>(
  function EditorArea({ className, onEditorReady }, ref) {
  
  // Get IDs from Zustand (no content!)
  const activeProjectId = useActiveProjectId();
  const activeDocumentId = useActiveDocumentId();
  const viewMode = useViewMode();
  
  // Get actions via getState to avoid re-render loops
  const setSelectedTextRef = useRef(useWorkspaceStore.getState().setSelectedText);
  const setActiveDocumentIdRef = useRef(useWorkspaceStore.getState().setActiveDocumentId);
  
  // Check view mode - only focus mode has special styling now
  const isFocusMode = viewMode === 'focus';
  
  // Local state for document data loaded from localStorage
  const [currentDocument, setCurrentDocument] = useState<ProjectDocument | null>(null);
  
  // Auto-save status indicator
  const [saveStatus, setSaveStatus] = useState<'saved' | 'saving' | 'idle'>('idle');
  const saveStatusTimerRef = useRef<NodeJS.Timeout | null>(null);
  
  // Auto-save debounce timer ref
  const autoSaveTimerRef = useRef<NodeJS.Timeout | null>(null);
  
  // Zoom level state (view preference, not saved to document)
  const [zoomLevel, setZoomLevel] = useState<number>(DEFAULT_ZOOM);
  
  // Track if we're loading content to prevent save during load
  const isLoadingRef = useRef(false);
  
  // Keep refs updated
  useEffect(() => {
    return useWorkspaceStore.subscribe((state) => {
      setSelectedTextRef.current = state.setSelectedText;
      setActiveDocumentIdRef.current = state.setActiveDocumentId;
    });
  }, []);

  // Initialize TipTap editor
  const editor = useEditor({
    immediatelyRender: false,
    extensions: [
      StarterKit.configure({
        heading: {
          levels: [1, 2, 3],
        },
      }),
      Placeholder.configure({
        placeholder: 'Start writing your copy...',
      }),
      CharacterCount,
      TextAlign.configure({
        types: ['heading', 'paragraph'],
      }),
      Underline,
      Link.configure({
        openOnClick: false,
        HTMLAttributes: {
          class: 'text-apple-blue underline cursor-pointer hover:text-apple-blue-dark',
        },
      }),
      Typography,
      Dropcursor.configure({
        color: '#0071E3',
        width: 2,
      }),
      TextStyle,
      FontFamily.configure({
        types: ['textStyle'],
      }),
      FontSize.configure({
        sizes: ['8px', '10px', '11px', '12px', '14px', '16px', '18px', '20px', '24px', '28px', '32px', '36px', '48px', '72px'],
      }),
      Color.configure({
        types: ['textStyle'],
      }),
      Highlight.configure({
        multicolor: true,
      }),
    ],
    content: '',
    onCreate: ({ editor }) => {
      onEditorReady?.(editor);
    },
    onDestroy: () => {
      onEditorReady?.(null);
    },
    editorProps: {
      attributes: {
        class: 'prose prose-lg max-w-none focus:outline-none min-h-[800px] text-apple-text-dark',
      },
      handleDOMEvents: {
        drop: () => false,
        dragstart: () => false,
      },
    },
  });

  /**
   * Save document content to storage (cloud with localStorage fallback)
   */
  const saveToLocalStorage = useCallback(async (content: string) => {
    if (!activeProjectId || !currentDocument?.id) {
      logger.warn('‚ö†Ô∏è Cannot save: missing projectId or documentId');
      setSaveStatus('idle');
      return;
    }
    
    try {
      await updateDocument(activeProjectId, currentDocument.id, { content });
      setSaveStatus('saved');
      
      if (saveStatusTimerRef.current) {
        clearTimeout(saveStatusTimerRef.current);
      }
      
      saveStatusTimerRef.current = setTimeout(() => {
        setSaveStatus('idle');
      }, 2000);
      
    } catch (error) {
      logger.error('‚ùå Failed to save document:', error);
      setSaveStatus('idle');
    }
  }, [activeProjectId, currentDocument?.id]);

  /**
   * Handle editor content changes
   */
  const handleEditorUpdate = useCallback(() => {
    if (isLoadingRef.current) return;
    if (!editor) return;
    
    setSaveStatus('saving');
    
    if (autoSaveTimerRef.current) {
      clearTimeout(autoSaveTimerRef.current);
    }
    
    autoSaveTimerRef.current = setTimeout(() => {
      const html = editor.getHTML();
      saveToLocalStorage(html);
      
      setCurrentDocument((prev) => prev ? {
        ...prev,
        content: html,
        modifiedAt: new Date().toISOString(),
      } : null);
    }, AUTO_SAVE_DELAY);
  }, [editor, saveToLocalStorage]);

  /**
   * Load document from storage (cloud with localStorage fallback)
   */
  const loadDocumentFromStorage = useCallback(async (docId: string) => {
    if (!activeProjectId || !editor) {
      logger.warn('‚ö†Ô∏è Cannot load document: missing projectId or editor');
      return;
    }
    
    isLoadingRef.current = true;
    
    try {
      const doc = await getDocument(activeProjectId, docId);
      
      if (!doc) {
        logger.warn('‚ö†Ô∏è Document not found:', docId);
        setCurrentDocument(null);
        editor.commands.setContent('');
        isLoadingRef.current = false;
        return;
      }
      
      setCurrentDocument(doc);
      editor.commands.setContent(doc.content || '');
    } catch (error) {
      logger.error('‚ùå Failed to load document:', error);
      setCurrentDocument(null);
      editor.commands.setContent('');
    } finally {
      setTimeout(() => {
        isLoadingRef.current = false;
      }, 100);
    }
  }, [activeProjectId, editor]);

  /**
   * Load document when activeDocumentId changes
   */
  useEffect(() => {
    if (!editor) return;
    
    if (activeDocumentId) {
      loadDocumentFromStorage(activeDocumentId);
    } else {
      setCurrentDocument(null);
      isLoadingRef.current = true;
      editor.commands.setContent('');
      setTimeout(() => {
        isLoadingRef.current = false;
      }, 100);
    }
  }, [editor, activeDocumentId, loadDocumentFromStorage]);

  /**
   * Listen for document updates from external sources
   */
  useEffect(() => {
    const handleDocumentUpdated = async (event: Event) => {
      const customEvent = event as CustomEvent;
      const { projectId, documentId } = customEvent.detail;
      
      if (projectId === activeProjectId && documentId === activeDocumentId && editor) {
        try {
          const doc = await getDocument(projectId, documentId);
          if (doc) {
            setCurrentDocument(doc);
            logger.log('‚úÖ Document metadata refreshed:', doc.title);
          }
        } catch (error) {
          logger.error('‚ùå Failed to refresh document:', error);
        }
      }
    };

    window.addEventListener('documentUpdated', handleDocumentUpdated);
    return () => window.removeEventListener('documentUpdated', handleDocumentUpdated);
  }, [activeProjectId, activeDocumentId, editor]);

  /**
   * Listen to editor updates for auto-save
   */
  useEffect(() => {
    if (!editor) return;
    
    editor.on('update', handleEditorUpdate);
    
    return () => {
      editor.off('update', handleEditorUpdate);
      if (autoSaveTimerRef.current) {
        clearTimeout(autoSaveTimerRef.current);
      }
      if (saveStatusTimerRef.current) {
        clearTimeout(saveStatusTimerRef.current);
      }
    };
  }, [editor, handleEditorUpdate]);

  /**
   * Track text selection changes
   */
  useEffect(() => {
    if (!editor) return;

    let debounceTimer: NodeJS.Timeout | null = null;
    
    const handleSelectionUpdate = (): void => {
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }
      
      debounceTimer = setTimeout(() => {
        const selection = getEditorSelection(editor);
        
        if (selection) {
          setSelectedTextRef.current(selection.text, selection.html, selection.range);
        } else {
          setSelectedTextRef.current(null, null, null);
        }
      }, 150);
    };

    editor.on('selectionUpdate', handleSelectionUpdate);
    editor.on('update', handleSelectionUpdate);

    return () => {
      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }
      editor.off('selectionUpdate', handleSelectionUpdate);
      editor.off('update', handleSelectionUpdate);
    };
  }, [editor]);

  /**
   * Export editor instance for toolbar
   */
  useEffect(() => {
    if (editor && typeof window !== 'undefined') {
      window.__tiptapEditor = editor;
    }
  }, [editor]);
  
  /**
   * Register editor with snippet store
   */
  useEffect(() => {
    useSnippetStore.getState().setEditorRef(editor);
    return () => {
      useSnippetStore.getState().setEditorRef(null);
    };
  }, [editor]);

  /**
   * Handle loading a document from external source
   */
  const handleLoadDocument = useCallback((doc: ProjectDocument) => {
    if (!editor) {
      logger.warn('‚ö†Ô∏è Editor not ready');
      return;
    }
    
    isLoadingRef.current = true;
    setActiveDocumentIdRef.current(doc.id);
    setCurrentDocument(doc);
    editor.commands.setContent(doc.content || '');
    
    logger.log('üìÑ Document loaded via click:', {
      id: doc.id,
      title: doc.title,
      version: doc.version,
    });
    
    setTimeout(() => {
      isLoadingRef.current = false;
    }, 100);
  }, [editor]);

  // Zoom handlers
  const handleZoomIn = useCallback(() => {
    setZoomLevel((current) => {
      const currentIndex = ZOOM_LEVELS.indexOf(current as typeof ZOOM_LEVELS[number]);
      if (currentIndex === -1) {
        const nextLevel = ZOOM_LEVELS.find((level) => level > current);
        return nextLevel ?? ZOOM_LEVELS[ZOOM_LEVELS.length - 1];
      }
      if (currentIndex < ZOOM_LEVELS.length - 1) {
        return ZOOM_LEVELS[currentIndex + 1];
      }
      return current;
    });
  }, []);

  const handleZoomOut = useCallback(() => {
    setZoomLevel((current) => {
      const currentIndex = ZOOM_LEVELS.indexOf(current as typeof ZOOM_LEVELS[number]);
      if (currentIndex === -1) {
        const prevLevels = ZOOM_LEVELS.filter((level) => level < current);
        return prevLevels.length > 0 ? prevLevels[prevLevels.length - 1] : ZOOM_LEVELS[0];
      }
      if (currentIndex > 0) {
        return ZOOM_LEVELS[currentIndex - 1];
      }
      return current;
    });
  }, []);

  const handleZoomReset = useCallback(() => {
    setZoomLevel(DEFAULT_ZOOM);
  }, []);

  const handleSliderChange = useCallback((value: number[]) => {
    if (value[0] !== undefined) {
      setZoomLevel(value[0]);
    }
  }, []);

  const canZoomIn = zoomLevel < ZOOM_LEVELS[ZOOM_LEVELS.length - 1];
  const canZoomOut = zoomLevel > ZOOM_LEVELS[0];

  /**
   * Parse version number from document title
   */
  const parseVersionFromTitle = useCallback((title: string): { base: string; version: number | null } => {
    const regex = /\s+v(\d+)$/i;
    const match = title.match(regex);
    
    if (match) {
      const version = parseInt(match[1], 10);
      const base = title.slice(0, match.index).trim();
      return { base, version };
    }
    
    return { base: title, version: null };
  }, []);

  /**
   * Handle "Save as New Version"
   */
  const handleSaveAsNewVersion = useCallback(async () => {
    if (!currentDocument || !activeProjectId || !editor) {
      logger.error('‚ùå Cannot save version: missing document, project, or editor');
      return;
    }

    try {
      const currentContent = editor.getHTML();
      const { base, version } = parseVersionFromTitle(currentDocument.title);
      const currentVersion = version ?? 1;
      const newVersion = currentVersion + 1;
      
      const newDoc = await createDocumentVersion(activeProjectId, currentDocument.id, currentContent);
      const newTitle = `${base} v${newVersion}`;
      
      await updateDocument(activeProjectId, newDoc.id, { 
        title: newTitle,
        baseTitle: base,
        version: newVersion 
      });
      
      setCurrentDocument({
        ...newDoc,
        title: newTitle,
        baseTitle: base,
        version: newVersion,
        content: currentContent,
      });
      
      setActiveDocumentIdRef.current(newDoc.id);
      toast.success(`Created ${newTitle}`);
      
      logger.log('‚úÖ New version created:', {
        originalTitle: currentDocument.title,
        newTitle,
        newVersion,
        newId: newDoc.id,
      });
    } catch (error) {
      logger.error('‚ùå Failed to create new version:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to create new version');
    }
  }, [currentDocument, activeProjectId, editor, parseVersionFromTitle]);

  // Expose loadDocument via ref
  useImperativeHandle(ref, () => ({
    loadDocument: handleLoadDocument,
  }), [handleLoadDocument]);

  return (
    <div
      className={cn(
        'relative h-full w-full',
        'overflow-y-auto custom-scrollbar',
        'transition-all duration-300',
        isFocusMode 
          ? 'bg-white py-8 px-4'
          : 'bg-apple-editor-bg py-12 px-8',
        'flex items-start justify-center',
        className
      )}
      data-print-content
      data-tour="editor"
    >
      {/* Template Resume Banner */}
      <TemplateResumeBanner />
      
      {/* Paper Container */}
      <div
        className={cn(
          'w-full',
          'bg-white',
          'relative',
          'transition-all duration-300',
          isFocusMode 
            ? 'max-w-[750px] shadow-none min-h-screen'
            : 'max-w-[850px] rounded-sm min-h-[11in]',
        )}
        style={{
          boxShadow: isFocusMode ? 'none' : '0 2px 8px rgba(0, 0, 0, 0.08)',
        }}
      >
        {currentDocument ? (
          <>
            {/* Document header */}
            <div
              className={cn(
                'transition-all duration-300',
                isFocusMode 
                  ? 'px-8 py-3 border-b border-gray-100 space-y-2'
                  : 'px-16 py-3 border-b border-gray-200 space-y-2'
              )}
              data-print-hide
            >
              {/* LINE 1: Document title and Save as New Version button */}
              <div className="flex items-start justify-between gap-4">
                <h1 
                  className="text-xl font-sans font-semibold text-black leading-tight max-w-[70%]"
                  title={currentDocument.title}
                >
                  {currentDocument.title}
                </h1>
                
                <button
                  onClick={handleSaveAsNewVersion}
                  className={cn(
                    'flex items-center gap-1.5 px-3 py-1.5 rounded-md flex-shrink-0',
                    'text-sm font-medium',
                    'bg-primary/10 text-primary',
                    'hover:bg-primary/20 active:bg-primary/25',
                    'transition-colors duration-150',
                    'focus:outline-none focus:ring-2 focus:ring-primary/30'
                  )}
                  title="Save as New Version"
                  aria-label="Save as New Version"
                >
                  <Copy className="w-4 h-4" />
                  <span>Save as New Version</span>
                </button>
              </div>

              {/* LINE 2: Zoom controls and Save status */}
              <div className="flex items-center justify-between">
                {/* Zoom controls */}
                <div className="flex items-center gap-2 border border-gray-200 rounded-md bg-gray-50/50 px-2 py-1.5">
                  <button
                    onClick={handleZoomOut}
                    disabled={!canZoomOut}
                    className={cn(
                      'p-1 rounded transition-colors duration-150',
                      'hover:bg-gray-100 active:bg-gray-200',
                      'disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-transparent',
                      'focus:outline-none focus:ring-2 focus:ring-primary/20 focus:ring-inset'
                    )}
                    title="Zoom out"
                    aria-label="Zoom out"
                  >
                    <ZoomOut className="w-4 h-4 text-gray-600" />
                  </button>

                  <div className="w-px h-5 bg-gray-200" />

                  <div className="w-[120px] px-1">
                    <Slider
                      value={[zoomLevel]}
                      onValueChange={handleSliderChange}
                      min={50}
                      max={200}
                      step={5}
                      className="cursor-pointer"
                      aria-label="Zoom level"
                    />
                  </div>

                  <div className="w-px h-5 bg-gray-200" />

                  <button
                    onClick={handleZoomReset}
                    className={cn(
                      'px-2 py-1 min-w-[52px] text-center',
                      'text-xs font-medium text-gray-700',
                      'hover:bg-gray-100 active:bg-gray-200',
                      'transition-colors duration-150',
                      'focus:outline-none focus:ring-2 focus:ring-primary/20 focus:ring-inset',
                      zoomLevel !== DEFAULT_ZOOM && 'text-primary'
                    )}
                    title="Reset to 100%"
                    aria-label={`Current zoom: ${zoomLevel}%. Click to reset to 100%`}
                  >
                    {zoomLevel}%
                  </button>

                  <div className="w-px h-5 bg-gray-200" />

                  <button
                    onClick={handleZoomIn}
                    disabled={!canZoomIn}
                    className={cn(
                      'p-1 rounded transition-colors duration-150',
                      'hover:bg-gray-100 active:bg-gray-200',
                      'disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-transparent',
                      'focus:outline-none focus:ring-2 focus:ring-primary/20 focus:ring-inset'
                    )}
                    title="Zoom in"
                    aria-label="Zoom in"
                  >
                    <ZoomIn className="w-4 h-4 text-gray-600" />
                  </button>
                </div>

                {/* Save status */}
                <div className="flex items-center gap-3 text-xs text-gray-500 whitespace-nowrap">
                  <span>
                    Saved{' '}
                    {new Date(currentDocument.modifiedAt).toLocaleTimeString([], { 
                      hour: '2-digit', 
                      minute: '2-digit' 
                    })}
                  </span>
                  <span className="min-w-[60px]">
                    {saveStatus === 'saved' && (
                      <span className="text-green-500 text-xs flex items-center gap-1">
                        <span className="inline-block w-2 h-2 rounded-full bg-green-500"></span>
                        Saved
                      </span>
                    )}
                    {saveStatus === 'saving' && (
                      <span className="text-yellow-500 text-xs flex items-center gap-1">
                        <span className="inline-block w-2 h-2 rounded-full bg-yellow-500 animate-pulse"></span>
                        Saving...
                      </span>
                    )}
                  </span>
                </div>
              </div>
            </div>

            {/* TipTap editor with zoom */}
            <div
              className="overflow-auto transition-all duration-300 print-editor-wrapper"
              style={{
                paddingLeft: isFocusMode ? '40px' : '60px',
                paddingRight: isFocusMode ? '40px' : '60px',
                paddingTop: isFocusMode ? '60px' : '40px',
                paddingBottom: isFocusMode ? '120px' : '40px',
              }}
            >
              <div
                className="editor-zoom-container"
                style={{
                  transform: `scale(${zoomLevel / 100})`,
                  transformOrigin: 'top left',
                  transition: 'transform 150ms ease-out',
                  width: `${10000 / zoomLevel}%`,
                }}
              >
                {/* This is the actual print content - ID used by print CSS */}
                <div id="print-content">
                  <EditorContent
                    editor={editor}
                    className={cn(
                      'tiptap-editor',
                      'text-base leading-relaxed',
                      'focus-within:outline-none'
                    )}
                  />
                </div>
              </div>
            </div>
          </>
        ) : (
          // No document state
          <div className="flex flex-col items-center justify-center min-h-[600px] text-center p-16">
            <div className="text-gray-400 text-lg font-medium mb-2">
              No document open
            </div>
            <p className="text-gray-400 text-sm max-w-md">
              Create a new document or select one from the left sidebar
            </p>
          </div>
        )}

        {/* Paper shadow effect */}
        <div
          className="absolute inset-0 pointer-events-none rounded-sm"
          style={{
            boxShadow: 'inset 0 0 0 1px rgba(0, 0, 0, 0.03)',
          }}
        />
      </div>

      {/* TipTap styles */}
      <style jsx global>{`
        .tiptap-editor {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
          font-size: 16px;
          line-height: 1.6;
          color: #1D1D1F;
        }

        .tiptap-editor .ProseMirror {
          outline: none;
        }

        .tiptap-editor .ProseMirror p.is-editor-empty:first-child::before {
          content: attr(data-placeholder);
          float: left;
          color: #86868B;
          font-style: italic;
          pointer-events: none;
          height: 0;
        }

        .tiptap-editor p {
          margin-top: 0;
          margin-bottom: 0.75rem;
        }

        .tiptap-editor p:first-child {
          margin-top: 0;
        }

        .tiptap-editor p:last-child {
          margin-bottom: 0;
        }

        .tiptap-editor h1 {
          font-size: 2em;
          font-weight: 700;
          margin-top: 1.5rem;
          margin-bottom: 0.75rem;
          line-height: 1.2;
        }

        .tiptap-editor h1:first-child {
          margin-top: 0;
        }

        .tiptap-editor h2 {
          font-size: 1.5em;
          font-weight: 600;
          margin-top: 1.5rem;
          margin-bottom: 0.75rem;
          line-height: 1.3;
        }

        .tiptap-editor h2:first-child {
          margin-top: 0;
        }

        .tiptap-editor h3 {
          font-size: 1.25em;
          font-weight: 600;
          margin-top: 1.5rem;
          margin-bottom: 0.75rem;
          line-height: 1.4;
        }

        .tiptap-editor h3:first-child {
          margin-top: 0;
        }

        .tiptap-editor ul,
        .tiptap-editor ol {
          padding-left: 1.5rem;
          margin: 0.75rem 0;
        }

        .tiptap-editor ul {
          list-style-type: disc;
        }

        .tiptap-editor ol {
          list-style-type: decimal;
        }

        .tiptap-editor li {
          margin-bottom: 0.25rem;
        }

        .tiptap-editor strong {
          font-weight: 600;
        }

        .tiptap-editor em {
          font-style: italic;
        }

        .tiptap-editor u {
          text-decoration: underline;
        }

        .tiptap-editor a {
          color: #0071E3;
          text-decoration: underline;
          cursor: pointer;
        }

        .tiptap-editor a:hover {
          color: #0062CC;
        }

        .tiptap-editor code {
          background-color: #f5f5f7;
          padding: 0.2em 0.4em;
          border-radius: 3px;
          font-family: monospace;
          font-size: 0.9em;
        }

        .tiptap-editor blockquote {
          border-left: 3px solid #d2d2d7;
          padding-left: 1em;
          margin-left: 0;
          margin-top: 0.75rem;
          margin-bottom: 0.75rem;
          font-style: italic;
          color: #6e6e73;
        }

        .tiptap-editor [data-text-align="left"] {
          text-align: left;
        }

        .tiptap-editor [data-text-align="center"] {
          text-align: center;
        }

        .tiptap-editor [data-text-align="right"] {
          text-align: right;
        }

        .tiptap-editor [data-text-align="justify"] {
          text-align: justify;
        }

        .ProseMirror .ProseMirror-dropcursor {
          border-left: 2px solid #0071E3;
          pointer-events: none;
          position: absolute;
        }

        .editor-zoom-container {
          will-change: transform;
        }

        .editor-zoom-container .ProseMirror {
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
          text-rendering: optimizeLegibility;
        }
      `}</style>
    </div>
  );
});


=== FILE: components/workspace/ExpandTool.tsx ===

/**
 * @file components/workspace/ExpandTool.tsx
 * @description AI-powered copy expansion component
 * 
 * Features:
 * - Expands copy by adding detail, examples, and depth
 * - Real-time loading states
 * - Result preview with insert/copy options
 * - Apple-style design aesthetic
 * - Full integration with Zustand store and TipTap editor
 * 
 * @example
 * ```tsx
 * <ExpandTool editor={editorInstance} />
 * ```
 */

'use client';

import React from 'react';
import { logger } from '@/lib/utils/logger';
import { 
  Maximize2, 
  Check, 
  X,
  Copy,
  FileText,
  Sparkles
} from 'lucide-react';
import { 
  useSelectedText,
  useSelectedHTML,
  useSelectionRange,
  useExpandResult,
  useExpandLoading,
  useExpandError,
  useExpandActions,
} from '@/lib/stores/workspaceStore';
import { insertTextAtSelection } from '@/lib/editor-utils';
import { formatGeneratedContent } from '@/lib/utils/content-formatting';
import { AIWorxButtonLoader } from '@/components/ui/AIWorxLoader';
import type { Editor } from '@tiptap/react';
import { cn } from '@/lib/utils';

interface ExpandToolProps {
  /** TipTap editor instance */
  editor: Editor | null;
  
  /** Optional CSS classes */
  className?: string;
}

/**
 * ExpandTool component - AI-powered copy expansion tool
 */
export function ExpandTool({ editor, className }: ExpandToolProps) {
  // Optimized selectors - only re-render when these specific values change
  const selectedText = useSelectedText();
  const selectedHTML = useSelectedHTML();
  const selectionRange = useSelectionRange();
  const expandResult = useExpandResult();
  const expandLoading = useExpandLoading();
  const expandError = useExpandError();
  const { runExpand, clearExpandResult, insertExpandResult } = useExpandActions();

  // Check if user has text selected
  const hasSelection = selectedText && selectedText.trim().length > 0;
  const canExpand = hasSelection && !expandLoading;

  /**
   * Handle expand action
   * Uses HTML content to preserve formatting (bullets, headings, etc.)
   */
  const handleExpand = async () => {
    // Prefer HTML for formatting preservation, fallback to plain text
    const contentToExpand = selectedHTML || selectedText;
    if (!contentToExpand) return;
    
    logger.log('üìù Expanding with formatting:', {
      hasHTML: !!selectedHTML,
      textLength: selectedText?.length || 0,
      htmlLength: selectedHTML?.length || 0,
    });
    
    await runExpand(contentToExpand);
  };

  /**
   * Handle replace selection with result
   */
  const handleReplaceSelection = (): void => {
    if (!editor || !expandResult || !selectionRange) return;
    
    // Format the HTML result (sanitize and remove excess whitespace)
    const formattedHTML = formatGeneratedContent(expandResult, false);
    
    // Use editor utils to replace the selection with formatted HTML
    const success = insertTextAtSelection(editor, formattedHTML, { isHTML: true });
    
    if (success) {
      // Clear the result after replacing
      clearExpandResult();
      logger.log('‚úÖ Expanded content inserted with formatting preserved');
    }
  };

  /**
   * Handle insert result into editor (replaces entire document)
   */
  const handleInsertResult = (): void => {
    if (!editor) return;
    insertExpandResult(editor);
  };

  /**
   * Handle copy result to clipboard
   */
  const handleCopyResult = async (): Promise<void> => {
    if (!expandResult) return;
    
    try {
      await navigator.clipboard.writeText(expandResult);
      // TODO: Show toast notification
      logger.log('‚úÖ Copied to clipboard');
    } catch (error) {
      logger.error('‚ùå Failed to copy:', error);
    }
  };

  return (
    <div className={cn('flex flex-col gap-6', className)}>
      {/* Header */}
      <div className="flex flex-col gap-2">
        <div className="flex items-center gap-2">
          <Maximize2 className="w-5 h-5 text-apple-blue" />
          <h2 className="text-lg font-semibold text-apple-text-dark">
            Expand Copy
          </h2>
        </div>
        <p className="text-sm text-apple-text-light">
          Add detail, examples, and depth to your copy
        </p>
      </div>

      {/* Selected Text Preview */}
      {hasSelection ? (
        <div className="flex flex-col gap-2">
          <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide flex items-center gap-1.5">
            <Sparkles className="w-3.5 h-3.5 text-apple-blue" />
            Selected Text ({selectedText?.length || 0} characters)
          </label>
          <div className="bg-apple-gray-bg border border-apple-gray-light rounded-lg p-3 max-h-32 overflow-y-auto custom-scrollbar">
            <p className="text-sm text-apple-text-dark whitespace-pre-wrap">
              {selectedText}
            </p>
          </div>
        </div>
      ) : (
        <div className="flex items-center gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
          <Sparkles className="w-4 h-4 text-blue-600 flex-shrink-0" />
          <p className="text-xs text-blue-700">
            Highlight text in the editor to expand
          </p>
        </div>
      )}

      {/* Action Button */}
      <button
        onClick={handleExpand}
        disabled={!canExpand}
        className={cn(
          'w-full py-3 px-4 rounded-lg',
          'font-medium text-sm text-white',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          // Animated gradient when loading
          expandLoading && 'aiworx-gradient-animated cursor-wait',
          // Brand button with blue‚Üípurple active when not loading
          !expandLoading && hasSelection && 'bg-[#006EE6] hover:bg-[#0062CC] active:bg-[#7A3991] active:scale-[0.98] shadow-sm hover:shadow transition-all duration-200',
          // Gray background when truly disabled (not loading)
          !hasSelection && !expandLoading && 'bg-apple-gray-light text-apple-text-light cursor-not-allowed'
        )}
      >
        {expandLoading ? (
          <AIWorxButtonLoader />
        ) : (
          'Expand Copy'
        )}
      </button>

      {/* Helper Text */}
      {!hasSelection && (
        <p className="text-xs text-apple-text-light text-center">
          Select text in the editor to use Expand
        </p>
      )}

      {/* Error Display */}
      {expandError && (
        <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
          <X className="w-4 h-4 text-red-600 flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <p className="text-sm font-medium text-red-900">Error</p>
            <p className="text-xs text-red-700 mt-1">{expandError}</p>
          </div>
          <button
            onClick={clearExpandResult}
            className="text-red-600 hover:text-red-800 focus:outline-none"
            aria-label="Dismiss error"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
      )}

      {/* Result Display */}
      {expandResult && (
        <div className="flex flex-col gap-3 p-4 bg-green-50 border border-green-200 rounded-lg">
          {/* Success Header */}
          <div className="flex items-center gap-2">
            <Check className="w-5 h-5 text-green-600" />
            <span className="text-sm font-medium text-green-900">
              Expansion Complete
            </span>
          </div>

          {/* Result Preview */}
          <div className="bg-white border border-green-200 rounded p-3 max-h-48 overflow-y-auto custom-scrollbar">
            <div 
              className="text-sm text-apple-text-dark prose prose-sm max-w-none"
              dangerouslySetInnerHTML={{ __html: expandResult }}
            />
          </div>

          {/* Action Buttons */}
          <div className="flex gap-2">
            <button
              onClick={handleReplaceSelection}
              className={cn(
                'flex-1 py-2 px-3 rounded-lg',
                'bg-green-600 text-white text-sm font-medium',
                'hover:bg-green-700 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              disabled={!selectionRange}
              title="Replace selected text with expanded version"
            >
              <Check className="w-4 h-4" />
              Replace Selection
            </button>
            <button
              onClick={handleCopyResult}
              className={cn(
                'py-2 px-3 rounded-lg',
                'bg-white border border-green-300 text-green-700 text-sm font-medium',
                'hover:bg-green-50 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              title="Copy to clipboard"
            >
              <Copy className="w-4 h-4" />
            </button>
            <button
              onClick={clearExpandResult}
              className={cn(
                'py-2 px-3 rounded-lg',
                'bg-white border border-green-300 text-green-700 text-sm font-medium',
                'hover:bg-green-50 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              title="Clear result"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>
      )}
    </div>
  );
}


=== FILE: components/workspace/index.ts ===

/**
 * @file components/workspace/index.ts
 * @description Barrel export for workspace components
 */

export { Sidebar } from './Sidebar';
export { EditorArea } from './EditorArea';
export type { EditorAreaHandle } from './EditorArea';
export { Toolbar } from './Toolbar';
export { WorkspaceLayout } from './WorkspaceLayout';
export { ToneShifter } from './ToneShifter';
export { ExpandTool } from './ExpandTool';
export { ShortenTool } from './ShortenTool';
export { TemplatesModal } from './TemplatesModal';
export { TemplateGenerator } from './TemplateGenerator';
export { TemplateFormField } from './TemplateFormField';
export { ProjectSelector } from './ProjectSelector';
export { BrandVoiceTool } from './BrandVoiceTool';
export { BrandAlignmentTool } from './BrandAlignmentTool';
export { PersonasTool } from './PersonasTool';
export { PersonaAlignmentTool } from './PersonaAlignmentTool';
export { PersonaCard } from './PersonaCard';
export { PersonaForm } from './PersonaForm';
export { LeftSidebarContent } from './LeftSidebarContent';
export { RightSidebarContent } from './RightSidebarContent';
export { default as DocumentList } from './DocumentList';
export { ViewModeSelector } from './ViewModeSelector';
export { MyProjectsSlideOut, MY_PROJECTS_PANEL_ID } from './MyProjectsSlideOut';
export { TemplatesSlideOut, TEMPLATES_PANEL_ID } from './TemplatesSlideOut';
export { TemplateFormSlideOut, TEMPLATE_FORM_PANEL_ID } from './TemplateFormSlideOut';
export { BrandVoiceSlideOut, BRAND_VOICE_PANEL_ID } from './BrandVoiceSlideOut';
export { PersonasSlideOut, PERSONAS_PANEL_ID } from './PersonasSlideOut';
export { InsightsSlideOut, INSIGHTS_PANEL_ID } from './InsightsSlideOut';
export type { InsightsPanelType } from './InsightsSlideOut';
export { DeleteProjectModal } from './DeleteProjectModal';
export { BrochureMultiSectionTemplate, BROCHURE_TEMPLATE_PANEL_ID } from './BrochureMultiSectionTemplate';
export { TemplateResumeBanner } from './TemplateResumeBanner';





=== FILE: components/workspace/InsightsSlideOut.tsx ===

/**
 * @file components/workspace/InsightsSlideOut.tsx
 * @description Right slide-out panel for displaying analysis results
 * 
 * Supports two panel types:
 * - Brand Alignment Analysis
 * - Persona Alignment Analysis
 * 
 * Features:
 * - 550px wide right slide-out panel
 * - Clean, spacious layout for readable results
 * - Color-coded scores and feedback sections
 * - Refresh button for re-running analysis
 */

'use client';

import React, { useMemo } from 'react';
import {
  Zap,
  UserCheck,
  Sparkles,
  CheckCircle,
  AlertCircle,
  ThumbsUp,
  ThumbsDown,
  Lightbulb,
  Loader2,
  Target,
  Activity,
  X,
  Wand2,
} from 'lucide-react';
import { SlideOutPanel } from '@/components/ui/SlideOutPanel';
import { Button } from '@/components/ui/button';
import { AIWorxButtonLoader } from '@/components/ui/AIWorxLoader';
import { cn } from '@/lib/utils';
import {
  useWorkspaceStore,
  useBrandAlignmentResult,
  useBrandAlignmentLoading,
  useBrandAlignmentError,
  useBrandAlignmentActions,
  useBrandAlignmentBrandName,
  useBrandAlignmentAnalyzedText,
  usePersonaAlignmentResult,
  usePersonaAlignmentLoading,
  usePersonaAlignmentError,
  usePersonaAlignmentActions,
  usePersonaAlignmentPersonaName,
  usePersonaAlignmentAnalyzedText,
  useSelectedText,
  useOptimizeAlignmentLoading,
  useOptimizeAlignmentActions,
  useProjects,
  useActiveProjectId,
  useInsightsPanelActions,
} from '@/lib/stores/workspaceStore';
import type { Persona } from '@/lib/types/project';
import type { BrandVoice } from '@/lib/types/brand';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/** Unique ID for the insights slide-out panel */
export const INSIGHTS_PANEL_ID = 'insights-panel';

/** Panel type for insights */
export type InsightsPanelType = 'brand-alignment' | 'persona-alignment' | null;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TYPES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

interface InsightsSlideOutProps {
  /** Whether the slide-out is open */
  isOpen: boolean;
  
  /** Callback when slide-out should close */
  onClose: () => void;
  
  /** Type of insights to display */
  panelType: InsightsPanelType;
  
  /** Callback to trigger brand alignment check */
  onCheckBrandAlignment?: () => void;
  
  /** Callback to trigger persona alignment check */
  onCheckPersonaAlignment?: () => void;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HELPER COMPONENTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Score indicator badge with color coding
 */
function ScoreBadge({ 
  score, 
  maxScore = 100,
  size = 'large',
}: { 
  score: number; 
  maxScore?: number;
  size?: 'small' | 'large';
}) {
  const normalizedScore = (score / maxScore) * 100;
  
  let colorClass = 'bg-red-100 text-red-700 border-red-200';
  let icon = <AlertCircle className={size === 'large' ? 'w-5 h-5' : 'w-3 h-3'} />;
  
  if (normalizedScore >= 80) {
    colorClass = 'bg-emerald-100 text-emerald-700 border-emerald-200';
    icon = <CheckCircle className={size === 'large' ? 'w-5 h-5' : 'w-3 h-3'} />;
  } else if (normalizedScore >= 50) {
    colorClass = 'bg-amber-100 text-amber-700 border-amber-200';
    icon = <Activity className={size === 'large' ? 'w-5 h-5' : 'w-3 h-3'} />;
  }
  
  return (
    <span className={cn(
      'inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full font-semibold border',
      size === 'large' ? 'text-lg' : 'text-sm',
      colorClass
    )}>
      {icon}
      {score}%
    </span>
  );
}

/**
 * Section card for displaying lists of items
 */
function ResultSection({
  icon: Icon,
  title,
  items,
  variant = 'default',
}: {
  icon: React.ElementType;
  title: string;
  items: string[];
  variant?: 'default' | 'success' | 'warning' | 'danger' | 'info';
}) {
  if (!items || items.length === 0) return null;
  
  const variantStyles = {
    default: 'bg-gray-50 border-gray-200 text-gray-700',
    success: 'bg-emerald-50 border-emerald-200 text-emerald-700',
    warning: 'bg-amber-50 border-amber-200 text-amber-700',
    danger: 'bg-red-50 border-red-200 text-red-700',
    info: 'bg-purple-50 border-purple-200 text-purple-700',
  };
  
  const iconStyles = {
    default: 'text-gray-500',
    success: 'text-emerald-600',
    warning: 'text-amber-600',
    danger: 'text-red-600',
    info: 'text-purple-600',
  };
  
  const titleStyles = {
    default: 'text-gray-900',
    success: 'text-emerald-900',
    warning: 'text-amber-900',
    danger: 'text-red-900',
    info: 'text-purple-900',
  };
  
  return (
    <div className={cn('rounded-lg border p-4', variantStyles[variant])}>
      <div className="flex items-center gap-2 mb-3">
        <Icon className={cn('w-5 h-5', iconStyles[variant])} />
        <h4 className={cn('font-semibold', titleStyles[variant])}>
          {title}
        </h4>
      </div>
      <ul className="space-y-2">
        {items.map((item, index) => (
          <li key={index} className="flex items-start gap-2 text-sm">
            <span className="mt-1.5 w-1.5 h-1.5 rounded-full bg-current flex-shrink-0" />
            <span>{item}</span>
          </li>
        ))}
      </ul>
    </div>
  );
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PANEL CONTENT COMPONENTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Brand Alignment Panel Content
 */
function BrandAlignmentContent() {
  const result = useBrandAlignmentResult();
  const isLoading = useBrandAlignmentLoading();
  const error = useBrandAlignmentError();
  const brandName = useBrandAlignmentBrandName();
  const analyzedText = useBrandAlignmentAnalyzedText();
  const { clearBrandAlignmentResult } = useBrandAlignmentActions();
  const selectedText = useSelectedText();
  
  // Optimize alignment state
  const optimizeLoading = useOptimizeAlignmentLoading();
  const { runOptimizeAlignment } = useOptimizeAlignmentActions();
  
  // Insights panel actions
  const { closeInsightsPanel } = useInsightsPanelActions();
  
  // Get active project for brand voice data
  const activeProjectId = useActiveProjectId();
  const projects = useProjects();
  const activeProject = projects.find((p) => p.id === activeProjectId);
  
  const hasSelection = selectedText && selectedText.trim().length > 0;
  
  /**
   * Handle rewrite to optimize for brand
   */
  const handleRewriteToOptimize = async () => {
    if (!activeProject?.brandVoice || !result || !analyzedText) return;
    
    // Close the InsightsSlideOut panel immediately
    closeInsightsPanel();
    
    await runOptimizeAlignment(
      analyzedText,
      'brand',
      result,
      activeProject.brandVoice
    );
  };

  if (isLoading) {
    return (
      <div className="flex flex-col items-center justify-center py-16">
        <Loader2 className="w-12 h-12 animate-spin text-apple-blue mb-4" />
        <p className="text-lg font-medium text-gray-900">Analyzing Brand Alignment</p>
        <p className="text-sm text-gray-500 mt-1">This may take a few seconds...</p>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
        <div className="flex items-start gap-3">
          <X className="w-5 h-5 text-red-600 flex-shrink-0 mt-0.5" />
          <div>
            <p className="font-medium text-red-900">Analysis Failed</p>
            <p className="text-sm text-red-700 mt-1">{error}</p>
          </div>
        </div>
      </div>
    );
  }
  
  if (!result) {
    return (
      <div className="space-y-6">
        {!hasSelection ? (
          <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
            <div className="flex items-start gap-3">
              <Sparkles className="w-5 h-5 text-blue-600 flex-shrink-0 mt-0.5" />
              <div>
                <p className="font-medium text-blue-900">Select Text to Analyze</p>
                <p className="text-sm text-blue-700 mt-1">
                  Highlight text in the editor and select a brand voice from the dropdown to analyze.
                </p>
              </div>
            </div>
          </div>
        ) : (
          <div className="text-center py-8">
            <Zap className="w-16 h-16 text-gray-300 mx-auto mb-4" />
            <p className="text-gray-500">
              Select a brand voice and click "Check Brand Alignment" to analyze your text.
            </p>
          </div>
        )}
      </div>
    );
  }
  
  return (
    <div className="space-y-6">
      {/* Brand Name Banner */}
      {brandName && (
        <div className="p-3 bg-blue-100 border border-blue-200 rounded-lg">
          <div className="flex items-center gap-2">
            <Zap className="w-4 h-4 text-blue-600" />
            <p className="text-sm font-medium text-blue-800">
              Analyzing against: <span className="font-semibold">{brandName}</span>
            </p>
          </div>
        </div>
      )}
      
      {/* Overall Score */}
      <div className="p-6 bg-gradient-to-br from-blue-50 to-indigo-50 border border-blue-200 rounded-xl">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-blue-900">Alignment Score</h3>
          <ScoreBadge score={result.score} />
        </div>
        <p className="text-blue-700">{result.assessment}</p>
      </div>
      
      {/* Matches */}
      <ResultSection
        icon={ThumbsUp}
        title="What Matches Your Brand"
        items={result.matches}
        variant="success"
      />
      
      {/* Violations */}
      <ResultSection
        icon={ThumbsDown}
        title="Brand Violations"
        items={result.violations}
        variant="danger"
      />
      
      {/* Recommendations */}
      <ResultSection
        icon={Lightbulb}
        title="Recommendations"
        items={result.recommendations}
        variant="info"
      />
      
      {/* Rewrite to Optimize Button */}
      <button
        onClick={handleRewriteToOptimize}
        disabled={optimizeLoading || !analyzedText}
        className={cn(
          'w-full py-3 px-4 rounded-lg',
          'font-medium text-sm text-white',
          'focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-offset-2',
          'flex items-center justify-center gap-2',
          'transition-all duration-200',
          optimizeLoading 
            ? 'aiworx-gradient-animated cursor-wait'
            : 'bg-[#006EE6] hover:bg-[#7A3991] active:scale-[0.98] shadow-sm hover:shadow',
          (optimizeLoading || !analyzedText) && !optimizeLoading && 'opacity-50 cursor-not-allowed'
        )}
      >
        {optimizeLoading ? (
          <AIWorxButtonLoader />
        ) : (
          <>
            <Wand2 className="w-4 h-4" />
            {`Rewrite to Optimize for ${brandName || 'Brand'}`}
          </>
        )}
      </button>
      
      {/* Clear Results */}
      <Button
        variant="outline"
        className="w-full"
        onClick={clearBrandAlignmentResult}
      >
        Clear Results
      </Button>
    </div>
  );
}

/**
 * Persona Alignment Panel Content
 */
function PersonaAlignmentContent() {
  const result = usePersonaAlignmentResult();
  const isLoading = usePersonaAlignmentLoading();
  const error = usePersonaAlignmentError();
  const personaName = usePersonaAlignmentPersonaName();
  const analyzedText = usePersonaAlignmentAnalyzedText();
  const { clearPersonaAlignmentResult } = usePersonaAlignmentActions();
  const selectedText = useSelectedText();
  
  // Optimize alignment state
  const optimizeLoading = useOptimizeAlignmentLoading();
  const { runOptimizeAlignment } = useOptimizeAlignmentActions();
  
  // Insights panel actions
  const { closeInsightsPanel } = useInsightsPanelActions();
  
  // Get active project for persona data
  const activeProjectId = useActiveProjectId();
  const projects = useProjects();
  const activeProject = projects.find((p) => p.id === activeProjectId);
  
  // Find the persona that was analyzed
  const selectedPersona = activeProject?.personas?.find(
    (p: Persona) => p.name === personaName
  );
  
  const hasSelection = selectedText && selectedText.trim().length > 0;
  
  /**
   * Handle rewrite to optimize for persona
   */
  const handleRewriteToOptimize = async () => {
    if (!selectedPersona || !result || !analyzedText) return;
    
    // Close the InsightsSlideOut panel immediately
    closeInsightsPanel();
    
    await runOptimizeAlignment(
      analyzedText,
      'persona',
      result,
      selectedPersona
    );
  };

  if (isLoading) {
    return (
      <div className="flex flex-col items-center justify-center py-16">
        <Loader2 className="w-12 h-12 animate-spin text-apple-blue mb-4" />
        <p className="text-lg font-medium text-gray-900">Analyzing Persona Alignment</p>
        <p className="text-sm text-gray-500 mt-1">This may take a few seconds...</p>
      </div>
    );
  }
  
  if (error) {
    return (
      <div className="p-4 bg-red-50 border border-red-200 rounded-lg">
        <div className="flex items-start gap-3">
          <X className="w-5 h-5 text-red-600 flex-shrink-0 mt-0.5" />
          <div>
            <p className="font-medium text-red-900">Analysis Failed</p>
            <p className="text-sm text-red-700 mt-1">{error}</p>
          </div>
        </div>
      </div>
    );
  }
  
  if (!result) {
    return (
      <div className="space-y-6">
        {!hasSelection ? (
          <div className="p-4 bg-blue-50 border border-blue-200 rounded-lg">
            <div className="flex items-start gap-3">
              <Sparkles className="w-5 h-5 text-blue-600 flex-shrink-0 mt-0.5" />
              <div>
                <p className="font-medium text-blue-900">Select Text to Analyze</p>
                <p className="text-sm text-blue-700 mt-1">
                  Highlight text in the editor and select a persona from the dropdown to analyze.
                </p>
              </div>
            </div>
          </div>
        ) : (
          <div className="text-center py-8">
            <UserCheck className="w-16 h-16 text-gray-300 mx-auto mb-4" />
            <p className="text-gray-500">
              Select a persona and click "Check Persona Alignment" to analyze your text.
            </p>
          </div>
        )}
      </div>
    );
  }
  
  return (
    <div className="space-y-6">
      {/* Persona Name Banner */}
      {personaName && (
        <div className="p-3 bg-purple-100 border border-purple-200 rounded-lg">
          <div className="flex items-center gap-2">
            <UserCheck className="w-4 h-4 text-purple-600" />
            <p className="text-sm font-medium text-purple-800">
              Analyzing against: <span className="font-semibold">{personaName}</span>
            </p>
          </div>
        </div>
      )}
      
      {/* Overall Score */}
      <div className="p-6 bg-gradient-to-br from-purple-50 to-pink-50 border border-purple-200 rounded-xl">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold text-purple-900">Alignment Score</h3>
          <ScoreBadge score={result.score} />
        </div>
        <p className="text-purple-700">{result.assessment}</p>
      </div>
      
      {/* Strengths */}
      <ResultSection
        icon={ThumbsUp}
        title="Strengths"
        items={result.strengths}
        variant="success"
      />
      
      {/* Areas to Improve */}
      <ResultSection
        icon={AlertCircle}
        title="Areas to Improve"
        items={result.improvements}
        variant="warning"
      />
      
      {/* Recommendations */}
      <ResultSection
        icon={Lightbulb}
        title="Recommendations"
        items={result.recommendations}
        variant="info"
      />
      
      {/* Rewrite to Optimize Button */}
      <button
        onClick={handleRewriteToOptimize}
        disabled={optimizeLoading || !analyzedText || !selectedPersona}
        className={cn(
          'w-full py-3 px-4 rounded-lg',
          'font-medium text-sm text-white',
          'focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-offset-2',
          'flex items-center justify-center gap-2',
          'transition-all duration-200',
          optimizeLoading 
            ? 'aiworx-gradient-animated cursor-wait'
            : 'bg-[#006EE6] hover:bg-[#7A3991] active:scale-[0.98] shadow-sm hover:shadow',
          (optimizeLoading || !analyzedText || !selectedPersona) && !optimizeLoading && 'opacity-50 cursor-not-allowed'
        )}
      >
        {optimizeLoading ? (
          <AIWorxButtonLoader />
        ) : (
          <>
            <Wand2 className="w-4 h-4" />
            {`Rewrite to Optimize for ${personaName || 'Persona'}`}
          </>
        )}
      </button>
      
      {/* Clear Results */}
      <Button
        variant="outline"
        className="w-full"
        onClick={clearPersonaAlignmentResult}
      >
        Clear Results
      </Button>
    </div>
  );
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * InsightsSlideOut - Right slide-out panel for analysis results
 */
export function InsightsSlideOut({
  isOpen,
  onClose,
  panelType,
  onCheckBrandAlignment,
  onCheckPersonaAlignment,
}: InsightsSlideOutProps) {
  // Get panel title and subtitle based on type
  const panelConfig = useMemo(() => {
    switch (panelType) {
      case 'brand-alignment':
        return {
          title: 'Brand Alignment Analysis',
          subtitle: 'See how well your copy aligns with your brand voice',
          icon: Zap,
        };
      case 'persona-alignment':
        return {
          title: 'Persona Alignment Analysis',
          subtitle: 'See how well your copy resonates with your target audience',
          icon: UserCheck,
        };
      default:
        return {
          title: 'Analysis',
          subtitle: 'View analysis results',
          icon: Sparkles,
        };
    }
  }, [panelType]);
  
  // Render content based on panel type
  const renderContent = () => {
    switch (panelType) {
      case 'brand-alignment':
        return <BrandAlignmentContent />;
      case 'persona-alignment':
        return <PersonaAlignmentContent />;
      default:
        return (
          <div className="text-center py-16">
            <Sparkles className="w-16 h-16 text-gray-300 mx-auto mb-4" />
            <p className="text-gray-500">Select an analysis type</p>
          </div>
        );
    }
  };
  
  return (
    <SlideOutPanel
      isOpen={isOpen}
      onClose={onClose}
      side="right"
      title={panelConfig.title}
      subtitle={panelConfig.subtitle}
    >
      {renderContent()}
    </SlideOutPanel>
  );
}

export default InsightsSlideOut;


=== FILE: components/workspace/LeftSidebarContent.tsx ===

/**
 * @file components/workspace/LeftSidebarContent.tsx
 * @description Left sidebar content with document list, tool selector, and collapsible sections
 * 
 * IMPORTANT: This component is extracted to its own file to prevent
 * infinite re-render loops. Defining components inline inside parent
 * components causes React to treat them as new component types on
 * every render, triggering unmount/remount cycles.
 * 
 * Features:
 * - Project selector section with slide-out panel trigger
 * - Document list with version control
 * - AI@Worx Templates slide-out browser
 * - Collapsible tool sections (My Copy Optimizer, My Brand & Audience)
 * - Active tool highlighting
 * - My Projects slide-out for full project navigation
 * - Templates slide-out for browsing and selecting templates
 */

'use client';

import React, { useState, useCallback, useMemo, useEffect } from 'react';
import { logger } from '@/lib/utils/logger';
import Image from 'next/image';
import { 
  Sparkles, 
  ChevronRight, 
  ChevronDown, 
  PanelLeftOpen, 
  Folder as FolderIcon,
  Zap,
  UserCheck,
  Target,
  Loader2,
  AlertCircle,
} from 'lucide-react';
import { MyProjectsSlideOut, MY_PROJECTS_PANEL_ID } from '@/components/workspace/MyProjectsSlideOut';
import { TemplatesSlideOut, TEMPLATES_PANEL_ID } from '@/components/workspace/TemplatesSlideOut';
import { BRAND_VOICE_PANEL_ID } from '@/components/workspace/BrandVoiceSlideOut';
import { PERSONAS_PANEL_ID } from '@/components/workspace/PersonasSlideOut';
import { InsightsSlideOut, INSIGHTS_PANEL_ID, type InsightsPanelType } from '@/components/workspace/InsightsSlideOut';
import { 
  useWorkspaceStore, 
  useActiveProjectId, 
  useProjects,
  useActiveInsightsPanel,
  useInsightsPanelActions,
  useSelectedText,
  useBrandAlignmentActions,
  usePersonaAlignmentActions,
} from '@/lib/stores/workspaceStore';
import { useIsSlideOutOpen, useSlideOutActions } from '@/lib/stores/slideOutStore';
import { SECTIONS, getToolsBySection } from '@/lib/tools';
import { cn } from '@/lib/utils';
import type { ProjectDocument } from '@/lib/types/project';
import type { BrandVoice } from '@/lib/types/brand';
import type { Persona } from '@/lib/types/project';

// ============================================================================
// Types for Brand Voice and Persona selectors
// ============================================================================

/**
 * Brand voice with project context for display in selectors
 */
interface BrandVoiceWithProject {
  id: string;
  projectId: string | null;
  projectName: string | null;
  brandName: string;
  brandTone: string;
  approvedPhrases: string[];
  forbiddenWords: string[];
  brandValues: string[];
  missionStatement: string;
  createdAt: string;
  updatedAt: string;
}

/**
 * Persona with project context for display in selectors
 */
interface PersonaWithProject {
  id: string;
  projectId: string | null;
  projectName: string | null;
  name: string;
  photoUrl?: string;
  demographics: string;
  psychographics: string;
  painPoints: string;
  languagePatterns: string;
  goals: string;
  createdAt: string;
  updatedAt: string;
}

/**
 * Props for LeftSidebarContent
 */
interface LeftSidebarContentProps {
  /** Callback when a document is clicked in the DocumentList */
  onDocumentClick?: (doc: ProjectDocument) => void;
}

/**
 * Left sidebar content - Tool selector with collapsible sections
 * 
 * Extracted to prevent infinite re-render loops when defined inline.
 */
export function LeftSidebarContent({ onDocumentClick }: LeftSidebarContentProps) {
  const activeToolId = useWorkspaceStore((state) => state.activeToolId);
  const activeProjectId = useActiveProjectId();
  const projects = useProjects();
  const selectedText = useSelectedText();
  
  // Slide-out state
  const isProjectsSlideOutOpen = useIsSlideOutOpen(MY_PROJECTS_PANEL_ID);
  const isTemplatesSlideOutOpen = useIsSlideOutOpen(TEMPLATES_PANEL_ID);
  const { openSlideOut, closeSlideOut } = useSlideOutActions();
  
  // Insights panel state
  const activeInsightsPanel = useActiveInsightsPanel();
  const { openInsightsPanel, closeInsightsPanel } = useInsightsPanelActions();
  const { runBrandAlignment, clearBrandAlignmentResult } = useBrandAlignmentActions();
  const { runPersonaAlignment, clearPersonaAlignmentResult } = usePersonaAlignmentActions();
  
  // Get active project for brand voice and personas
  const activeProject = useMemo(
    () => projects.find((p) => p.id === activeProjectId),
    [projects, activeProjectId]
  );
  
  // Track which sections are expanded (all start collapsed by default)
  const [expandedSections, setExpandedSections] = useState<Set<string>>(
    new Set([])
  );
  
  // ============================================================================
  // Brand Voice & Persona Selector State
  // ============================================================================
  
  // All brand voices for the user (across all projects)
  const [allBrandVoices, setAllBrandVoices] = useState<BrandVoiceWithProject[]>([]);
  const [brandVoicesLoading, setBrandVoicesLoading] = useState(true);
  const [brandVoicesError, setBrandVoicesError] = useState<string | null>(null);
  
  // All personas for the user (across all projects)
  const [allPersonas, setAllPersonas] = useState<PersonaWithProject[]>([]);
  const [personasLoading, setPersonasLoading] = useState(true);
  const [personasError, setPersonasError] = useState<string | null>(null);
  
  // Selected brand voice and persona IDs for insights analysis
  const [selectedBrandVoiceId, setSelectedBrandVoiceId] = useState<string | null>(null);
  const [selectedPersonaId, setSelectedPersonaId] = useState<string | null>(null);
  
  // Get the selected brand voice and persona objects
  const selectedBrandVoice = useMemo(
    () => allBrandVoices.find((bv) => bv.id === selectedBrandVoiceId),
    [allBrandVoices, selectedBrandVoiceId]
  );
  
  const selectedPersona = useMemo(
    () => allPersonas.find((p) => p.id === selectedPersonaId),
    [allPersonas, selectedPersonaId]
  );
  
  // ============================================================================
  // Fetch Brand Voices and Personas
  // ============================================================================
  
  useEffect(() => {
    const fetchAllBrandVoices = async () => {
      try {
        setBrandVoicesLoading(true);
        setBrandVoicesError(null);
        
        const response = await fetch('/api/db/all-brand-voices');
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || 'Failed to fetch brand voices');
        }
        
        const data = await response.json();
        setAllBrandVoices(data);
      } catch (error) {
        logger.error('Failed to fetch brand voices:', error);
        setBrandVoicesError(error instanceof Error ? error.message : 'Failed to load brand voices');
      } finally {
        setBrandVoicesLoading(false);
      }
    };
    
    const fetchAllPersonas = async () => {
      try {
        setPersonasLoading(true);
        setPersonasError(null);
        
        const response = await fetch('/api/db/all-personas');
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || 'Failed to fetch personas');
        }
        
        const data = await response.json();
        setAllPersonas(data);
      } catch (error) {
        logger.error('Failed to fetch personas:', error);
        setPersonasError(error instanceof Error ? error.message : 'Failed to load personas');
      } finally {
        setPersonasLoading(false);
      }
    };
    
    fetchAllBrandVoices();
    fetchAllPersonas();
  }, []);
  
  // Clear results when selection changes
  const handleBrandVoiceChange = useCallback((id: string | null) => {
    setSelectedBrandVoiceId(id);
    clearBrandAlignmentResult();
  }, [clearBrandAlignmentResult]);
  
  const handlePersonaChange = useCallback((id: string | null) => {
    setSelectedPersonaId(id);
    clearPersonaAlignmentResult();
  }, [clearPersonaAlignmentResult]);
  
  // NOTE: Project initialization is now handled in the parent WorkspacePage
  // This prevents duplicate refreshProjects() calls that could cause issues
  
  /**
   * Open the My Projects slide-out panel
   */
  const openProjectsSlideOut = useCallback(() => {
    openSlideOut(MY_PROJECTS_PANEL_ID);
  }, [openSlideOut]);
  
  /**
   * Close the My Projects slide-out panel
   */
  const closeProjectsSlideOut = useCallback(() => {
    closeSlideOut(MY_PROJECTS_PANEL_ID);
  }, [closeSlideOut]);
  
  /**
   * Open the Templates slide-out panel
   */
  const openTemplatesSlideOut = useCallback(() => {
    openSlideOut(TEMPLATES_PANEL_ID);
  }, [openSlideOut]);
  
  /**
   * Close the Templates slide-out panel
   */
  const closeTemplatesSlideOut = useCallback(() => {
    closeSlideOut(TEMPLATES_PANEL_ID);
  }, [closeSlideOut]);
  
  /**
   * Handle document click from slide-out panel
   */
  const handleSlideOutDocumentClick = useCallback((doc: ProjectDocument) => {
    onDocumentClick?.(doc);
  }, [onDocumentClick]);
  
  /**
   * Handle Check Brand Alignment click
   * Uses the selected brand voice from the dropdown
   */
  const handleCheckBrandAlignment = useCallback(() => {
    // Open the slide-out panel
    openInsightsPanel('brand-alignment');
    
    // If we have selected text and a selected brand voice, run the analysis
    if (selectedText && selectedText.trim() && selectedBrandVoice) {
      // Convert BrandVoiceWithProject to BrandVoice format for the API
      const brandVoice: BrandVoice = {
        brandName: selectedBrandVoice.brandName,
        brandTone: selectedBrandVoice.brandTone,
        approvedPhrases: selectedBrandVoice.approvedPhrases,
        forbiddenWords: selectedBrandVoice.forbiddenWords,
        brandValues: selectedBrandVoice.brandValues,
        missionStatement: selectedBrandVoice.missionStatement,
      };
      runBrandAlignment(selectedText, brandVoice);
    }
  }, [openInsightsPanel, selectedText, selectedBrandVoice, runBrandAlignment]);
  
  /**
   * Handle Check Persona Alignment click
   * Uses the selected persona from the dropdown
   */
  const handleCheckPersonaAlignment = useCallback(() => {
    // Open the slide-out panel
    openInsightsPanel('persona-alignment');
    
    // If we have selected text and a selected persona, run the analysis
    if (selectedText && selectedText.trim() && selectedPersona) {
      // Convert PersonaWithProject to Persona format for the API
      const persona: Persona = {
        id: selectedPersona.id,
        name: selectedPersona.name,
        photoUrl: selectedPersona.photoUrl,
        demographics: selectedPersona.demographics,
        psychographics: selectedPersona.psychographics,
        painPoints: selectedPersona.painPoints,
        languagePatterns: selectedPersona.languagePatterns,
        goals: selectedPersona.goals,
        createdAt: selectedPersona.createdAt,
        updatedAt: selectedPersona.updatedAt,
      };
      runPersonaAlignment(selectedText, persona);
    }
  }, [openInsightsPanel, selectedText, selectedPersona, runPersonaAlignment]);
  
  /**
   * Close insights panel
   */
  const handleCloseInsightsPanel = useCallback(() => {
    closeInsightsPanel();
  }, [closeInsightsPanel]);

  /**
   * Clear all tool states before switching tools
   * Uses getState() to get latest store functions without causing re-renders
   */
  const clearAllToolStates = useCallback(() => {
    const store = useWorkspaceStore.getState();
    // Clear Copy Optimizer results
    store.clearToneShiftResult();
    store.clearExpandResult();
    store.clearShortenResult();
    store.clearRewriteChannelResult();
    
    // Clear Brand & Audience results
    store.clearBrandAlignmentResult();
    
    // Clear template state
    store.setSelectedTemplateId(null);
    store.setIsGeneratingTemplate(false);
  }, []);

  /**
   * Handle tool selection with automatic state clearing
   * Special handling for brand-voice and personas which open slide-outs
   */
  const handleToolClick = useCallback((toolId: string) => {
    const currentToolId = useWorkspaceStore.getState().activeToolId;
    
    // Special handling for brand-voice and personas - open slide-outs instead
    if (toolId === 'brand-voice') {
      openSlideOut(BRAND_VOICE_PANEL_ID);
      return;
    }
    
    if (toolId === 'personas') {
      openSlideOut(PERSONAS_PANEL_ID);
      return;
    }
    
    // Only clear if switching to a different tool
    if (currentToolId !== toolId) {
      clearAllToolStates();
    }
    useWorkspaceStore.getState().setActiveTool(toolId);
  }, [clearAllToolStates, openSlideOut]);

  /**
   * Toggle section expansion
   */
  const toggleSection = useCallback((sectionId: string) => {
    setExpandedSections((prev) => {
      const next = new Set(prev);
      if (next.has(sectionId)) {
        next.delete(sectionId);
      } else {
        next.add(sectionId);
      }
      return next;
    });
  }, []);

  const isProjectsExpanded = expandedSections.has('projects');

  return (
    <div className="space-y-1">
      {/* CopyWorx Logo Header */}
      <div className="bg-gray-200 -mx-2 -mt-6 mb-4 py-4 flex items-center justify-center">
        <Image
          src="/copyworx-studio-logo.png"
          alt="CopyWorx Studio"
          width={140}
          height={140}
          className="object-contain ml-2"
          priority
          unoptimized
        />
      </div>
      
      {/* Content with padding */}
      <div className="px-4 space-y-1">
        {/* My Projects Slide-Out Panel */}
        <MyProjectsSlideOut
        isOpen={isProjectsSlideOutOpen}
        onClose={closeProjectsSlideOut}
        onDocumentClick={handleSlideOutDocumentClick}
      />
      
      {/* Templates Slide-Out Panel */}
      <TemplatesSlideOut
        isOpen={isTemplatesSlideOutOpen}
        onClose={closeTemplatesSlideOut}
      />
      
      {/* Insights Slide-Out Panel */}
      <InsightsSlideOut
        isOpen={activeInsightsPanel !== null}
        onClose={handleCloseInsightsPanel}
        panelType={activeInsightsPanel}
        onCheckBrandAlignment={handleCheckBrandAlignment}
        onCheckPersonaAlignment={handleCheckPersonaAlignment}
      />
      
      {/* MY PROJECTS SECTION */}
      <div className="space-y-1" data-tour="projects">
        {/* Section Header - Click to open slide-out */}
        <div className="flex items-center gap-1">
          {/* Main header button - opens slide-out */}
          <button
            onClick={() => {
              openProjectsSlideOut();
            }}
            className={cn(
              'flex-1 flex items-center justify-between px-3 py-2.5 rounded-lg',
              'bg-gray-50 hover:bg-gray-100 transition-colors duration-200',
              'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
              'relative pl-5 border-l-[3px] border-transparent',
              'before:content-[""] before:absolute before:left-0 before:top-0 before:bottom-0',
              'before:w-[3px] before:rounded-l-lg',
              'before:bg-gradient-to-b before:from-[#006EE6] before:to-[#7A3991]'
            )}
            aria-label="Open My Projects navigator"
          >
            <div className="flex items-center gap-2">
              <Sparkles className="w-4 h-4 text-apple-text-dark" />
              <span className="font-semibold text-sm text-apple-text-dark uppercase tracking-wide">
                My Projects
              </span>
            </div>
            <PanelLeftOpen className="w-4 h-4 text-gray-400" />
          </button>
          
          {/* Local collapse toggle button */}
          <button
            onClick={(e) => {
              e.stopPropagation();
              toggleSection('projects');
            }}
            className={cn(
              'p-2 rounded-lg',
              'text-gray-400 hover:text-gray-600 hover:bg-apple-gray-bg',
              'transition-colors duration-200',
              'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2'
            )}
            title="Show/hide project selector"
            aria-label="Toggle project selector visibility"
          >
            {isProjectsExpanded ? (
              <ChevronDown className="w-4 h-4" />
            ) : (
              <ChevronRight className="w-4 h-4" />
            )}
          </button>
        </div>

        {/* Projects Content - Collapsed View - Simple project list */}
        {isProjectsExpanded && (
          <div className="py-2 space-y-1">
            {projects.length > 0 ? (
              projects.map((project) => (
                <button
                  key={project.id}
                  onClick={() => {
                    openProjectsSlideOut();
                  }}
                  className={cn(
                    'w-full text-left px-3 py-2 rounded-lg',
                    'text-sm transition-all duration-200',
                    'hover:bg-apple-gray-bg',
                    'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
                    project.id === activeProjectId
                      ? 'bg-apple-blue/10 text-apple-blue font-medium'
                      : 'text-gray-700 hover:text-gray-900'
                  )}
                  title={`Open ${project.name} in navigator`}
                >
                  <div className="flex items-center gap-2">
                    <FolderIcon className={cn(
                      'w-4 h-4 flex-shrink-0',
                      project.id === activeProjectId ? 'text-apple-blue' : 'text-gray-400'
                    )} />
                    <span className="truncate">{project.name}</span>
                  </div>
                </button>
              ))
            ) : (
              <div className="px-3 py-4 text-center">
                <p className="text-xs text-gray-500">No projects yet</p>
              </div>
            )}
          </div>
        )}
      </div>

      {/* Divider */}
      <div className="border-t border-gray-200 my-2" />

      {/* AI@WORX TEMPLATES SECTION */}
      <div className="mb-2" data-tour="templates">
        <button
          onClick={openTemplatesSlideOut}
          className={cn(
            'w-full flex items-center justify-between px-3 py-3 rounded-lg',
            'bg-gray-50 hover:bg-gray-100 transition-all duration-200',
            'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
            'relative pl-5 border-l-[3px] border-transparent',
            'before:content-[""] before:absolute before:left-0 before:top-0 before:bottom-0',
            'before:w-[3px] before:rounded-l-lg',
            'before:bg-gradient-to-b before:from-[#006EE6] before:to-[#7A3991]',
            'group'
          )}
        >
          <div className="flex items-center gap-3">
            <Sparkles className="w-5 h-5 text-blue-500 group-hover:text-blue-600 transition-colors" />
            <div className="text-left">
              <div className="font-medium text-sm text-apple-text-dark">
                AI@Worx‚Ñ¢ Templates
              </div>
              <div className="text-xs text-gray-500">
                Browse templates
              </div>
            </div>
          </div>
          <PanelLeftOpen className="w-4 h-4 text-gray-400" />
        </button>
      </div>

      {/* Divider */}
      <div className="border-t border-gray-200 my-2" />

      {/* EXISTING TOOL SECTIONS - Exclude 'insights' section (replaced by AI@Worx‚Ñ¢ Live) */}
      {SECTIONS.filter(section => section.id !== 'insights').map((section) => {
        // Determine data-tour attribute for specific sections
        const dataTourAttr = section.id === 'optimizer' ? 'copy-optimizer' 
          : section.id === 'brand' ? 'brand-voice' 
          : undefined;
        const tools = getToolsBySection(section.id);
        const isExpanded = expandedSections.has(section.id);
        const SectionIcon = section.icon;

        return (
          <div key={section.id} className="space-y-1" data-tour={dataTourAttr}>
            {/* Section Header - Collapsible */}
            <button
              onClick={() => toggleSection(section.id)}
              className={cn(
                'w-full flex items-center justify-between px-3 py-2.5 rounded-lg',
                'bg-gray-50 hover:bg-gray-100 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
                'relative pl-5 border-l-[3px] border-transparent',
                'before:content-[""] before:absolute before:left-0 before:top-0 before:bottom-0',
                'before:w-[3px] before:rounded-l-lg',
                'before:bg-gradient-to-b before:from-[#006EE6] before:to-[#7A3991]'
              )}
              aria-expanded={isExpanded}
            >
              <div className="flex items-center gap-2">
                <SectionIcon className="w-4 h-4 text-apple-text-dark" />
                <span className="font-semibold text-sm text-apple-text-dark uppercase tracking-wide">
                  {section.name}
                </span>
              </div>
              {isExpanded ? (
                <ChevronDown className="w-4 h-4 text-gray-400" />
              ) : (
                <ChevronRight className="w-4 h-4 text-gray-400" />
              )}
            </button>

            {/* Tools in Section */}
            {isExpanded && (
              <div className="ml-6 space-y-1">
                {tools.map((tool) => {
                  const ToolIcon = tool.icon;
                  const isActive = activeToolId === tool.id;

                  return (
                    <button
                      key={tool.id}
                      onClick={() => {
                        logger.log('üñ±Ô∏è Tool clicked:', tool.id);
                        handleToolClick(tool.id);
                      }}
                      className={cn(
                        'w-full text-left p-2 rounded-lg',
                        'transition-all duration-200',
                        'flex items-center gap-2',
                        'group',
                        'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
                        isActive
                          ? 'bg-apple-blue text-white shadow-sm'
                          : 'hover:bg-apple-gray-bg text-apple-text-dark'
                      )}
                      title={tool.description}
                    >
                      <ToolIcon
                        className={cn(
                          'w-4 h-4 flex-shrink-0',
                          isActive ? 'text-white' : 'text-apple-blue'
                        )}
                      />
                      <span className="text-sm font-medium flex-1">{tool.name}</span>
                      {tool.badge && (
                        <span
                          className={cn(
                            'px-1.5 py-0.5 text-[10px] font-bold rounded uppercase',
                            isActive
                              ? 'bg-white/20 text-white'
                              : 'bg-green-100 text-green-700'
                          )}
                        >
                          {tool.badge}
                        </span>
                      )}
                    </button>
                  );
                })}
              </div>
            )}
          </div>
        );
      })}

      {/* Divider */}
      <div className="border-t border-gray-200 my-2" />

      {/* MY INSIGHTS SECTION - Dedicated buttons for alignment checks */}
      <div className="space-y-1" data-tour="insights">
        {/* Section Header */}
        <button
          onClick={() => toggleSection('insights')}
          className={cn(
            'w-full flex items-center justify-between px-3 py-2.5 rounded-lg',
            'bg-gray-50 hover:bg-gray-100 transition-colors duration-200',
            'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
            'relative pl-5 border-l-[3px] border-transparent',
            'before:content-[""] before:absolute before:left-0 before:top-0 before:bottom-0',
            'before:w-[3px] before:rounded-l-lg',
            'before:bg-gradient-to-b before:from-[#006EE6] before:to-[#7A3991]'
          )}
          aria-expanded={expandedSections.has('insights')}
        >
          <div className="flex items-center gap-2">
            <Target className="w-4 h-4 text-apple-text-dark" />
            <span className="font-semibold text-sm text-apple-text-dark uppercase tracking-wide">
              My Insights
            </span>
          </div>
          {expandedSections.has('insights') ? (
            <ChevronDown className="w-4 h-4 text-gray-400" />
          ) : (
            <ChevronRight className="w-4 h-4 text-gray-400" />
          )}
        </button>

        {/* Insights Content */}
        {expandedSections.has('insights') && (
          <div className="ml-2 space-y-4 py-2">
            {/* ============================================================ */}
            {/* BRAND ALIGNMENT SECTION */}
            {/* ============================================================ */}
            <div className="space-y-2">
              {/* Brand Voice Selector Label */}
              <label className="block text-xs font-medium text-gray-600 uppercase tracking-wide px-2">
                Select Brand Voice
              </label>
              
              {/* Brand Voice Selector Dropdown */}
              {brandVoicesLoading ? (
                <div className="flex items-center gap-2 px-3 py-2 text-sm text-gray-500">
                  <Loader2 className="w-4 h-4 animate-spin" />
                  <span>Loading brand voices...</span>
                </div>
              ) : brandVoicesError ? (
                <div className="flex items-center gap-2 px-3 py-2 text-sm text-red-600">
                  <AlertCircle className="w-4 h-4" />
                  <span>{brandVoicesError}</span>
                </div>
              ) : allBrandVoices.length === 0 ? (
                <div className="px-3 py-2 text-sm text-amber-600 bg-amber-50 rounded-lg">
                  <p className="font-medium">Create a brand voice first</p>
                  <p className="text-xs text-amber-500 mt-1">Go to Brand & Audience to set up your brand voice</p>
                </div>
              ) : (
                <select
                  value={selectedBrandVoiceId || ''}
                  onChange={(e) => handleBrandVoiceChange(e.target.value || null)}
                  className={cn(
                    'w-full px-3 py-2 rounded-lg border text-sm',
                    'bg-white text-gray-900',
                    'border-gray-200 focus:border-apple-blue focus:ring-2 focus:ring-apple-blue/20',
                    'transition-colors duration-200',
                    'cursor-pointer'
                  )}
                >
                  <option value="">Choose a brand voice...</option>
                  {allBrandVoices.map((bv) => (
                    <option key={bv.id} value={bv.id}>
                      {bv.brandName}{bv.projectName ? ` (${bv.projectName})` : ''}
                    </option>
                  ))}
                </select>
              )}
              
              {/* Check Brand Alignment Button - Shows blue when brand voice selected */}
              <button
                onClick={handleCheckBrandAlignment}
                disabled={!selectedBrandVoiceId || allBrandVoices.length === 0}
                className={cn(
                  'w-full text-left p-2.5 rounded-lg',
                  'transition-all duration-200',
                  'flex items-center gap-2',
                  'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
                  !selectedBrandVoiceId || allBrandVoices.length === 0
                    ? 'bg-gray-100 text-gray-400 cursor-not-allowed'
                    : 'bg-[#006EE6] text-white shadow-sm hover:bg-[#7A3991] active:scale-[0.98]'
                )}
                title={
                  !selectedBrandVoiceId 
                    ? 'Select a brand voice first' 
                    : 'Check how well your copy aligns with your brand voice'
                }
              >
                <Zap
                  className={cn(
                    'w-4 h-4 flex-shrink-0',
                    !selectedBrandVoiceId || allBrandVoices.length === 0
                      ? 'text-gray-400'
                      : 'text-white'
                  )}
                />
                <span className="text-sm font-medium flex-1">Check Brand Alignment</span>
              </button>
            </div>
            
            {/* Divider */}
            <div className="border-t border-gray-200 mx-2" />
            
            {/* ============================================================ */}
            {/* PERSONA ALIGNMENT SECTION */}
            {/* ============================================================ */}
            <div className="space-y-2">
              {/* Persona Selector Label */}
              <label className="block text-xs font-medium text-gray-600 uppercase tracking-wide px-2">
                Select Persona
              </label>
              
              {/* Persona Selector Dropdown */}
              {personasLoading ? (
                <div className="flex items-center gap-2 px-3 py-2 text-sm text-gray-500">
                  <Loader2 className="w-4 h-4 animate-spin" />
                  <span>Loading personas...</span>
                </div>
              ) : personasError ? (
                <div className="flex items-center gap-2 px-3 py-2 text-sm text-red-600">
                  <AlertCircle className="w-4 h-4" />
                  <span>{personasError}</span>
                </div>
              ) : allPersonas.length === 0 ? (
                <div className="px-3 py-2 text-sm text-amber-600 bg-amber-50 rounded-lg">
                  <p className="font-medium">Create a persona first</p>
                  <p className="text-xs text-amber-500 mt-1">Go to Brand & Audience to set up your personas</p>
                </div>
              ) : (
                <select
                  value={selectedPersonaId || ''}
                  onChange={(e) => handlePersonaChange(e.target.value || null)}
                  className={cn(
                    'w-full px-3 py-2 rounded-lg border text-sm',
                    'bg-white text-gray-900',
                    'border-gray-200 focus:border-apple-blue focus:ring-2 focus:ring-apple-blue/20',
                    'transition-colors duration-200',
                    'cursor-pointer'
                  )}
                >
                  <option value="">Choose a persona...</option>
                  {allPersonas.map((p) => (
                    <option key={p.id} value={p.id}>
                      {p.name}{p.projectName ? ` (${p.projectName})` : ''}
                    </option>
                  ))}
                </select>
              )}
              
              {/* Check Persona Alignment Button - Shows blue when persona selected */}
              <button
                onClick={handleCheckPersonaAlignment}
                disabled={!selectedPersonaId || allPersonas.length === 0}
                className={cn(
                  'w-full text-left p-2.5 rounded-lg',
                  'transition-all duration-200',
                  'flex items-center gap-2',
                  'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
                  !selectedPersonaId || allPersonas.length === 0
                    ? 'bg-gray-100 text-gray-400 cursor-not-allowed'
                    : 'bg-[#006EE6] text-white shadow-sm hover:bg-[#7A3991] active:scale-[0.98]'
                )}
                title={
                  !selectedPersonaId 
                    ? 'Select a persona first' 
                    : 'Check how well your copy resonates with your target persona'
                }
              >
                <UserCheck
                  className={cn(
                    'w-4 h-4 flex-shrink-0',
                    !selectedPersonaId || allPersonas.length === 0
                      ? 'text-gray-400'
                      : 'text-white'
                  )}
                />
                <span className="text-sm font-medium flex-1">Check Persona Alignment</span>
              </button>
            </div>
          </div>
        )}
      </div>
      </div>
    </div>
  );
}


=== FILE: components/workspace/MyProjectsSlideOut.tsx ===

/**
 * @file components/workspace/MyProjectsSlideOut.tsx
 * @description Full-featured project navigator slide-out panel
 * 
 * Features:
 * - Search/filter bar
 * - Project tree with Projects ‚Üí Folders ‚Üí Documents hierarchy
 * - Snippets section (project-scoped)
 * - Full document names (no truncation)
 * - Current document highlighting
 * - New Project / New Folder buttons
 * - Metadata display (modified date, word count)
 * - Click document to open and close panel
 * 
 * @example
 * ```tsx
 * <MyProjectsSlideOut
 *   isOpen={isOpen}
 *   onClose={() => setIsOpen(false)}
 *   onDocumentClick={(doc) => handleDocumentSelect(doc)}
 * />
 * ```
 */

'use client';

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { logger } from '@/lib/utils/logger';
import {
  Search,
  FolderPlus,
  FilePlus,
  ChevronRight,
  ChevronDown,
  Folder as FolderIcon,
  FileText,
  Trash2,
  Pencil,
  Plus,
  Calendar,
  Type,
  MoreHorizontal,
  Check,
  X,
  Scissors,
  Volume2,
  Users,
} from 'lucide-react';
import { SlideOutPanel } from '@/components/ui/SlideOutPanel';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { cn } from '@/lib/utils';
import {
  useWorkspaceStore,
  useProjects,
  useActiveProjectId,
  useActiveDocumentId,
  useProjectActions,
  useDocumentActions,
} from '@/lib/stores/workspaceStore';
import { useSlideOutActions } from '@/lib/stores/slideOutStore';
import {
  getAllDocuments,
  createDocument,
  deleteDocument,
  updateDocument,
  getAllFolders,
  createFolder,
  deleteFolder,
  updateFolder,
  createProject,
  updateProject,
  deleteProject as deleteProjectFromStorage,
} from '@/lib/storage/unified-storage';
import type { Project, ProjectDocument, Folder } from '@/lib/types/project';
import type { Snippet } from '@/lib/types/snippet';
import { SnippetSection } from './SnippetSection';
import { SnippetModals } from './SnippetModals';
import { useSnippetActions, useSnippetStore } from '@/lib/stores/snippetStore';
import { DeleteProjectModal } from './DeleteProjectModal';
import { BrandVoiceSection } from './BrandVoiceSection';
import { PersonaSection } from './PersonaSection';

// ============================================================================
// Constants
// ============================================================================

/** Slide-out panel ID for state management */
export const MY_PROJECTS_PANEL_ID = 'my-projects';

// ============================================================================
// Types
// ============================================================================

interface MyProjectsSlideOutProps {
  /** Whether the panel is open */
  isOpen: boolean;
  /** Callback when panel should close */
  onClose: () => void;
  /** Callback when a document is clicked */
  onDocumentClick?: (doc: ProjectDocument) => void;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Format date to relative time (e.g., "2 days ago", "Just now")
 */
function formatRelativeDate(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);

  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  if (diffDays < 7) return `${diffDays}d ago`;
  
  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
}

/**
 * Group documents by baseTitle
 */
function groupDocumentsByBaseTitle(docs: ProjectDocument[]): Map<string, ProjectDocument[]> {
  const grouped = new Map<string, ProjectDocument[]>();
  
  for (const doc of docs) {
    const existing = grouped.get(doc.baseTitle) || [];
    existing.push(doc);
    grouped.set(doc.baseTitle, existing);
  }
  
  // Sort versions ascending
  for (const [baseTitle, versions] of grouped) {
    versions.sort((a, b) => a.version - b.version);
    grouped.set(baseTitle, versions);
  }
  
  return grouped;
}

// ============================================================================
// Sub-Components
// ============================================================================

/**
 * Document row with metadata
 */
interface DocumentRowProps {
  doc: ProjectDocument;
  isSelected: boolean;
  isEditing: boolean;
  editValue: string;
  onSelect: (doc: ProjectDocument) => void;
  onStartEdit: () => void;
  onEditChange: (value: string) => void;
  onSaveEdit: () => void;
  onCancelEdit: () => void;
  onDelete: () => void;
  indentLevel?: number;
}

function DocumentRow({
  doc,
  isSelected,
  isEditing,
  editValue,
  onSelect,
  onStartEdit,
  onEditChange,
  onSaveEdit,
  onCancelEdit,
  onDelete,
  indentLevel = 0,
}: DocumentRowProps) {
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      onSaveEdit();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      onCancelEdit();
    }
  };

  return (
    <div
      className={cn(
        'group flex items-start gap-1.5 px-2 py-1.5 rounded-md cursor-pointer',
        'transition-colors duration-150',
        isSelected
          ? 'bg-blue-50 border border-blue-200'
          : 'hover:bg-gray-50'
      )}
      style={{ paddingLeft: `${8 + indentLevel * 12}px` }}
      onClick={() => !isEditing && onSelect(doc)}
    >
      <FileText className={cn(
        'h-3.5 w-3.5 flex-shrink-0 mt-px',
        isSelected ? 'text-blue-600' : 'text-gray-400'
      )} />
      
      {isEditing ? (
        <div className="flex-1 flex items-center gap-1.5">
          <input
            type="text"
            value={editValue}
            onChange={(e) => onEditChange(e.target.value)}
            onKeyDown={handleKeyDown}
            onClick={(e) => e.stopPropagation()}
            className="flex-1 px-1.5 py-0.5 text-xs border border-blue-400 rounded focus:outline-none focus:ring-1 focus:ring-blue-500"
            autoFocus
          />
          <button
            onClick={(e) => { e.stopPropagation(); onSaveEdit(); }}
            className="p-0.5 text-green-600 hover:bg-green-50 rounded"
          >
            <Check className="h-3 w-3" />
          </button>
          <button
            onClick={(e) => { e.stopPropagation(); onCancelEdit(); }}
            className="p-0.5 text-gray-500 hover:bg-gray-100 rounded"
          >
            <X className="h-3 w-3" />
          </button>
        </div>
      ) : (
        <>
          <div className="flex-1 min-w-0">
            <div 
              className={cn(
                'text-xs font-medium leading-snug line-clamp-2',
                isSelected ? 'text-blue-900' : 'text-gray-900'
              )}
              title={doc.title}
            >
              {doc.title}
            </div>
            <div className="flex items-center gap-2 mt-0.5">
              <span className="flex items-center gap-0.5 text-[10px] text-gray-500">
                <Calendar className="h-2.5 w-2.5" />
                {formatRelativeDate(doc.modifiedAt)}
              </span>
              {doc.metadata?.wordCount !== undefined && (
                <span className="flex items-center gap-0.5 text-[10px] text-gray-500">
                  <Type className="h-2.5 w-2.5" />
                  {doc.metadata.wordCount}w
                </span>
              )}
            </div>
          </div>
          
          {/* Actions - visible on hover */}
          <div className="flex items-center gap-0.5 opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0">
            <button
              onClick={(e) => { e.stopPropagation(); onStartEdit(); }}
              className="p-1 rounded hover:bg-gray-200 transition-colors"
              title="Rename"
            >
              <Pencil className="h-3 w-3 text-gray-500" />
            </button>
            <button
              onClick={(e) => { e.stopPropagation(); onDelete(); }}
              className="p-1 rounded hover:bg-red-100 transition-colors"
              title="Delete"
            >
              <Trash2 className="h-3 w-3 text-red-500" />
            </button>
          </div>
        </>
      )}
    </div>
  );
}

/**
 * Folder row with expand/collapse
 */
interface FolderRowProps {
  folder: Folder;
  isExpanded: boolean;
  documentCount: number;
  isEditing: boolean;
  editValue: string;
  onToggle: () => void;
  onStartEdit: () => void;
  onEditChange: (value: string) => void;
  onSaveEdit: () => void;
  onCancelEdit: () => void;
  onDelete: () => void;
  onCreateDocument: () => void;
  indentLevel?: number;
}

function FolderRow({
  folder,
  isExpanded,
  documentCount,
  isEditing,
  editValue,
  onToggle,
  onStartEdit,
  onEditChange,
  onSaveEdit,
  onCancelEdit,
  onDelete,
  onCreateDocument,
  indentLevel = 0,
}: FolderRowProps) {
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      onSaveEdit();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      onCancelEdit();
    }
  };

  return (
    <div
      className={cn(
        'group flex items-center gap-1.5 px-2 py-1.5 rounded-md cursor-pointer',
        'hover:bg-gray-50 transition-colors duration-150'
      )}
      style={{ paddingLeft: `${8 + indentLevel * 12}px` }}
      onClick={() => !isEditing && onToggle()}
    >
      {isExpanded ? (
        <ChevronDown className="h-3 w-3 text-gray-400 flex-shrink-0" />
      ) : (
        <ChevronRight className="h-3 w-3 text-gray-400 flex-shrink-0" />
      )}
      
      <FolderIcon className="h-3.5 w-3.5 text-blue-500 flex-shrink-0" />
      
      {isEditing ? (
        <div className="flex-1 flex items-center gap-1.5">
          <input
            type="text"
            value={editValue}
            onChange={(e) => onEditChange(e.target.value)}
            onKeyDown={handleKeyDown}
            onClick={(e) => e.stopPropagation()}
            className="flex-1 px-1.5 py-0.5 text-xs border border-blue-400 rounded focus:outline-none focus:ring-1 focus:ring-blue-500"
            autoFocus
          />
          <button
            onClick={(e) => { e.stopPropagation(); onSaveEdit(); }}
            className="p-0.5 text-green-600 hover:bg-green-50 rounded"
          >
            <Check className="h-3 w-3" />
          </button>
          <button
            onClick={(e) => { e.stopPropagation(); onCancelEdit(); }}
            className="p-0.5 text-gray-500 hover:bg-gray-100 rounded"
          >
            <X className="h-3 w-3" />
          </button>
        </div>
      ) : (
        <>
          <span className="flex-1 text-xs font-semibold text-gray-900 truncate">
            {folder.name}
          </span>
          
          <span className="text-[10px] text-gray-500 px-1.5 py-0.5 bg-gray-100 rounded-full">
            {documentCount}
          </span>
          
          {/* Actions - visible on hover */}
          <div className="flex items-center gap-0.5 opacity-0 group-hover:opacity-100 transition-opacity">
            <button
              onClick={(e) => { e.stopPropagation(); onCreateDocument(); }}
              className="p-1 rounded hover:bg-gray-200 transition-colors"
              title="New document in folder"
            >
              <FilePlus className="h-3 w-3 text-gray-500" />
            </button>
            <button
              onClick={(e) => { e.stopPropagation(); onStartEdit(); }}
              className="p-1 rounded hover:bg-gray-200 transition-colors"
              title="Rename folder"
            >
              <Pencil className="h-3 w-3 text-gray-500" />
            </button>
            <button
              onClick={(e) => { e.stopPropagation(); onDelete(); }}
              className="p-1 rounded hover:bg-red-100 transition-colors"
              title="Delete folder"
            >
              <Trash2 className="h-3 w-3 text-red-500" />
            </button>
          </div>
        </>
      )}
    </div>
  );
}

/**
 * Project section with documents, folders, and snippets
 */
interface ProjectSectionProps {
  project: Project;
  isActive: boolean;
  isExpanded: boolean;
  selectedDocId: string | null;
  searchQuery: string;
  onToggle: () => void;
  onSelect: () => void;
  onDocumentSelect: (doc: ProjectDocument) => void;
  onRefresh: () => void;
  onSnippetClick?: (snippet: Snippet) => void;
  onAddSnippet?: (projectId: string) => void;
  onEditSnippet?: (snippet: Snippet) => void;
  onDeleteProject?: (project: Project) => void;
  onRenameProject?: (projectId: string, newName: string) => void;
  canDelete: boolean;
}

function ProjectSection({
  project,
  isActive,
  isExpanded,
  selectedDocId,
  searchQuery,
  onToggle,
  onSelect,
  onDocumentSelect,
  onRefresh,
  onSnippetClick,
  onAddSnippet,
  onEditSnippet,
  onDeleteProject,
  onRenameProject,
  canDelete,
}: ProjectSectionProps) {
  // Local state
  const [folders, setFolders] = useState<Folder[]>([]);
  const [documents, setDocuments] = useState<ProjectDocument[]>([]);
  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set());
  const [editingDocId, setEditingDocId] = useState<string | null>(null);
  const [editingFolderId, setEditingFolderId] = useState<string | null>(null);
  const [editValue, setEditValue] = useState('');
  
  // Project rename state
  const [isEditingProjectName, setIsEditingProjectName] = useState(false);
  const [projectNameEditValue, setProjectNameEditValue] = useState('');

  // Load data when project changes or expands
  useEffect(() => {
    const loadData = async () => {
      if (isExpanded) {
        try {
          const projectFolders = await getAllFolders(project.id);
          const projectDocs = await getAllDocuments(project.id);
          setFolders(projectFolders);
          setDocuments(projectDocs);
        } catch (error) {
          logger.error('Failed to load project data:', error);
          setFolders([]);
          setDocuments([]);
        }
      }
    };
    loadData();
  }, [project.id, isExpanded]);

  // Filter documents by search query
  const filteredDocuments = useMemo(() => {
    if (!Array.isArray(documents)) return [];
    if (!searchQuery.trim()) return documents;
    const query = searchQuery.toLowerCase();
    return documents.filter(doc => 
      doc.title.toLowerCase().includes(query) ||
      doc.baseTitle.toLowerCase().includes(query)
    );
  }, [documents, searchQuery]);

  // Get root-level documents and folders (with defensive checks)
  const rootFolders = Array.isArray(folders) ? folders.filter(f => !f.parentFolderId) : [];
  const rootDocs = Array.isArray(filteredDocuments) ? filteredDocuments.filter(d => !d.folderId) : [];

  // Toggle folder expansion
  const toggleFolder = (folderId: string) => {
    setExpandedFolders(prev => {
      const next = new Set(prev);
      if (next.has(folderId)) {
        next.delete(folderId);
      } else {
        next.add(folderId);
      }
      return next;
    });
  };

  // Document operations
  const handleStartDocEdit = (doc: ProjectDocument) => {
    setEditingDocId(doc.id);
    setEditValue(doc.title);
  };

  const handleSaveDocEdit = async (docId: string) => {
    if (!editValue.trim()) {
      setEditingDocId(null);
      return;
    }
    try {
      logger.log('üíæ Saving document rename via unified-storage:', { docId, newTitle: editValue.trim() });
      
      // Use unified-storage to update BOTH localStorage AND Supabase
      await updateDocument(project.id, docId, { title: editValue.trim() });
      
      logger.log('‚úÖ Document renamed successfully');
      
      // Refresh local state
      setDocuments(await getAllDocuments(project.id));
      onRefresh();
    } catch (error) {
      logger.error('‚ùå Failed to rename document:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to rename document');
    }
    setEditingDocId(null);
    setEditValue('');
  };

  const handleDeleteDoc = async (docId: string) => {
    if (!window.confirm('Delete this document? This cannot be undone.')) return;
    try {
      await deleteDocument(project.id, docId);
      setDocuments(await getAllDocuments(project.id));
      onRefresh();
    } catch (error) {
      logger.error('Failed to delete document:', error);
    }
  };

  // Folder operations
  const handleStartFolderEdit = (folder: Folder) => {
    setEditingFolderId(folder.id);
    setEditValue(folder.name);
  };

  const handleSaveFolderEdit = async (folderId: string) => {
    if (!editValue.trim()) {
      setEditingFolderId(null);
      return;
    }
    try {
      await updateFolder(project.id, folderId, { name: editValue.trim() });
      setFolders(await getAllFolders(project.id));
      onRefresh();
    } catch (error) {
      logger.error('Failed to rename folder:', error);
    }
    setEditingFolderId(null);
    setEditValue('');
  };

  const handleDeleteFolder = async (folderId: string) => {
    if (!window.confirm('Delete this folder? It must be empty first.')) return;
    try {
      await deleteFolder(project.id, folderId);
      setFolders(await getAllFolders(project.id));
      onRefresh();
    } catch (error) {
      window.alert(error instanceof Error ? error.message : 'Failed to delete folder');
    }
  };

  const handleCreateDocInFolder = async (folderId: string) => {
    const title = window.prompt('Document title:');
    if (!title?.trim()) return;
    try {
      const newDoc = await createDocument(project.id, title.trim());
      await updateDocument(project.id, newDoc.id, { folderId });
      setDocuments(await getAllDocuments(project.id));
      onRefresh();
    } catch (error) {
      logger.error('Failed to create document:', error);
    }
  };

  // Project rename operations
  const handleStartProjectRename = () => {
    setIsEditingProjectName(true);
    setProjectNameEditValue(project.name);
  };

  const handleSaveProjectRename = () => {
    const trimmedName = projectNameEditValue.trim();
    
    if (!trimmedName) {
      // Don't allow empty names
      setIsEditingProjectName(false);
      setProjectNameEditValue('');
      return;
    }
    
    if (trimmedName !== project.name) {
      onRenameProject?.(project.id, trimmedName);
    }
    
    setIsEditingProjectName(false);
    setProjectNameEditValue('');
  };

  const handleCancelProjectRename = () => {
    setIsEditingProjectName(false);
    setProjectNameEditValue('');
  };

  const handleProjectRenameKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleSaveProjectRename();
    } else if (e.key === 'Escape') {
      e.preventDefault();
      handleCancelProjectRename();
    }
  };

  // Render folder recursively
  const renderFolder = (folder: Folder, level: number = 0) => {
    const isExpanded = expandedFolders.has(folder.id);
    const folderDocs = Array.isArray(filteredDocuments) ? filteredDocuments.filter(d => d.folderId === folder.id) : [];
    const childFolders = Array.isArray(folders) ? folders.filter(f => f.parentFolderId === folder.id) : [];

    return (
      <div key={folder.id}>
        <FolderRow
          folder={folder}
          isExpanded={isExpanded}
          documentCount={folderDocs.length}
          isEditing={editingFolderId === folder.id}
          editValue={editValue}
          onToggle={() => toggleFolder(folder.id)}
          onStartEdit={() => handleStartFolderEdit(folder)}
          onEditChange={setEditValue}
          onSaveEdit={() => handleSaveFolderEdit(folder.id)}
          onCancelEdit={() => { setEditingFolderId(null); setEditValue(''); }}
          onDelete={() => handleDeleteFolder(folder.id)}
          onCreateDocument={() => handleCreateDocInFolder(folder.id)}
          indentLevel={level}
        />
        
        {isExpanded && (
          <div className="ml-4">
            {childFolders.map(child => renderFolder(child, level + 1))}
            {folderDocs.map(doc => (
              <DocumentRow
                key={doc.id}
                doc={doc}
                isSelected={doc.id === selectedDocId}
                isEditing={editingDocId === doc.id}
                editValue={editValue}
                onSelect={onDocumentSelect}
                onStartEdit={() => handleStartDocEdit(doc)}
                onEditChange={setEditValue}
                onSaveEdit={() => handleSaveDocEdit(doc.id)}
                onCancelEdit={() => { setEditingDocId(null); setEditValue(''); }}
                onDelete={() => handleDeleteDoc(doc.id)}
                indentLevel={level + 1}
              />
            ))}
            {folderDocs.length === 0 && childFolders.length === 0 && (
              <div 
                className="text-xs text-gray-400 italic py-2"
                style={{ paddingLeft: `${28 + (level + 1) * 16}px` }}
              >
                Empty folder
              </div>
            )}
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="mb-3">
      {/* Project header */}
      <div
        className={cn(
          'group flex items-center gap-1.5 px-2 py-1.5 rounded-md',
          'transition-colors duration-150',
          isActive
            ? 'bg-blue-100 border border-blue-300'
            : 'hover:bg-gray-100 border border-transparent',
          !isEditingProjectName && 'cursor-pointer'
        )}
        onClick={() => {
          if (isEditingProjectName) return;
          if (!isActive) {
            onSelect();
          }
          onToggle();
        }}
      >
        {isExpanded ? (
          <ChevronDown className="h-3.5 w-3.5 text-gray-500 flex-shrink-0" />
        ) : (
          <ChevronRight className="h-3.5 w-3.5 text-gray-500 flex-shrink-0" />
        )}
        
        <FolderIcon className={cn(
          'h-4 w-4 flex-shrink-0',
          isActive ? 'text-blue-600' : 'text-gray-400'
        )} />
        
        {/* Project name - editable or display */}
        {isEditingProjectName ? (
          <div className="flex-1 flex items-center gap-1.5 min-w-0">
            <input
              type="text"
              value={projectNameEditValue}
              onChange={(e) => setProjectNameEditValue(e.target.value)}
              onKeyDown={handleProjectRenameKeyDown}
              onClick={(e) => e.stopPropagation()}
              className="flex-1 px-1.5 py-0.5 text-xs font-semibold border-2 border-blue-400 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white"
              autoFocus
              placeholder="Project name"
            />
            <button
              onClick={(e) => {
                e.stopPropagation();
                handleSaveProjectRename();
              }}
              className="p-0.5 text-green-600 hover:bg-green-50 rounded flex-shrink-0"
              title="Save"
            >
              <Check className="h-3.5 w-3.5" />
            </button>
            <button
              onClick={(e) => {
                e.stopPropagation();
                handleCancelProjectRename();
              }}
              className="p-0.5 text-gray-500 hover:bg-gray-100 rounded flex-shrink-0"
              title="Cancel"
            >
              <X className="h-3.5 w-3.5" />
            </button>
          </div>
        ) : (
          <>
            <span className={cn(
              'flex-1 text-xs font-semibold truncate',
              isActive ? 'text-blue-900' : 'text-gray-900'
            )}>
              {project.name}
            </span>
            
            {isActive && (
              <span className="text-[10px] font-medium text-blue-600 bg-blue-50 px-1.5 py-0.5 rounded flex-shrink-0">
                Active
              </span>
            )}
            
            <span className="text-[10px] text-gray-500 flex-shrink-0">
              {documents.length} docs
            </span>
            
            {/* Edit button - visible on hover */}
            <button
              onClick={(e) => {
                e.stopPropagation();
                handleStartProjectRename();
              }}
              className={cn(
                'p-1 rounded opacity-0 group-hover:opacity-100',
                'hover:bg-blue-100 transition-all duration-150',
                'flex-shrink-0'
              )}
              title="Rename project"
              aria-label={`Rename project ${project.name}`}
            >
              <Pencil className="h-3 w-3 text-blue-600" />
            </button>
            
            {/* Delete button - visible on hover */}
            {canDelete && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  onDeleteProject?.(project);
                }}
                className={cn(
                  'p-1 rounded opacity-0 group-hover:opacity-100',
                  'hover:bg-red-100 transition-all duration-150',
                  'flex-shrink-0'
                )}
                title="Delete project"
                aria-label={`Delete project ${project.name}`}
              >
                <Trash2 className="h-3 w-3 text-red-500" />
              </button>
            )}
          </>
        )}
      </div>
      
      {/* Project contents */}
      {isExpanded && (
        <div className="mt-1 ml-2 pl-2 border-l-2 border-gray-200">
          {/* Folders */}
          {rootFolders.map(folder => renderFolder(folder))}
          
          {/* Root documents (not in folders) */}
          {rootDocs.map(doc => (
            <DocumentRow
              key={doc.id}
              doc={doc}
              isSelected={doc.id === selectedDocId}
              isEditing={editingDocId === doc.id}
              editValue={editValue}
              onSelect={onDocumentSelect}
              onStartEdit={() => handleStartDocEdit(doc)}
              onEditChange={setEditValue}
              onSaveEdit={() => handleSaveDocEdit(doc.id)}
              onCancelEdit={() => { setEditingDocId(null); setEditValue(''); }}
              onDelete={() => handleDeleteDoc(doc.id)}
            />
          ))}
          
          {/* Snippets section */}
          <SnippetSection
            projectId={project.id}
            isExpanded={isExpanded}
            searchQuery={searchQuery}
            onSnippetClick={onSnippetClick}
            onAddSnippet={onAddSnippet}
            onEditSnippet={onEditSnippet}
          />
          
          {/* Brand Voice section */}
          <BrandVoiceSection
            project={project}
            isExpanded={isExpanded}
            searchQuery={searchQuery}
          />
          
          {/* Personas section */}
          <PersonaSection
            project={project}
            isExpanded={isExpanded}
            searchQuery={searchQuery}
          />
          
          {/* Empty state */}
          {rootFolders.length === 0 && rootDocs.length === 0 && (
            <div className="text-sm text-gray-500 text-center py-4">
              No documents in this project yet
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// ============================================================================
// Main Component
// ============================================================================

export function MyProjectsSlideOut({
  isOpen,
  onClose,
  onDocumentClick,
}: MyProjectsSlideOutProps) {
  // Store state
  const projects = useProjects();
  const activeProjectId = useActiveProjectId();
  const activeDocumentId = useActiveDocumentId();
  const { setActiveProjectId } = useProjectActions();
  const { setActiveDocumentId } = useDocumentActions();
  const { closeSlideOut } = useSlideOutActions();
  
  // Snippet store actions
  const {
    loadSnippets,
    insertSnippet,
    openAddModal,
    openEditModal,
  } = useSnippetActions();

  // Local state
  const [searchQuery, setSearchQuery] = useState('');
  // ACCORDION BEHAVIOR: Only track one expanded project ID at a time
  const [expandedProjectId, setExpandedProjectId] = useState<string | null>(null);
  const [refreshKey, setRefreshKey] = useState(0);
  
  // Delete project modal state
  const [projectToDelete, setProjectToDelete] = useState<Project | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);
  
  // Track previous isOpen to detect open transitions
  const wasOpenRef = React.useRef(false);

  // Auto-expand active project on open
  useEffect(() => {
    if (isOpen && activeProjectId) {
      setExpandedProjectId(activeProjectId);
    }
  }, [isOpen, activeProjectId]);

  // Refresh projects only when panel opens (not on every render)
  useEffect(() => {
    // Only refresh when transitioning from closed to open
    if (isOpen && !wasOpenRef.current) {
      useWorkspaceStore.getState().refreshProjects();
    }
    wasOpenRef.current = isOpen;
  }, [isOpen]);

  // Toggle project expansion - ACCORDION: only one open at a time
  const toggleProject = useCallback((projectId: string) => {
    setExpandedProjectId(prev => {
      // If clicking the already-expanded project, collapse it
      if (prev === projectId) {
        return null;
      }
      // Otherwise, expand this project (and implicitly close others)
      return projectId;
    });
  }, []);

  // Handle document selection
  const handleDocumentSelect = useCallback((doc: ProjectDocument) => {
    // Set active document
    setActiveDocumentId(doc.id);
    
    // If document is in a different project, switch projects first
    if (doc.projectId !== activeProjectId) {
      setActiveProjectId(doc.projectId);
    }
    
    // Notify parent
    onDocumentClick?.(doc);
    
    // Close panel
    onClose();
  }, [activeProjectId, setActiveProjectId, setActiveDocumentId, onDocumentClick, onClose]);

  // Handle project selection
  const handleProjectSelect = useCallback((projectId: string) => {
    setActiveProjectId(projectId);
  }, [setActiveProjectId]);

  // Create new project
  const handleCreateProject = useCallback(async () => {
    const name = window.prompt('Project name:');
    if (!name?.trim()) return;
    
    try {
      const newProject = await createProject(name.trim());
      // Use getState() to avoid dependency on refreshProjects
      useWorkspaceStore.getState().refreshProjects();
      setActiveProjectId(newProject.id);
      // ACCORDION: Auto-expand the newly created project
      setExpandedProjectId(newProject.id);
    } catch (error) {
      window.alert(error instanceof Error ? error.message : 'Failed to create project');
    }
  }, [setActiveProjectId]);

  // Create new folder in active project
  const handleCreateFolder = useCallback(() => {
    if (!activeProjectId) {
      window.alert('Please select a project first');
      return;
    }
    
    const name = window.prompt('Folder name:');
    if (!name?.trim()) return;
    
    try {
      createFolder(activeProjectId, name.trim());
      setRefreshKey(k => k + 1);
    } catch (error) {
      window.alert(error instanceof Error ? error.message : 'Failed to create folder');
    }
  }, [activeProjectId]);

  // Create new document in active project
  const handleCreateDocument = useCallback(async () => {
    if (!activeProjectId) {
      window.alert('Please select a project first');
      return;
    }
    
    const title = window.prompt('Document title:');
    if (!title?.trim()) return;
    
    try {
      const newDoc = await createDocument(activeProjectId, title.trim());
      setRefreshKey(k => k + 1);
      handleDocumentSelect(newDoc);
    } catch (error) {
      window.alert(error instanceof Error ? error.message : 'Failed to create document');
    }
  }, [activeProjectId, handleDocumentSelect]);

  // Refresh handler
  const handleRefresh = useCallback(() => {
    setRefreshKey(k => k + 1);
  }, []);
  
  // Delete project handlers
  const handleOpenDeleteModal = useCallback((project: Project) => {
    setProjectToDelete(project);
  }, []);
  
  const handleCloseDeleteModal = useCallback(() => {
    if (!isDeleting) {
      setProjectToDelete(null);
    }
  }, [isDeleting]);
  
  const handleConfirmDelete = useCallback(async () => {
    if (!projectToDelete) return;
    
    setIsDeleting(true);
    
    try {
      const deletingActiveProject = projectToDelete.id === activeProjectId;
      const projectIdToDelete = projectToDelete.id;
      const isLastProject = projects.length <= 1;
      
      // If this is the last project, create a default one first
      if (isLastProject) {
        logger.log('üìù Creating default project before deleting last project...');
        const newProject = await createProject('My Project');
        useWorkspaceStore.getState().refreshProjects();
        setActiveProjectId(newProject.id);
        // ACCORDION: Expand the newly created default project
        setExpandedProjectId(newProject.id);
      }
      
      // Delete from storage (this also handles switching active project if needed)
      deleteProjectFromStorage(projectIdToDelete);
      
      // Refresh the store state
      useWorkspaceStore.getState().refreshProjects();
      
      // If we deleted the active project, clear active document
      // (the storage function already handles switching to another project)
      if (deletingActiveProject) {
        setActiveDocumentId(null);
      }
      
      // ACCORDION: If the deleted project was expanded, clear the expansion
      if (expandedProjectId === projectIdToDelete) {
        setExpandedProjectId(null);
      }
      
      // Force refresh
      setRefreshKey(k => k + 1);
      
      logger.log('‚úÖ Project deleted:', projectToDelete.name);
    } catch (error) {
      logger.error('‚ùå Failed to delete project:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to delete project');
    } finally {
      setIsDeleting(false);
      setProjectToDelete(null);
    }
  }, [projectToDelete, projects.length, activeProjectId, setActiveDocumentId, setActiveProjectId, expandedProjectId]);
  
  // Always allow delete - we'll auto-create a default project if needed
  const canDeleteProject = true;
  
  // Rename project handler
  const handleRenameProject = useCallback(async (projectId: string, newName: string) => {
    try {
      // Update in storage
      await updateProject(projectId, { name: newName });
      
      // Refresh the store to reflect changes
      useWorkspaceStore.getState().refreshProjects();
      
      // Force UI refresh
      setRefreshKey(k => k + 1);
      
      logger.log('‚úÖ Project renamed:', { projectId, newName });
    } catch (error) {
      logger.error('‚ùå Failed to rename project:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to rename project');
    }
  }, []);
  
  // Snippet handlers
  const handleSnippetClick = useCallback((snippet: Snippet) => {
    // Load snippets for the snippet's project if needed
    if (snippet.projectId !== activeProjectId) {
      loadSnippets(snippet.projectId);
    }
    // Insert snippet at cursor
    insertSnippet(snippet);
    // Optionally close the panel
    // onClose();
  }, [activeProjectId, loadSnippets, insertSnippet]);
  
  const handleAddSnippet = useCallback((projectId: string) => {
    // Load snippets for the specific project where "Add" was clicked
    loadSnippets(projectId);
    openAddModal();
  }, [loadSnippets, openAddModal]);
  
  const handleEditSnippet = useCallback((snippet: Snippet) => {
    // Ensure snippets are loaded for the snippet's project
    loadSnippets(snippet.projectId);
    openEditModal(snippet);
  }, [loadSnippets, openEditModal]);

  // Panel footer
  const panelFooter = (
    <div className="flex gap-2">
      <Button
        variant="outline"
        size="sm"
        onClick={handleCreateFolder}
        disabled={!activeProjectId}
        className="flex-1"
      >
        <FolderPlus className="h-4 w-4 mr-2" />
        New Folder
      </Button>
      <Button
        variant="outline"
        size="sm"
        onClick={handleCreateDocument}
        disabled={!activeProjectId}
        className="flex-1"
      >
        <FilePlus className="h-4 w-4 mr-2" />
        New Document
      </Button>
    </div>
  );

  return (
    <>
    <SlideOutPanel
      isOpen={isOpen}
      onClose={onClose}
      side="left"
      title="My Projects"
      subtitle={`${projects.length} project${projects.length !== 1 ? 's' : ''}`}
      footer={panelFooter}
    >
      <div className="space-y-4">
        {/* Search bar */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
          <Input
            type="text"
            placeholder="Search documents..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-10"
          />
        </div>

        {/* New Project button */}
        <Button
          variant="outline"
          size="sm"
          onClick={handleCreateProject}
          className="w-full justify-start"
        >
          <Plus className="h-4 w-4 mr-2" />
          New Project
        </Button>

        {/* Project list */}
        <div className="space-y-2" key={refreshKey}>
          {projects.map(project => (
            <ProjectSection
              key={project.id}
              project={project}
              isActive={project.id === activeProjectId}
              isExpanded={expandedProjectId === project.id}
              selectedDocId={activeDocumentId}
              searchQuery={searchQuery}
              onToggle={() => toggleProject(project.id)}
              onSelect={() => handleProjectSelect(project.id)}
              onDocumentSelect={handleDocumentSelect}
              onRefresh={handleRefresh}
              onSnippetClick={handleSnippetClick}
              onAddSnippet={handleAddSnippet}
              onEditSnippet={handleEditSnippet}
              onDeleteProject={handleOpenDeleteModal}
              onRenameProject={handleRenameProject}
              canDelete={canDeleteProject}
            />
          ))}
          
          {/* Empty state */}
          {projects.length === 0 && (
            <div className="text-center py-8">
              <FolderIcon className="h-12 w-12 mx-auto text-gray-300 mb-3" />
              <p className="text-gray-500">No projects yet</p>
              <p className="text-sm text-gray-400 mt-1">
                Create a project to get started
              </p>
            </div>
          )}
        </div>
      </div>
    </SlideOutPanel>
    
    {/* Snippet modals */}
    <SnippetModals />
    
    {/* Delete project confirmation modal */}
    <DeleteProjectModal
      isOpen={projectToDelete !== null}
      projectName={projectToDelete?.name || ''}
      onClose={handleCloseDeleteModal}
      onConfirm={handleConfirmDelete}
      isDeleting={isDeleting}
    />
  </>
  );
}

export default MyProjectsSlideOut;


=== FILE: components/workspace/OptimizeComparisonModal.tsx ===

/**
 * @file components/workspace/OptimizeComparisonModal.tsx
 * @description Side-by-side comparison modal for alignment optimization results
 * 
 * Shows original vs optimized copy with:
 * - Side-by-side comparison view
 * - Changes summary
 * - Accept/Reject/Edit options
 * - Character count comparison
 */

'use client';

import React, { useState, useEffect } from 'react';
import { 
  X, 
  Check, 
  XCircle, 
  Edit3, 
  ArrowRight,
  FileText,
  Sparkles,
  AlertTriangle,
  Copy as CopyIcon
} from 'lucide-react';
import { 
  useOptimizeAlignmentResult,
  useOptimizeAlignmentChangesSummary,
  useOptimizeAlignmentLoading,
  useOptimizeAlignmentError,
  useOptimizeAlignmentTargetName,
  useOptimizeAlignmentType,
  useOptimizeAlignmentOriginalText,
  useOptimizeAlignmentModalOpen,
  useOptimizeAlignmentActions,
} from '@/lib/stores/workspaceStore';
import { AIWorxLoader } from '@/components/ui/AIWorxLoader';
import type { Editor } from '@tiptap/react';
import { cn } from '@/lib/utils';
import { logger } from '@/lib/utils/logger';
import { createDocumentVersion } from '@/lib/storage/unified-storage';
import { toast } from 'sonner';

interface OptimizeComparisonModalProps {
  /** TipTap editor instance */
  editor: Editor | null;
  /** Active project ID for versioning */
  projectId: string | null;
  /** Active document ID for versioning */
  documentId: string | null;
}

/**
 * Calculate word count from text/HTML
 */
function getWordCount(content: string): number {
  if (!content) return 0;
  const textOnly = content.replace(/<[^>]*>/g, ' ');
  const words = textOnly.split(/\s+/).filter(word => word.trim().length > 0);
  return words.length;
}

/**
 * Calculate character count from text/HTML
 */
function getCharCount(content: string): number {
  if (!content) return 0;
  const textOnly = content.replace(/<[^>]*>/g, '');
  return textOnly.length;
}

/**
 * OptimizeComparisonModal component
 */
export function OptimizeComparisonModal({ 
  editor, 
  projectId,
  documentId 
}: OptimizeComparisonModalProps) {
  // State from store
  const result = useOptimizeAlignmentResult();
  const changesSummary = useOptimizeAlignmentChangesSummary();
  const loading = useOptimizeAlignmentLoading();
  const error = useOptimizeAlignmentError();
  const targetName = useOptimizeAlignmentTargetName();
  const type = useOptimizeAlignmentType();
  const originalText = useOptimizeAlignmentOriginalText();
  const modalOpen = useOptimizeAlignmentModalOpen();
  const { clearOptimizeAlignmentResult, setOptimizeAlignmentModalOpen, acceptOptimizeResult } = useOptimizeAlignmentActions();

  // Local state for editing
  const [isEditing, setIsEditing] = useState(false);
  const [editedResult, setEditedResult] = useState('');
  const [isSavingVersion, setIsSavingVersion] = useState(false);

  // Update edited result when result changes
  useEffect(() => {
    if (result) {
      setEditedResult(result);
    }
  }, [result]);

  // Don't render if not open
  if (!modalOpen && !loading) {
    return null;
  }

  // Calculate stats
  const originalWordCount = originalText ? getWordCount(originalText) : 0;
  const originalCharCount = originalText ? getCharCount(originalText) : 0;
  const newWordCount = editedResult ? getWordCount(editedResult) : (result ? getWordCount(result) : 0);
  const newCharCount = editedResult ? getCharCount(editedResult) : (result ? getCharCount(result) : 0);
  const charDiff = newCharCount - originalCharCount;
  const charDiffPercent = originalCharCount > 0 ? Math.round((charDiff / originalCharCount) * 100) : 0;

  /**
   * Handle accepting the optimized result
   */
  const handleAccept = async () => {
    if (!editor) return;

    // Save current version before replacing (if we have project/document context)
    if (projectId && documentId) {
      setIsSavingVersion(true);
      try {
        // Get current editor content
        const currentContent = editor.getHTML();
        
        // Create a new version with the current content before replacing
        await createDocumentVersion(projectId, documentId, currentContent);
        logger.log('‚úÖ Document version saved before optimization');
        toast.success('Original version saved to history');
      } catch (err) {
        logger.error('‚ùå Failed to save document version:', err);
        toast.error('Could not save original version, but proceeding with replacement');
      } finally {
        setIsSavingVersion(false);
      }
    }

    // Use the edited result if user was editing, otherwise use the original result
    const contentToInsert = isEditing ? editedResult : result;
    
    if (contentToInsert) {
      // Update store result if edited
      if (isEditing && editedResult !== result) {
        // We need to manually insert since store has original
        const { insertTextAtSelection } = await import('@/lib/editor-utils');
        const success = insertTextAtSelection(editor, editedResult, { isHTML: true });
        if (success) {
          clearOptimizeAlignmentResult();
          toast.success('Optimized copy accepted');
        }
      } else {
        acceptOptimizeResult(editor);
        toast.success('Optimized copy accepted');
      }
    }
  };

  /**
   * Handle rejecting the result
   */
  const handleReject = () => {
    clearOptimizeAlignmentResult();
    setIsEditing(false);
    setEditedResult('');
    toast.info('Kept original copy');
  };

  /**
   * Handle closing the modal
   */
  const handleClose = () => {
    setOptimizeAlignmentModalOpen(false);
    setIsEditing(false);
  };

  /**
   * Handle copy to clipboard
   */
  const handleCopy = async (content: string) => {
    try {
      // Copy plain text version
      const textContent = content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
      await navigator.clipboard.writeText(textContent);
      toast.success('Copied to clipboard');
    } catch {
      toast.error('Failed to copy');
    }
  };

  // Show loading state as overlay
  if (loading) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
        <div className="bg-white rounded-2xl p-8 shadow-2xl max-w-md mx-4">
          <div className="flex flex-col items-center gap-4">
            <AIWorxLoader message="Optimizing with AI@Worx‚Ñ¢" />
            <div className="text-center">
              <h3 className="text-lg font-semibold text-apple-text-dark">
                Optimizing for {targetName || (type === 'persona' ? 'Persona' : 'Brand')}
              </h3>
              <p className="text-sm text-apple-text-light mt-1">
                Rewriting copy to fix alignment issues...
              </p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Show error state
  if (error && !result) {
    return (
      <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm">
        <div className="bg-white rounded-2xl p-6 shadow-2xl max-w-md mx-4">
          <div className="flex flex-col gap-4">
            <div className="flex items-start gap-3">
              <XCircle className="w-6 h-6 text-red-500 flex-shrink-0" />
              <div>
                <h3 className="text-lg font-semibold text-red-900">
                  Optimization Failed
                </h3>
                <p className="text-sm text-red-700 mt-1">{error}</p>
              </div>
            </div>
            <button
              onClick={handleReject}
              className="w-full py-2 px-4 rounded-lg bg-gray-100 text-gray-700 font-medium hover:bg-gray-200 transition-colors"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Don't show if no result
  if (!result || !originalText) {
    return null;
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm p-4">
      <div className="bg-white rounded-2xl shadow-2xl w-full max-w-5xl max-h-[90vh] flex flex-col overflow-hidden">
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200 bg-gradient-to-r from-blue-50 to-purple-50">
          <div className="flex items-center gap-3">
            <Sparkles className="w-6 h-6 text-purple-600" />
            <div>
              <h2 className="text-lg font-semibold text-apple-text-dark">
                Optimized for {targetName}
              </h2>
              <p className="text-xs text-apple-text-light">
                {type === 'persona' ? 'Persona' : 'Brand'} alignment optimization complete
              </p>
            </div>
          </div>
          <button
            onClick={handleClose}
            className="p-2 rounded-lg hover:bg-gray-100 transition-colors"
            aria-label="Close"
          >
            <X className="w-5 h-5 text-gray-500" />
          </button>
        </div>

        {/* Changes Summary */}
        {changesSummary.length > 0 && (
          <div className="px-6 py-3 bg-gradient-to-r from-green-50 to-emerald-50 border-b border-green-200">
            <div className="flex items-start gap-2">
              <ArrowRight className="w-4 h-4 text-green-600 flex-shrink-0 mt-0.5" />
              <div>
                <span className="text-sm font-medium text-green-900">What Changed:</span>
                <ul className="mt-1 space-y-0.5">
                  {changesSummary.map((change, index) => (
                    <li key={index} className="text-sm text-green-700">‚Ä¢ {change}</li>
                  ))}
                </ul>
              </div>
            </div>
          </div>
        )}

        {/* Length Warning */}
        {charDiff > 0 && charDiffPercent > 20 && (
          <div className="px-6 py-2 bg-yellow-50 border-b border-yellow-200 flex items-center gap-2">
            <AlertTriangle className="w-4 h-4 text-yellow-600 flex-shrink-0" />
            <p className="text-sm text-yellow-800">
              Note: Optimized copy is {charDiffPercent}% longer ({charDiff} characters more)
            </p>
          </div>
        )}

        {/* Comparison Content */}
        <div className="flex-1 overflow-hidden flex">
          {/* Original Side */}
          <div className="w-1/2 flex flex-col border-r border-gray-200">
            <div className="px-4 py-2 bg-gray-50 border-b border-gray-200 flex items-center justify-between">
              <div className="flex items-center gap-2">
                <FileText className="w-4 h-4 text-gray-500" />
                <span className="text-sm font-medium text-gray-700">Original</span>
              </div>
              <div className="flex items-center gap-3">
                <span className="text-xs text-gray-500">{originalWordCount} words</span>
                <span className="text-xs text-gray-500">{originalCharCount} chars</span>
                <button
                  onClick={() => handleCopy(originalText)}
                  className="p-1 rounded hover:bg-gray-200 transition-colors"
                  title="Copy original"
                >
                  <CopyIcon className="w-3.5 h-3.5 text-gray-500" />
                </button>
              </div>
            </div>
            <div className="flex-1 overflow-y-auto p-4">
              <div 
                className="prose prose-sm max-w-none text-apple-text-dark"
                dangerouslySetInnerHTML={{ __html: originalText }}
              />
            </div>
          </div>

          {/* Optimized Side */}
          <div className="w-1/2 flex flex-col">
            <div className="px-4 py-2 bg-purple-50 border-b border-purple-200 flex items-center justify-between">
              <div className="flex items-center gap-2">
                <Sparkles className="w-4 h-4 text-purple-600" />
                <span className="text-sm font-medium text-purple-900">
                  Optimized for {targetName}
                </span>
                {isEditing && (
                  <span className="text-xs bg-purple-200 text-purple-800 px-2 py-0.5 rounded-full">
                    Editing
                  </span>
                )}
              </div>
              <div className="flex items-center gap-3">
                <span className="text-xs text-purple-600">{newWordCount} words</span>
                <span className={cn(
                  "text-xs",
                  charDiff > 0 ? "text-yellow-600" : charDiff < 0 ? "text-green-600" : "text-purple-600"
                )}>
                  {newCharCount} chars
                  {charDiff !== 0 && (
                    <span className="ml-1">
                      ({charDiff > 0 ? '+' : ''}{charDiff})
                    </span>
                  )}
                </span>
                <button
                  onClick={() => handleCopy(isEditing ? editedResult : result)}
                  className="p-1 rounded hover:bg-purple-100 transition-colors"
                  title="Copy optimized"
                >
                  <CopyIcon className="w-3.5 h-3.5 text-purple-600" />
                </button>
              </div>
            </div>
            <div className="flex-1 overflow-y-auto p-4">
              {isEditing ? (
                <textarea
                  value={editedResult}
                  onChange={(e) => setEditedResult(e.target.value)}
                  className="w-full h-full min-h-[200px] p-3 text-sm border border-purple-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 resize-none"
                  placeholder="Edit the optimized copy..."
                />
              ) : (
                <div 
                  className="prose prose-sm max-w-none text-apple-text-dark"
                  dangerouslySetInnerHTML={{ __html: result }}
                />
              )}
            </div>
          </div>
        </div>

        {/* Footer Actions */}
        <div className="px-6 py-4 border-t border-gray-200 bg-gray-50 flex items-center justify-between">
          <div className="flex items-center gap-2">
            <button
              onClick={() => setIsEditing(!isEditing)}
              className={cn(
                'flex items-center gap-2 py-2 px-4 rounded-lg text-sm font-medium transition-colors',
                isEditing 
                  ? 'bg-purple-100 text-purple-800 hover:bg-purple-200' 
                  : 'bg-white border border-gray-300 text-gray-700 hover:bg-gray-100'
              )}
            >
              <Edit3 className="w-4 h-4" />
              {isEditing ? 'Preview' : 'Edit Before Accepting'}
            </button>
          </div>

          <div className="flex items-center gap-3">
            <button
              onClick={handleReject}
              className="flex items-center gap-2 py-2 px-4 rounded-lg bg-white border border-gray-300 text-gray-700 text-sm font-medium hover:bg-gray-100 transition-colors"
            >
              <XCircle className="w-4 h-4" />
              Keep Original
            </button>
            <button
              onClick={handleAccept}
              disabled={isSavingVersion}
              className={cn(
                'flex items-center gap-2 py-2 px-5 rounded-lg text-sm font-medium transition-all',
                'bg-gradient-to-r from-green-600 to-emerald-600 text-white',
                'hover:from-green-700 hover:to-emerald-700',
                'focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2',
                'shadow-sm hover:shadow',
                isSavingVersion && 'opacity-50 cursor-wait'
              )}
            >
              <Check className="w-4 h-4" />
              {isSavingVersion ? 'Saving Version...' : 'Accept Rewrite'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}


=== FILE: components/workspace/PagedPreview.tsx ===

/**
 * @file components/workspace/PagedPreview.tsx
 * @description Professional print preview component using Paged.js
 * 
 * Features:
 * - True pagination using Paged.js W3C Paged Media implementation
 * - US Letter size (8.5" x 11") with 1" margins
 * - Automatic page numbering
 * - Proper page break handling (no widows/orphans)
 * - Headings stay with following content
 * - Loading state while rendering
 * - Smooth zoom controls
 * 
 * CRITICAL FIX: Proper React lifecycle handling to prevent
 * "Cannot read properties of null (reading 'getBoundingClientRect')" error
 */

'use client';

import React, { useEffect, useRef, useState, useCallback, useMemo } from 'react';
import { Previewer } from 'pagedjs';
import { cn } from '@/lib/utils';
import { X, ZoomIn, ZoomOut, Printer, RefreshCw } from 'lucide-react';

interface PagedPreviewProps {
  /** HTML content to render with pagination */
  content: string;
  /** Document title for display */
  title?: string;
  /** Callback when preview is closed */
  onClose: () => void;
  /** Optional CSS classes */
  className?: string;
}

/** Zoom levels available */
const ZOOM_LEVELS = [50, 75, 100, 125, 150] as const;
const DEFAULT_ZOOM = 75;

/**
 * PagedPreview - Professional print preview with Paged.js pagination
 * 
 * Renders HTML content through Paged.js to create true paginated output
 * with proper page breaks, margins, and page numbering.
 */
export function PagedPreview({
  content,
  title = 'Document Preview',
  onClose,
  className,
}: PagedPreviewProps) {
  // State
  const [isMounted, setIsMounted] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [pageCount, setPageCount] = useState(0);
  const [currentPage, setCurrentPage] = useState(1);
  const [zoom, setZoom] = useState(DEFAULT_ZOOM);
  const [retryCount, setRetryCount] = useState(0);
  
  // Refs
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const previewContainerRef = useRef<HTMLDivElement>(null);
  const contentSourceRef = useRef<HTMLDivElement>(null);
  const previewerRef = useRef<Previewer | null>(null);
  const styleBlobUrlRef = useRef<string | null>(null);
  
  /**
   * CSS stylesheet for paged content
   * Uses both modern (break-*) and legacy (page-break-*) properties
   */
  const pagedStyles = useMemo(() => `
    /* PAGE SETUP - US Letter with 1" margins */
    @page {
      size: 8.5in 11in;
      margin: 1in;
    }
    
    /* GLOBAL TYPOGRAPHY */
    body, .pagedjs_page_content, .paged-content-wrapper {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
      font-size: 12pt;
      line-height: 1.6;
      color: #1D1D1F;
    }
    
    /* HEADINGS - Must stay with following content */
    h1, h2, h3, h4, h5, h6 {
      break-after: avoid;
      break-inside: avoid;
      page-break-after: avoid;
      page-break-inside: avoid;
    }
    
    h1 {
      font-size: 24pt;
      font-weight: 700;
      margin-top: 0;
      margin-bottom: 12pt;
      line-height: 1.2;
    }
    
    h2 {
      font-size: 18pt;
      font-weight: 600;
      margin-top: 18pt;
      margin-bottom: 9pt;
      line-height: 1.3;
    }
    
    h3 {
      font-size: 14pt;
      font-weight: 600;
      margin-top: 14pt;
      margin-bottom: 7pt;
      line-height: 1.4;
    }
    
    h4 {
      font-size: 12pt;
      font-weight: 600;
      margin-top: 12pt;
      margin-bottom: 6pt;
      line-height: 1.4;
    }
    
    /* PARAGRAPHS - Prevent widows and orphans */
    p {
      margin-top: 0;
      margin-bottom: 9pt;
      orphans: 3;
      widows: 3;
    }
    
    /* LISTS - Keep together when possible */
    ul, ol {
      margin: 9pt 0;
      padding-left: 24pt;
      break-inside: avoid-page;
      page-break-inside: avoid;
    }
    
    li {
      margin-bottom: 4pt;
      break-inside: avoid;
      page-break-inside: avoid;
    }
    
    /* BLOCKQUOTES */
    blockquote {
      margin: 12pt 0;
      padding-left: 18pt;
      border-left: 3px solid #d2d2d7;
      font-style: italic;
      color: #6e6e73;
      break-inside: avoid;
      page-break-inside: avoid;
    }
    
    /* INLINE ELEMENTS */
    a { color: #0071E3; text-decoration: underline; }
    code {
      font-family: 'SF Mono', Monaco, 'Courier New', monospace;
      font-size: 10pt;
      background-color: #f5f5f7;
      padding: 2pt 4pt;
      border-radius: 2pt;
    }
    strong { font-weight: 600; }
    em { font-style: italic; }
    u { text-decoration: underline; }
    
    /* IMAGES */
    img {
      max-width: 100%;
      height: auto;
      break-inside: avoid;
      page-break-inside: avoid;
    }
    
    /* TABLES */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 12pt 0;
      break-inside: avoid;
      page-break-inside: avoid;
    }
    th, td {
      border: 1px solid #d2d2d7;
      padding: 6pt 9pt;
      text-align: left;
    }
    th { background-color: #f5f5f7; font-weight: 600; }
    tr { break-inside: avoid; page-break-inside: avoid; }
    
    /* HORIZONTAL RULES */
    hr {
      border: none;
      border-top: 1px solid #d2d2d7;
      margin: 18pt 0;
    }
  `, []);

  /**
   * Mark component as mounted after initial render
   */
  useEffect(() => {
    setIsMounted(true);
    return () => setIsMounted(false);
  }, []);

  /**
   * Generate preview with Paged.js
   * CRITICAL: Wait for DOM to be fully painted before calling Paged.js
   */
  const generatePreview = useCallback(async () => {
    // Guard: Ensure component is mounted
    if (!isMounted) {
      console.log('üìÑ Paged.js: Component not yet mounted, waiting...');
      return;
    }
    
    // Guard: Check refs exist
    if (!previewContainerRef.current) {
      console.error('‚ùå Paged.js: Preview container ref is null');
      setError('Preview container not ready. Please try again.');
      return;
    }
    
    // Guard: Check content exists
    if (!content || content.trim() === '') {
      console.error('‚ùå Paged.js: No content to preview');
      setError('No content to preview');
      return;
    }
    
    console.log('üìÑ Paged.js: Starting preview generation...');
    console.log('üìÑ Content length:', content.length, 'characters');
    
    setIsGenerating(true);
    setError(null);
    
    try {
      // Clean up previous preview
      if (previewerRef.current) {
        try {
          previewerRef.current.destroy();
        } catch (e) {
          // Ignore destroy errors
        }
        previewerRef.current = null;
      }
      
      // Clear previous content
      previewContainerRef.current.innerHTML = '';
      
      // Clean up previous blob URL
      if (styleBlobUrlRef.current) {
        URL.revokeObjectURL(styleBlobUrlRef.current);
        styleBlobUrlRef.current = null;
      }
      
      // CRITICAL: Wait for DOM to be fully painted
      // This prevents the "getBoundingClientRect" error
      await new Promise<void>((resolve) => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            resolve();
          });
        });
      });
      
      // Double-check refs still exist after waiting
      if (!previewContainerRef.current || !isMounted) {
        console.warn('‚ö†Ô∏è Paged.js: Container no longer available');
        return;
      }
      
      // Create Blob URL for stylesheet
      const styleBlob = new Blob([pagedStyles], { type: 'text/css' });
      const styleBlobUrl = URL.createObjectURL(styleBlob);
      styleBlobUrlRef.current = styleBlobUrl;
      
      // Inject styles into document head
      let styleEl = document.getElementById('pagedjs-custom-styles');
      if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = 'pagedjs-custom-styles';
        document.head.appendChild(styleEl);
      }
      styleEl.textContent = pagedStyles;
      
      // Create content with embedded styles
      const contentWithStyles = `
        <style>${pagedStyles}</style>
        <div class="paged-content-wrapper">
          ${content}
        </div>
      `;
      
      console.log('üìÑ Paged.js: Creating Previewer...');
      
      // Create and run previewer
      const previewer = new Previewer();
      previewerRef.current = previewer;
      
      // Final check before calling preview
      if (!previewContainerRef.current) {
        throw new Error('Preview container became null');
      }
      
      console.log('üìÑ Paged.js: Calling preview()...');
      
      const result = await previewer.preview(
        contentWithStyles,
        [styleBlobUrl],
        previewContainerRef.current
      );
      
      console.log('‚úÖ Paged.js: Preview generated successfully!');
      console.log('üìÑ Total pages:', result.total);
      
      setPageCount(result.total);
      setCurrentPage(1);
      setIsGenerating(false);
      
    } catch (err) {
      console.error('‚ùå Paged.js error:', err);
      const errorMessage = err instanceof Error ? err.message : 'Failed to generate preview';
      setError(errorMessage);
      setIsGenerating(false);
    }
  }, [isMounted, content, pagedStyles]);

  /**
   * Trigger preview generation when mounted and content is available
   */
  useEffect(() => {
    if (!isMounted || !content) {
      return;
    }
    
    // Add delay to ensure DOM is stable
    const timer = setTimeout(() => {
      generatePreview();
    }, 200);
    
    return () => clearTimeout(timer);
  }, [isMounted, content, retryCount, generatePreview]);

  /**
   * Handle retry button click
   */
  const handleRetry = useCallback(() => {
    setRetryCount((c) => c + 1);
  }, []);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      // Clean up previewer
      if (previewerRef.current) {
        try {
          previewerRef.current.destroy();
        } catch (e) {
          // Ignore errors
        }
        previewerRef.current = null;
      }
      
      // Clean up blob URL
      if (styleBlobUrlRef.current) {
        URL.revokeObjectURL(styleBlobUrlRef.current);
        styleBlobUrlRef.current = null;
      }
      
      // Clean up injected styles
      const styleEl = document.getElementById('pagedjs-custom-styles');
      if (styleEl) {
        styleEl.remove();
      }
    };
  }, []);

  /**
   * Track scroll position to update current page
   */
  useEffect(() => {
    const container = scrollContainerRef.current;
    if (!container || pageCount === 0) return;
    
    const handleScroll = () => {
      const pages = container.querySelectorAll('.pagedjs_page');
      if (pages.length === 0) return;
      
      const scrollTop = container.scrollTop;
      const containerHeight = container.clientHeight;
      const scrollMiddle = scrollTop + containerHeight / 2;
      
      let currentPageNum = 1;
      pages.forEach((page, index) => {
        const pageEl = page as HTMLElement;
        const pageTop = pageEl.offsetTop;
        const pageBottom = pageTop + pageEl.offsetHeight;
        
        if (scrollMiddle >= pageTop && scrollMiddle < pageBottom) {
          currentPageNum = index + 1;
        }
      });
      
      setCurrentPage(currentPageNum);
    };
    
    container.addEventListener('scroll', handleScroll);
    return () => container.removeEventListener('scroll', handleScroll);
  }, [pageCount]);

  /**
   * Zoom handlers
   */
  const handleZoomIn = useCallback(() => {
    setZoom((current) => {
      const idx = ZOOM_LEVELS.indexOf(current as typeof ZOOM_LEVELS[number]);
      return idx < ZOOM_LEVELS.length - 1 ? ZOOM_LEVELS[idx + 1] : current;
    });
  }, []);

  const handleZoomOut = useCallback(() => {
    setZoom((current) => {
      const idx = ZOOM_LEVELS.indexOf(current as typeof ZOOM_LEVELS[number]);
      return idx > 0 ? ZOOM_LEVELS[idx - 1] : current;
    });
  }, []);

  const handlePrint = useCallback(() => {
    // Import and use PDF export utility for proper filename
    import('@/lib/utils/pdf-export').then(({ printWithTitle }) => {
      printWithTitle(title);
    });
  }, [title]);

  const canZoomIn = zoom < ZOOM_LEVELS[ZOOM_LEVELS.length - 1];
  const canZoomOut = zoom > ZOOM_LEVELS[0];

  return (
    <div
      className={cn(
        'fixed inset-0 z-50',
        'flex flex-col',
        'bg-gray-100',
        className
      )}
    >
      {/* Header toolbar */}
      <div
        className={cn(
          'flex items-center justify-between',
          'px-4 py-3',
          'bg-white border-b border-gray-200',
          'shadow-sm'
        )}
      >
        {/* Left: Title */}
        <div className="flex items-center gap-3">
          <h1 className="text-lg font-semibold text-gray-900 truncate max-w-[300px]">
            {title}
          </h1>
          <span className="text-sm text-gray-500">
            Print Preview
          </span>
        </div>
        
        {/* Center: Zoom controls */}
        <div className="flex items-center gap-2 bg-gray-50 rounded-lg px-2 py-1.5 border border-gray-200">
          <button
            onClick={handleZoomOut}
            disabled={!canZoomOut || isGenerating}
            className={cn(
              'p-1.5 rounded transition-colors',
              'hover:bg-gray-100 active:bg-gray-200',
              'disabled:opacity-40 disabled:cursor-not-allowed'
            )}
            title="Zoom out"
          >
            <ZoomOut className="w-4 h-4 text-gray-600" />
          </button>
          
          <span className="px-2 min-w-[60px] text-center text-sm font-medium text-gray-700">
            {zoom}%
          </span>
          
          <button
            onClick={handleZoomIn}
            disabled={!canZoomIn || isGenerating}
            className={cn(
              'p-1.5 rounded transition-colors',
              'hover:bg-gray-100 active:bg-gray-200',
              'disabled:opacity-40 disabled:cursor-not-allowed'
            )}
            title="Zoom in"
          >
            <ZoomIn className="w-4 h-4 text-gray-600" />
          </button>
        </div>
        
        {/* Right: Actions */}
        <div className="flex items-center gap-2">
          <button
            onClick={handlePrint}
            disabled={isGenerating || !!error}
            className={cn(
              'flex items-center gap-2 px-3 py-1.5 rounded-md',
              'bg-primary text-white text-sm font-medium',
              'hover:bg-primary/90 active:bg-primary/80',
              'disabled:opacity-50 disabled:cursor-not-allowed',
              'transition-colors'
            )}
          >
            <Printer className="w-4 h-4" />
            Print
          </button>
          
          <button
            onClick={onClose}
            className={cn(
              'p-2 rounded-md',
              'hover:bg-gray-100 active:bg-gray-200',
              'transition-colors'
            )}
            title="Close preview"
          >
            <X className="w-5 h-5 text-gray-600" />
          </button>
        </div>
      </div>
      
      {/* Preview container */}
      <div
        ref={scrollContainerRef}
        className="flex-1 overflow-auto"
        style={{ background: '#e8e8e8' }}
      >
        {/* Loading state */}
        {isGenerating && (
          <div className="flex flex-col items-center justify-center min-h-[400px] gap-4">
            <div 
              className="w-10 h-10 border-4 border-gray-300 border-t-primary rounded-full animate-spin" 
            />
            <p className="text-sm text-gray-600">Generating preview...</p>
            <p className="text-xs text-gray-400">This may take a moment for longer documents</p>
          </div>
        )}
        
        {/* Error state */}
        {error && !isGenerating && (
          <div className="flex flex-col items-center justify-center min-h-[400px] gap-4">
            <div className="text-5xl">‚ö†Ô∏è</div>
            <p className="text-base font-medium text-gray-900">Preview Generation Failed</p>
            <p className="text-sm text-red-600 max-w-md text-center">{error}</p>
            <div className="flex gap-3">
              <button
                onClick={handleRetry}
                className={cn(
                  'flex items-center gap-2 px-4 py-2 rounded-md',
                  'bg-primary text-white text-sm font-medium',
                  'hover:bg-primary/90 active:bg-primary/80',
                  'transition-colors'
                )}
              >
                <RefreshCw className="w-4 h-4" />
                Try Again
              </button>
              <button
                onClick={onClose}
                className={cn(
                  'px-4 py-2 rounded-md',
                  'bg-gray-200 text-gray-700 text-sm font-medium',
                  'hover:bg-gray-300 active:bg-gray-400',
                  'transition-colors'
                )}
              >
                Close
              </button>
            </div>
          </div>
        )}
        
        {/* Preview render container */}
        <div
          ref={previewContainerRef}
          className={cn(
            'pagedjs-render-container',
            'py-6',
            (isGenerating || error) && 'hidden'
          )}
          style={{
            transform: `scale(${zoom / 100})`,
            transformOrigin: 'top center',
            minHeight: `${100 / (zoom / 100)}%`,
          }}
        />
        
        {/* Hidden content source (for debugging) */}
        <div
          ref={contentSourceRef}
          style={{ display: 'none' }}
          dangerouslySetInnerHTML={{ __html: content || '' }}
        />
      </div>
      
      {/* Page count badge */}
      {!isGenerating && !error && pageCount > 0 && (
        <div
          className={cn(
            'fixed bottom-6 right-6',
            'flex items-center gap-1.5',
            'px-3 py-1.5 rounded-full',
            'bg-white/90 backdrop-blur-sm',
            'border border-gray-200/60',
            'shadow-lg shadow-black/5',
            'text-xs font-medium text-gray-600'
          )}
        >
          <span>Page</span>
          <span className="text-gray-900">{currentPage}</span>
          <span className="text-gray-400">/</span>
          <span>{pageCount}</span>
        </div>
      )}
      
      {/* Global styles for Paged.js output */}
      <style jsx global>{`
        /* Container for all pages */
        .pagedjs_pages {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 24px;
          padding: 24px;
        }
        
        /* Individual page */
        .pagedjs_page {
          background: white;
          box-shadow: 
            0 1px 3px rgba(0, 0, 0, 0.08),
            0 4px 12px rgba(0, 0, 0, 0.05),
            0 0 0 1px rgba(0, 0, 0, 0.03);
          border-radius: 2px;
        }
        
        /* Page content area */
        .pagedjs_pagebox {
          position: relative;
        }
        
        /* Page margin boxes */
        .pagedjs_margin-bottom-center {
          position: absolute;
          bottom: 0.25in;
          left: 0;
          right: 0;
          text-align: center;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          font-size: 10pt;
          color: #666;
        }
        
        /* Hide page number on first page */
        .pagedjs_first_page .pagedjs_margin-bottom-center {
          display: none;
        }
        
        /* Print styles */
        @media print {
          .pagedjs_pages {
            padding: 0;
            gap: 0;
          }
          
          .pagedjs_page {
            box-shadow: none;
            border-radius: 0;
            page-break-after: always;
          }
        }
      `}</style>
    </div>
  );
}

export default PagedPreview;


=== FILE: components/workspace/PersonaAlignmentTool.tsx ===

/**
 * @file components/workspace/PersonaAlignmentTool.tsx
 * @description Standalone Persona Alignment checking tool
 * 
 * Features:
 * - Check selected copy against saved persona
 * - Display alignment score, strengths, improvements, and recommendations
 * - Requires at least one persona to be set up
 * - Persona selector dropdown
 * - Apple-style design aesthetic
 * 
 * @example
 * ```tsx
 * <PersonaAlignmentTool editor={editorInstance} />
 * ```
 */

'use client';

import React, { useMemo, useState } from 'react';
import { 
  UserCheck,
  CheckCircle,
  AlertTriangle,
  X,
  ThumbsUp,
  AlertCircle,
  Lightbulb,
  Sparkles,
  Folder,
  Users,
  ChevronDown,
  Wand2
} from 'lucide-react';
import { 
  useWorkspaceStore,
  useProjects, 
  useActiveProjectId, 
  useSelectedText,
  usePersonaAlignmentResult,
  usePersonaAlignmentLoading,
  usePersonaAlignmentError,
  usePersonaAlignmentActions,
  usePersonaAlignmentAnalyzedText,
  useOptimizeAlignmentLoading,
  useOptimizeAlignmentActions,
} from '@/lib/stores/workspaceStore';
import { AIWorxButtonLoader } from '@/components/ui/AIWorxLoader';
import type { Editor } from '@tiptap/react';
import type { Persona } from '@/lib/types/project';
import { cn } from '@/lib/utils';

interface PersonaAlignmentToolProps {
  /** TipTap editor instance */
  editor: Editor | null;
  
  /** Optional CSS classes */
  className?: string;
}

/**
 * PersonaAlignmentTool component - Standalone persona alignment checking
 */
export function PersonaAlignmentTool({ editor, className }: PersonaAlignmentToolProps) {
  // Optimized selectors
  const selectedText = useSelectedText();
  const personaAlignmentResult = usePersonaAlignmentResult();
  const personaAlignmentLoading = usePersonaAlignmentLoading();
  const personaAlignmentError = usePersonaAlignmentError();
  const personaAlignmentAnalyzedText = usePersonaAlignmentAnalyzedText();
  const { runPersonaAlignment, clearPersonaAlignmentResult } = usePersonaAlignmentActions();
  
  // Optimize alignment state
  const optimizeLoading = useOptimizeAlignmentLoading();
  const { runOptimizeAlignment } = useOptimizeAlignmentActions();
  
  // Get active project
  const activeProjectId = useActiveProjectId();
  const projects = useProjects();
  const activeProject = useMemo(
    () => projects.find((p) => p.id === activeProjectId),
    [projects, activeProjectId]
  );

  // Local state for selected persona
  const [selectedPersonaId, setSelectedPersonaId] = useState<string | null>(null);
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);

  // Get personas from active project
  const personas = activeProject?.personas || [];
  const hasPersonas = personas.length > 0;
  
  // Get selected persona
  const selectedPersona = useMemo(
    () => personas.find((p) => p.id === selectedPersonaId),
    [personas, selectedPersonaId]
  );

  // Check states
  const hasSelection = selectedText && selectedText.trim().length > 0;
  const canCheck = hasSelection && selectedPersona && !personaAlignmentLoading;

  /**
   * Handle check persona alignment
   */
  const handleCheckAlignment = async () => {
    if (!selectedPersona || !selectedText) return;
    await runPersonaAlignment(selectedText, selectedPersona);
  };

  /**
   * Navigate to Personas setup
   */
  const handleGoToPersonas = () => {
    useWorkspaceStore.getState().setActiveTool('personas');
  };

  /**
   * Handle rewrite to optimize for persona
   * Uses the analysis results to guide the rewrite
   */
  const handleRewriteToOptimize = async () => {
    if (!selectedPersona || !personaAlignmentResult) return;
    
    // Use the stored analyzed text (from when analysis was run)
    // This allows rewriting even if user has deselected the text
    const textToOptimize = personaAlignmentAnalyzedText;
    if (!textToOptimize) return;

    await runOptimizeAlignment(
      textToOptimize,
      'persona',
      personaAlignmentResult,
      selectedPersona
    );
  };

  return (
    <div className={cn('flex flex-col gap-6', className)}>
      {/* Header */}
      <div className="flex flex-col gap-2">
        <div className="flex items-center gap-2">
          <UserCheck className="w-5 h-5 text-apple-blue" />
          <h2 className="text-lg font-semibold text-apple-text-dark">
            Check Persona Alignment
          </h2>
        </div>
        <p className="text-sm text-apple-text-light">
          Analyze how well your copy resonates with your target persona
        </p>
      </div>

      {/* Personas Status */}
      {hasPersonas ? (
        <div className="flex flex-col gap-3">
          <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide">
            Select Persona
          </label>
          
          {/* Persona Dropdown */}
          <div className="relative">
            <button
              onClick={() => setIsDropdownOpen(!isDropdownOpen)}
              className={cn(
                'w-full px-3 py-2.5 text-left text-sm',
                'border rounded-lg transition-all duration-200',
                'flex items-center justify-between gap-2',
                'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
                selectedPersona
                  ? 'bg-blue-50 border-blue-200 text-blue-900'
                  : 'bg-white border-gray-300 text-apple-text-dark hover:border-gray-400'
              )}
            >
              <div className="flex items-center gap-2 min-w-0">
                <Users className="w-4 h-4 flex-shrink-0" />
                <span className="truncate">
                  {selectedPersona ? selectedPersona.name : 'Choose a persona...'}
                </span>
              </div>
              <ChevronDown className={cn(
                'w-4 h-4 flex-shrink-0 transition-transform duration-200',
                isDropdownOpen && 'rotate-180'
              )} />
            </button>
            
            {/* Dropdown Menu */}
            {isDropdownOpen && (
              <div className="absolute z-10 w-full mt-1 bg-white border border-gray-200 rounded-lg shadow-lg max-h-60 overflow-y-auto">
                {personas.map((persona) => (
                  <button
                    key={persona.id}
                    onClick={() => {
                      setSelectedPersonaId(persona.id);
                      setIsDropdownOpen(false);
                      clearPersonaAlignmentResult();
                    }}
                    className={cn(
                      'w-full px-3 py-2 text-left text-sm',
                      'hover:bg-gray-50 transition-colors duration-150',
                      'flex flex-col gap-0.5',
                      selectedPersonaId === persona.id && 'bg-blue-50'
                    )}
                  >
                    <span className="font-medium text-apple-text-dark">
                      {persona.name}
                    </span>
                    {persona.demographics && (
                      <span className="text-xs text-gray-500 truncate">
                        {persona.demographics}
                      </span>
                    )}
                  </button>
                ))}
              </div>
            )}
          </div>

          {/* Selected Persona Preview */}
          {selectedPersona && (
            <div className="p-3 bg-blue-50 border border-blue-200 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <CheckCircle className="w-4 h-4 text-blue-600" />
                <span className="text-sm font-medium text-blue-900">
                  {selectedPersona.name}
                </span>
              </div>
              <p className="text-xs text-blue-700">
                Ready to check copy alignment
              </p>
            </div>
          )}
        </div>
      ) : (
        <div className="flex flex-col gap-3 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
          <div className="flex items-start gap-2">
            <AlertTriangle className="w-4 h-4 text-yellow-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-sm font-medium text-yellow-900">
                No Personas Set Up
              </p>
              <p className="text-xs text-yellow-700 mt-0.5">
                Create at least one persona to check alignment
              </p>
            </div>
          </div>
          <button
            onClick={handleGoToPersonas}
            className={cn(
              'w-full py-2 px-3 rounded-lg',
              'bg-yellow-600 text-white text-sm font-medium',
              'hover:bg-yellow-700 transition-colors duration-200',
              'focus:outline-none focus:ring-2 focus:ring-yellow-600 focus:ring-offset-2',
              'flex items-center justify-center gap-2'
            )}
          >
            <Users className="w-4 h-4" />
            Create Persona
          </button>
        </div>
      )}

      {/* Active Project Indicator */}
      {activeProject && (
        <div className="flex items-center gap-2 px-3 py-2 bg-gray-50 border border-gray-200 rounded-lg">
          <Folder className="w-4 h-4 text-gray-600 flex-shrink-0" />
          <p className="text-xs text-gray-700 truncate">
            Project: <span className="font-medium">{activeProject.name}</span>
          </p>
        </div>
      )}

      {/* Selected Text Preview */}
      {hasSelection ? (
        <div className="flex flex-col gap-2">
          <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide flex items-center gap-1.5">
            <Sparkles className="w-3.5 h-3.5 text-apple-blue" />
            Selected Text ({selectedText?.length || 0} characters)
          </label>
          <div className="bg-apple-gray-bg border border-apple-gray-light rounded-lg p-3 max-h-32 overflow-y-auto custom-scrollbar">
            <p className="text-sm text-apple-text-dark whitespace-pre-wrap">
              {selectedText}
            </p>
          </div>
        </div>
      ) : (
        <div className="flex items-center gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
          <Sparkles className="w-4 h-4 text-blue-600 flex-shrink-0" />
          <p className="text-xs text-blue-700">
            Highlight text in the editor to check persona alignment
          </p>
        </div>
      )}

      {/* Check Alignment Button */}
      <button
        onClick={handleCheckAlignment}
        disabled={!canCheck}
        className={cn(
          'w-full py-3 px-4 rounded-lg',
          'font-medium text-sm text-white',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          // Animated gradient when loading
          personaAlignmentLoading && 'aiworx-gradient-animated cursor-wait',
          // Brand button with blue‚Üípurple active when not loading
          !personaAlignmentLoading && (hasSelection && selectedPersona) && 'bg-[#006EE6] hover:bg-[#0062CC] active:bg-[#7A3991] active:scale-[0.98] shadow-sm hover:shadow transition-all duration-200',
          // Gray background when truly disabled (not loading)
          (!hasSelection || !selectedPersona) && !personaAlignmentLoading && 'bg-apple-gray-light text-apple-text-light cursor-not-allowed'
        )}
      >
        {personaAlignmentLoading ? (
          <AIWorxButtonLoader />
        ) : selectedPersona ? (
          `Check Alignment with ${selectedPersona.name}`
        ) : (
          'Select a Persona'
        )}
      </button>

      {/* Helper Text */}
      {!hasSelection && hasPersonas && selectedPersona && (
        <p className="text-xs text-apple-text-light text-center">
          Select text in the editor to check persona alignment
        </p>
      )}

      {/* Error Display */}
      {personaAlignmentError && (
        <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
          <X className="w-4 h-4 text-red-600 flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <p className="text-sm font-medium text-red-900">Error</p>
            <p className="text-xs text-red-700 mt-1">{personaAlignmentError}</p>
          </div>
          <button
            onClick={clearPersonaAlignmentResult}
            className="text-red-600 hover:text-red-800 focus:outline-none"
            aria-label="Dismiss error"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
      )}

      {/* Results Display */}
      {personaAlignmentResult && selectedPersona && (
        <div className="flex flex-col gap-4">
          {/* Analyzing Against Banner */}
          <div className="flex items-center gap-2 px-3 py-2.5 bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-lg">
            <Users className="w-4 h-4 text-blue-600 flex-shrink-0" />
            <div className="flex-1 min-w-0">
              <p className="text-xs font-medium text-blue-900 truncate">
                Analyzing against: <span className="font-semibold">{selectedPersona.name}</span>
              </p>
            </div>
          </div>

          {/* Overall Score */}
          <div className="flex flex-col gap-3 p-4 bg-blue-50 border border-blue-200 rounded-lg">
            <div className="flex items-center justify-between">
              <span className="text-sm font-medium text-blue-900">
                Alignment Score
              </span>
              <span className="text-2xl font-bold text-blue-600">
                {personaAlignmentResult.score}%
              </span>
            </div>
            <p className="text-sm text-blue-700">
              {personaAlignmentResult.assessment}
            </p>
          </div>

          {/* Strengths */}
          {personaAlignmentResult.strengths.length > 0 && (
            <div className="flex flex-col gap-2 p-3 bg-green-50 border border-green-200 rounded-lg">
              <div className="flex items-center gap-2">
                <ThumbsUp className="w-4 h-4 text-green-600" />
                <span className="text-sm font-medium text-green-900">
                  Strengths
                </span>
              </div>
              <ul className="ml-6 space-y-1">
                {personaAlignmentResult.strengths.map((strength: string, index: number) => (
                  <li key={index} className="text-sm text-green-700">
                    {strength}
                  </li>
                ))}
              </ul>
            </div>
          )}

          {/* Improvements */}
          {personaAlignmentResult.improvements.length > 0 && (
            <div className="flex flex-col gap-2 p-3 bg-orange-50 border border-orange-200 rounded-lg">
              <div className="flex items-center gap-2">
                <AlertCircle className="w-4 h-4 text-orange-600" />
                <span className="text-sm font-medium text-orange-900">
                  Areas to Improve
                </span>
              </div>
              <ul className="ml-6 space-y-1">
                {personaAlignmentResult.improvements.map((improvement: string, index: number) => (
                  <li key={index} className="text-sm text-orange-700">
                    {improvement}
                  </li>
                ))}
              </ul>
            </div>
          )}

          {/* Recommendations */}
          {personaAlignmentResult.recommendations.length > 0 && (
            <div className="flex flex-col gap-2 p-3 bg-purple-50 border border-purple-200 rounded-lg">
              <div className="flex items-center gap-2">
                <Lightbulb className="w-4 h-4 text-purple-600" />
                <span className="text-sm font-medium text-purple-900">
                  Recommendations
                </span>
              </div>
              <ul className="ml-6 space-y-1">
                {personaAlignmentResult.recommendations.map((rec: string, index: number) => (
                  <li key={index} className="text-sm text-purple-700">
                    {rec}
                  </li>
                ))}
              </ul>
            </div>
          )}

          {/* Rewrite to Optimize Button - Always show when there's a result */}
          <button
            onClick={handleRewriteToOptimize}
            disabled={optimizeLoading || !personaAlignmentAnalyzedText}
            className={cn(
              'w-full py-3 px-4 rounded-lg',
              'font-medium text-sm text-white',
              'focus:outline-none focus:ring-2 focus:ring-purple-600 focus:ring-offset-2',
              'flex items-center justify-center gap-2',
              'transition-all duration-200',
              optimizeLoading 
                ? 'aiworx-gradient-animated cursor-wait'
                : 'bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 shadow-sm hover:shadow'
            )}
          >
            <Wand2 className="w-4 h-4" />
            {optimizeLoading 
              ? 'Rewriting...' 
              : `Rewrite to Optimize for ${selectedPersona.name}`
            }
          </button>

          {/* Clear Button */}
          <button
            onClick={clearPersonaAlignmentResult}
            className="w-full py-2 px-4 rounded-lg bg-gray-100 text-gray-700 text-sm font-medium hover:bg-gray-200 transition-colors duration-200"
          >
            Clear Results
          </button>
        </div>
      )}
    </div>
  );
}


=== FILE: components/workspace/PersonaCard.tsx ===

/**
 * @file components/workspace/PersonaCard.tsx
 * @description Reusable persona card component for displaying persona summaries
 * 
 * Features:
 * - Photo or placeholder display
 * - Name and demographics preview
 * - Edit and delete actions
 * - Hover effects and animations
 * 
 * @example
 * ```tsx
 * <PersonaCard
 *   persona={persona}
 *   onEdit={() => handleEdit(persona)}
 *   onDelete={() => handleDelete(persona.id)}
 * />
 * ```
 */

'use client';

import React from 'react';
import { Edit2, Trash2, User } from 'lucide-react';
import type { Persona } from '@/lib/types/project';
import { cn } from '@/lib/utils';

interface PersonaCardProps {
  /** Persona data to display */
  persona: Persona;
  
  /** Callback when edit button is clicked */
  onEdit: () => void;
  
  /** Callback when delete button is clicked */
  onDelete: () => void;
  
  /** Optional CSS classes */
  className?: string;
}

/**
 * PersonaCard component - Displays persona summary in a card
 * 
 * Performance: Memoized to prevent re-renders when props haven't changed
 */
export const PersonaCard = React.memo(function PersonaCard({
  persona,
  onEdit,
  onDelete,
  className,
}: PersonaCardProps) {
  // Truncate demographics for preview
  const demographicsPreview =
    persona.demographics.length > 80
      ? `${persona.demographics.substring(0, 80)}...`
      : persona.demographics;

  return (
    <div
      className={cn(
        'group relative bg-white rounded-lg border border-gray-200',
        'hover:border-purple-300 hover:shadow-md',
        'transition-all duration-200',
        'overflow-hidden',
        'flex flex-row', // Horizontal layout
        className
      )}
    >
      {/* Photo Section - Left Side */}
      <div className="relative w-24 h-24 flex-shrink-0 bg-gradient-to-br from-purple-50 to-blue-50 overflow-hidden">
        {persona.photoUrl ? (
          <img
            src={persona.photoUrl}
            alt={persona.name}
            className="w-full h-full object-cover"
          />
        ) : (
          <div className="flex items-center justify-center h-full">
            <User className="w-12 h-12 text-purple-300" strokeWidth={1.5} />
          </div>
        )}
      </div>

      {/* Content Section - Right Side */}
      <div className="flex-1 p-3 space-y-1.5 min-w-0">
        {/* Name - Full visible, no truncation */}
        <h3 className="text-base font-semibold text-gray-900 leading-tight">
          {persona.name}
        </h3>

        {/* Demographics Preview */}
        {persona.demographics && (
          <p className="text-xs text-gray-600 line-clamp-2">
            {demographicsPreview}
          </p>
        )}

        {/* Metadata */}
        <div className="text-[10px] text-gray-400">
          Created {new Date(persona.createdAt).toLocaleDateString()}
        </div>
      </div>

      {/* Action Buttons (show on hover) - Top Right */}
      <div className="absolute top-2 right-2 flex gap-1.5 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
        <button
          onClick={(e) => {
            e.stopPropagation();
            onEdit();
          }}
          className="p-1.5 bg-white/90 backdrop-blur-sm rounded-lg hover:bg-purple-50 transition-colors shadow-sm"
          title="Edit persona"
          aria-label="Edit persona"
        >
          <Edit2 className="w-3.5 h-3.5 text-purple-600" />
        </button>
        <button
          onClick={(e) => {
            e.stopPropagation();
            onDelete();
          }}
          className="p-1.5 bg-white/90 backdrop-blur-sm rounded-lg hover:bg-red-50 transition-colors shadow-sm"
          title="Delete persona"
          aria-label="Delete persona"
        >
          <Trash2 className="w-3.5 h-3.5 text-red-600" />
        </button>
      </div>

      {/* Hover Overlay for Click to Edit */}
      <div
        onClick={onEdit}
        className="absolute inset-0 bg-purple-500/0 hover:bg-purple-500/5 cursor-pointer transition-colors duration-200"
        aria-label={`View details for ${persona.name}`}
      />
    </div>
  );
});


=== FILE: components/workspace/PersonaForm.tsx ===

/**
 * @file components/workspace/PersonaForm.tsx
 * @description Form component for creating/editing personas
 * 
 * Features:
 * - Photo upload with drag & drop
 * - All persona fields with validation
 * - Create/Edit modes
 * - Form validation
 * - Success/error handling
 * 
 * @example
 * ```tsx
 * <PersonaForm
 *   persona={existingPersona} // or null for create
 *   onSave={(persona) => handleSave(persona)}
 *   onCancel={() => setShowForm(false)}
 * />
 * ```
 */

'use client';

import React, { useState, useRef, useEffect } from 'react';
import { Upload, X, User, Loader2 } from 'lucide-react';
import type { Persona } from '@/lib/types/project';
import { processImageFile } from '@/lib/utils/image-utils';
import { AutoExpandTextarea } from '@/components/ui/AutoExpandTextarea';
import { cn } from '@/lib/utils';

interface PersonaFormProps {
  /** Persona to edit (null for create mode) */
  persona: Persona | null;
  
  /** Callback when form is saved */
  onSave: (personaData: Omit<Persona, 'id' | 'createdAt' | 'updatedAt'>) => void;
  
  /** Callback when form is cancelled */
  onCancel: () => void;
  
  /** Optional CSS classes */
  className?: string;
}

/**
 * PersonaForm component - Create/Edit form for personas
 */
export function PersonaForm({
  persona,
  onSave,
  onCancel,
  className,
}: PersonaFormProps) {
  // Form state
  const [name, setName] = useState(persona?.name || '');
  const [photoUrl, setPhotoUrl] = useState(persona?.photoUrl || '');
  const [demographics, setDemographics] = useState(persona?.demographics || '');
  const [psychographics, setPsychographics] = useState(persona?.psychographics || '');
  const [painPoints, setPainPoints] = useState(persona?.painPoints || '');
  const [languagePatterns, setLanguagePatterns] = useState(persona?.languagePatterns || '');
  const [goals, setGoals] = useState(persona?.goals || '');

  // UI state
  const [isDragging, setIsDragging] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadError, setUploadError] = useState<string | null>(null);

  const fileInputRef = useRef<HTMLInputElement>(null);

  // Mode
  const isEditMode = !!persona;

  /**
   * Handle photo upload
   */
  const handlePhotoUpload = async (file: File) => {
    setIsUploading(true);
    setUploadError(null);

    try {
      const processedImage = await processImageFile(file);
      setPhotoUrl(processedImage);
      console.log('‚úÖ Photo uploaded successfully');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to upload photo';
      setUploadError(errorMessage);
      console.error('‚ùå Photo upload failed:', error);
    } finally {
      setIsUploading(false);
    }
  };

  /**
   * Handle file input change
   */
  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const file = e.target.files?.[0];
    if (file) {
      handlePhotoUpload(file);
    }
  };

  /**
   * Handle drag & drop
   */
  const handleDrop = (e: React.DragEvent): void => {
    e.preventDefault();
    setIsDragging(false);

    const file = e.dataTransfer.files?.[0];
    if (file) {
      handlePhotoUpload(file);
    }
  };

  /**
   * Handle form submission
   */
  const handleSubmit = (e: React.FormEvent): void => {
    e.preventDefault();

    // Validate required fields
    if (!name.trim()) {
      alert('Persona name is required');
      return;
    }

    // Create persona data
    const personaData: Omit<Persona, 'id' | 'createdAt' | 'updatedAt'> = {
      name: name.trim(),
      photoUrl: photoUrl || undefined,
      demographics: demographics.trim(),
      psychographics: psychographics.trim(),
      painPoints: painPoints.trim(),
      languagePatterns: languagePatterns.trim(),
      goals: goals.trim(),
    };

    onSave(personaData);
  };

  /**
   * Remove photo
   */
  const handleRemovePhoto = (): void => {
    setPhotoUrl('');
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  return (
    <form onSubmit={handleSubmit} className={cn('space-y-6', className)}>
      {/* Photo Upload */}
      <div className="space-y-2">
        <label className="text-sm font-medium text-gray-700">
          Persona Photo <span className="text-gray-400">(optional)</span>
        </label>

        {photoUrl ? (
          // Photo Preview
          <div className="relative w-48 h-48 rounded-lg overflow-hidden border-2 border-gray-200">
            <img
              src={photoUrl}
              alt="Persona preview"
              className="w-full h-full object-cover"
            />
            <button
              type="button"
              onClick={handleRemovePhoto}
              className="absolute top-2 right-2 p-1.5 bg-red-500 text-white rounded-full hover:bg-red-600 transition-colors shadow-lg"
              title="Remove photo"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        ) : (
          // Upload Zone
          <div
            onDragOver={(e) => {
              e.preventDefault();
              setIsDragging(true);
            }}
            onDragLeave={() => setIsDragging(false)}
            onDrop={handleDrop}
            onClick={() => fileInputRef.current?.click()}
            className={cn(
              'relative w-full h-48 rounded-lg border-2 border-dashed',
              'flex flex-col items-center justify-center gap-3',
              'cursor-pointer transition-all duration-200',
              isDragging
                ? 'border-purple-500 bg-purple-50'
                : 'border-gray-300 hover:border-purple-400 hover:bg-gray-50'
            )}
          >
            {isUploading ? (
              <>
                <Loader2 className="w-12 h-12 text-purple-500 animate-spin" />
                <p className="text-sm text-gray-600">Processing image...</p>
              </>
            ) : (
              <>
                <div className="p-4 bg-purple-100 rounded-full">
                  <Upload className="w-8 h-8 text-purple-600" />
                </div>
                <div className="text-center">
                  <p className="text-sm font-medium text-gray-700">
                    Drop photo here or click to browse
                  </p>
                  <p className="text-xs text-gray-500 mt-1">
                    JPG, PNG, or WebP (max 2MB)
                  </p>
                </div>
              </>
            )}
            <input
              ref={fileInputRef}
              type="file"
              accept="image/jpeg,image/jpg,image/png,image/webp"
              onChange={handleFileChange}
              className="hidden"
            />
          </div>
        )}

        {uploadError && (
          <p className="text-sm text-red-600">{uploadError}</p>
        )}
      </div>

      {/* Name & Title */}
      <div className="space-y-2">
        <label className="text-sm font-medium text-gray-700">
          Name & Title <span className="text-red-600">*</span>
        </label>
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder='e.g., "Sarah, the Startup Founder"'
          required
          className="w-full px-4 py-2.5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
        />
      </div>

      {/* Demographics */}
      <div className="space-y-2">
        <label className="text-sm font-medium text-gray-700">
          Demographics
        </label>
        <AutoExpandTextarea
          value={demographics}
          onChange={(e) => setDemographics(e.target.value)}
          placeholder="Age, income, location, job title"
          minHeight={80}
          className="w-full px-4 py-2.5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
        />
        <p className="text-xs text-gray-500">
          Example: Age 28-35, Tech-savvy, $500K-$2M revenue
        </p>
      </div>

      {/* Psychographics */}
      <div className="space-y-2">
        <label className="text-sm font-medium text-gray-700">
          Psychographics
        </label>
        <AutoExpandTextarea
          value={psychographics}
          onChange={(e) => setPsychographics(e.target.value)}
          placeholder="Values, interests, lifestyle, personality traits"
          minHeight={80}
          maxHeight={400}
          className="w-full px-4 py-2.5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
        />
      </div>

      {/* Pain Points */}
      <div className="space-y-2">
        <label className="text-sm font-medium text-gray-700">
          Pain Points
        </label>
        <AutoExpandTextarea
          value={painPoints}
          onChange={(e) => setPainPoints(e.target.value)}
          placeholder="Problems and frustrations they face"
          minHeight={80}
          className="w-full px-4 py-2.5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
        />
        <p className="text-xs text-gray-500">
          Example: Time management, Scaling operations, Cash flow
        </p>
      </div>

      {/* Language Patterns */}
      <div className="space-y-2">
        <label className="text-sm font-medium text-gray-700">
          Language Patterns
        </label>
        <AutoExpandTextarea
          value={languagePatterns}
          onChange={(e) => setLanguagePatterns(e.target.value)}
          placeholder="Words and phrases they use and respond to"
          minHeight={80}
          className="w-full px-4 py-2.5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
        />
        <p className="text-xs text-gray-500">
          Example: ROI, efficiency, move fast, scale, optimize
        </p>
      </div>

      {/* Goals & Aspirations */}
      <div className="space-y-2">
        <label className="text-sm font-medium text-gray-700">
          Goals & Aspirations
        </label>
        <AutoExpandTextarea
          value={goals}
          onChange={(e) => setGoals(e.target.value)}
          placeholder="What they want to achieve"
          minHeight={80}
          className="w-full px-4 py-2.5 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent"
        />
      </div>

      {/* Action Buttons */}
      <div className="flex gap-3 pt-4">
        <button
          type="button"
          onClick={onCancel}
          className="flex-1 px-6 py-3 border border-gray-300 text-gray-700 font-medium rounded-lg hover:bg-gray-50 transition-colors"
        >
          Cancel
        </button>
        <button
          type="submit"
          disabled={isUploading}
          className={cn(
            'flex-1 px-6 py-3 font-medium rounded-lg transition-all',
            'bg-gradient-to-r from-purple-600 to-blue-600',
            'text-white hover:from-purple-700 hover:to-blue-700',
            'disabled:opacity-50 disabled:cursor-not-allowed',
            'shadow-md hover:shadow-lg'
          )}
        >
          {isEditMode ? 'Update Persona' : 'Create Persona'}
        </button>
      </div>
    </form>
  );
}


=== FILE: components/workspace/PersonaSection.tsx ===

/**
 * @file components/workspace/PersonaSection.tsx
 * @description Personas list section for the My Projects slide-out
 * 
 * Features:
 * - Displays personas for a project
 * - Click to open personas panel
 * - Collapsible section
 * - Shows persona name and demographics preview
 */

'use client';

import React, { useState, useMemo } from 'react';
import {
  Users,
  User,
  ChevronRight,
  ChevronDown,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import type { Project, Persona } from '@/lib/types/project';
import { useSlideOutActions } from '@/lib/stores/slideOutStore';
import { usePendingEditActions } from '@/lib/stores/workspaceStore';
import { PERSONAS_PANEL_ID } from '@/components/workspace/PersonasSlideOut';

// ============================================================================
// Types
// ============================================================================

interface PersonaSectionProps {
  /** Project to display personas for */
  project: Project;
  /** Whether this project section is expanded */
  isExpanded: boolean;
  /** Search query for filtering */
  searchQuery?: string;
}

interface PersonaRowProps {
  persona: Persona;
  onSelect: (personaId: string) => void;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Truncate text with ellipsis
 */
function truncateText(text: string, maxLength: number): string {
  if (!text || text.length <= maxLength) return text;
  return text.substring(0, maxLength).trim() + '...';
}

// ============================================================================
// PersonaRow Component
// ============================================================================

function PersonaRow({ persona, onSelect }: PersonaRowProps) {
  return (
    <div
      className={cn(
        'group flex items-start gap-1.5 px-2 py-1.5 rounded-md cursor-pointer',
        'transition-colors duration-150',
        'hover:bg-gray-50'
      )}
      onClick={() => onSelect(persona.id)}
      title={`Click to view/edit "${persona.name}"`}
    >
      {persona.photoUrl ? (
        <img
          src={persona.photoUrl}
          alt={persona.name}
          className="h-3.5 w-3.5 rounded-full object-cover flex-shrink-0 mt-px"
        />
      ) : (
        <User className="h-3.5 w-3.5 text-purple-500 flex-shrink-0 mt-px" />
      )}
      
      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2">
          <span className="text-xs font-medium text-gray-900 truncate">
            {persona.name}
          </span>
        </div>
        {persona.demographics && (
          <p className="text-[10px] text-gray-500 truncate mt-0.5">
            {truncateText(persona.demographics, 60)}
          </p>
        )}
      </div>
    </div>
  );
}

// ============================================================================
// PersonaSection Component
// ============================================================================

export function PersonaSection({
  project,
  isExpanded,
  searchQuery = '',
}: PersonaSectionProps) {
  const [sectionExpanded, setSectionExpanded] = useState(true);
  const { openSlideOut } = useSlideOutActions();
  const { setPendingPersonaEdit } = usePendingEditActions();
  
  // Get personas from project
  const personas = project.personas || [];
  const hasPersonas = personas.length > 0;
  
  // Filter by search query if provided
  const filteredPersonas = useMemo(() => {
    if (!searchQuery.trim()) return personas;
    
    const query = searchQuery.toLowerCase();
    return personas.filter(persona =>
      persona.name.toLowerCase().includes(query) ||
      persona.demographics.toLowerCase().includes(query) ||
      persona.psychographics.toLowerCase().includes(query)
    );
  }, [personas, searchQuery]);
  
  // Don't render if project section is collapsed
  if (!isExpanded) {
    return null;
  }
  
  // Toggle section expanded state
  const toggleSection = () => {
    setSectionExpanded(prev => !prev);
  };
  
  // Handle persona selection - set pending edit then open
  const handlePersonaClick = (personaId: string) => {
    // Set the persona ID to edit
    setPendingPersonaEdit(personaId);
    openSlideOut(PERSONAS_PANEL_ID);
  };
  
  return (
    <div className="mt-2 ml-2 pl-2 border-l-2 border-purple-200">
      {/* Section header */}
      <div
        className={cn(
          'flex items-center gap-2 px-3 py-2 rounded-lg cursor-pointer',
          'hover:bg-purple-50 transition-colors duration-150'
        )}
        onClick={toggleSection}
      >
        {sectionExpanded ? (
          <ChevronDown className="h-4 w-4 text-purple-400 flex-shrink-0" />
        ) : (
          <ChevronRight className="h-4 w-4 text-purple-400 flex-shrink-0" />
        )}
        
        <Users className="h-4 w-4 text-purple-500 flex-shrink-0" />
        
        <span className="flex-1 text-sm font-semibold text-purple-900">
          Personas
        </span>
        
        {hasPersonas && (
          <span className="text-xs text-purple-500 px-2 py-0.5 bg-purple-100 rounded-full">
            {personas.length}
          </span>
        )}
      </div>
      
      {/* Persona list */}
      {sectionExpanded && (
        <div className="mt-1 space-y-1">
          {filteredPersonas.length > 0 ? (
            filteredPersonas.map(persona => (
              <PersonaRow
                key={persona.id}
                persona={persona}
                onSelect={handlePersonaClick}
              />
            ))
          ) : hasPersonas ? (
            <div className="text-xs text-gray-400 italic py-2 px-3">
              No personas match &quot;{searchQuery}&quot;
            </div>
          ) : (
            <div className="text-center py-4">
              <p className="text-xs text-gray-400">
                No personas yet
              </p>
              <button
                onClick={() => {
                  setPendingPersonaEdit(null);
                  openSlideOut(PERSONAS_PANEL_ID);
                }}
                className="mt-2 text-xs text-purple-600 hover:text-purple-700 font-medium"
              >
                + Add your first persona
              </button>
            </div>
          )}
        </div>
      )}
    </div>
  );
}

export default PersonaSection;


=== FILE: components/workspace/PersonasSlideOut.tsx ===

/**
 * @file components/workspace/PersonasSlideOut.tsx
 * @description Personas management slide-out panel
 * 
 * Features:
 * - 550px wide right slide-out panel
 * - List view with existing personas
 * - Create/Edit persona form
 * - Full CRUD operations
 * - Project-scoped personas
 */

'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { logger } from '@/lib/utils/logger';
import {
  Users,
  Plus,
  ArrowLeft,
  Trash2,
  AlertTriangle,
  Folder,
  User,
  Edit2,
} from 'lucide-react';
import { SlideOutPanel } from '@/components/ui/SlideOutPanel';
import { Button } from '@/components/ui/button';
import { ConfirmationModal } from '@/components/ui/ConfirmationModal';
import { PersonaForm } from '@/components/workspace/PersonaForm';
import { cn } from '@/lib/utils';
import { useWorkspaceStore, useActiveProjectId, useProjects, usePendingPersonaEdit, usePendingEditActions } from '@/lib/stores/workspaceStore';
import {
  getProjectPersonas,
  createPersona,
  updatePersona,
  deletePersona,
} from '@/lib/storage/unified-storage';
import type { Persona } from '@/lib/types/project';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/** Unique ID for the personas slide-out panel */
export const PERSONAS_PANEL_ID = 'personas-manager';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TYPES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

interface PersonasSlideOutProps {
  /** Whether the slide-out is open */
  isOpen: boolean;
  
  /** Callback when slide-out should close */
  onClose: () => void;
}

type ViewMode = 'list' | 'create' | 'edit';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SUB-COMPONENTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Persona Card Component for List View
 */
function PersonaCard({
  persona,
  onEdit,
  onDelete,
}: {
  persona: Persona;
  onEdit: () => void;
  onDelete: () => void;
}) {
  return (
    <div className="p-4 border border-gray-200 rounded-lg hover:border-apple-blue transition-colors duration-200 group">
      <div className="flex items-start gap-3">
        {/* Avatar/Icon */}
        <div className="flex-shrink-0 w-12 h-12 rounded-full bg-apple-blue/10 flex items-center justify-center">
          {persona.photoUrl ? (
            <img
              src={persona.photoUrl}
              alt={persona.name}
              className="w-full h-full rounded-full object-cover"
            />
          ) : (
            <User className="w-6 h-6 text-apple-blue" />
          )}
        </div>
        
        {/* Content */}
        <div className="flex-1 min-w-0">
          <h4 className="text-sm font-semibold text-gray-900 mb-1">
            {persona.name}
          </h4>
          <p className="text-xs text-gray-600 mb-2 line-clamp-2">
            {persona.demographics || 'No demographics specified'}
          </p>
          <div className="flex items-center gap-2">
            <button
              onClick={onEdit}
              className="text-xs text-apple-blue hover:text-apple-blue/80 font-medium flex items-center gap-1"
            >
              <Edit2 className="w-3 h-3" />
              Edit
            </button>
            <button
              onClick={onDelete}
              className="text-xs text-red-600 hover:text-red-700 font-medium flex items-center gap-1"
            >
              <Trash2 className="w-3 h-3" />
              Delete
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export function PersonasSlideOut({
  isOpen,
  onClose,
}: PersonasSlideOutProps) {
  // Store state
  const activeProjectId = useActiveProjectId();
  const projects = useProjects();
  const pendingPersonaEdit = usePendingPersonaEdit();
  const { setPendingPersonaEdit } = usePendingEditActions();
  
  // Get active project
  const activeProject = React.useMemo(
    () => projects.find((p) => p.id === activeProjectId),
    [projects, activeProjectId]
  );
  
  // View state
  const [viewMode, setViewMode] = useState<ViewMode>('list');
  const [personas, setPersonas] = useState<Persona[]>([]);
  const [editingPersona, setEditingPersona] = useState<Persona | null>(null);
  
  // Delete confirmation state
  const [personaToDelete, setPersonaToDelete] = useState<Persona | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);
  
  // Load personas when project changes or panel opens
  useEffect(() => {
    if (!isOpen || !activeProjectId) {
      setPersonas([]);
      return;
    }
    
    loadPersonas();
  }, [isOpen, activeProjectId]);
  
  // Check for pending persona edit and automatically switch to edit mode
  useEffect(() => {
    if (isOpen && pendingPersonaEdit && personas.length > 0) {
      // Find the persona by ID
      const personaToEdit = personas.find(p => p.id === pendingPersonaEdit);
      
      if (personaToEdit) {
        // Load into edit mode
        handleEdit(personaToEdit);
        
        // Clear the pending edit
        setPendingPersonaEdit(null);
      }
    }
  }, [isOpen, pendingPersonaEdit, personas, setPendingPersonaEdit]);
  
  /**
   * Load personas from storage
   */
  const loadPersonas = useCallback(async () => {
    if (!activeProjectId) return;
    
    const projectPersonas = await getProjectPersonas(activeProjectId);
    setPersonas(projectPersonas);
    logger.log(`üìã Loaded ${projectPersonas.length} persona(s)`);
  }, [activeProjectId]);
  
  /**
   * Handle create new persona
   */
  const handleCreateNew = useCallback(() => {
    setEditingPersona(null);
    setViewMode('create');
  }, []);
  
  /**
   * Handle edit persona
   */
  const handleEdit = useCallback((persona: Persona) => {
    setEditingPersona(persona);
    setViewMode('edit');
  }, []);
  
  /**
   * Handle back to list
   */
  const handleBackToList = useCallback(() => {
    setViewMode('list');
    setEditingPersona(null);
  }, []);
  
  /**
   * Handle save persona from PersonaForm
   */
  const handleSave = useCallback(async (personaData: Omit<Persona, 'id' | 'createdAt' | 'updatedAt'>) => {
    // Check if project exists
    if (!activeProject || !activeProjectId) {
      alert('No active project. Please create a project first.');
      return;
    }
    
    try {
      if (viewMode === 'edit' && editingPersona) {
        // Update existing persona
        await updatePersona(activeProjectId, editingPersona.id, personaData);
        logger.log('‚úÖ Persona updated');
      } else {
        // Create new persona
        await createPersona(activeProjectId, personaData);
        logger.log('‚úÖ Persona created');
      }
      
      // Reload personas and return to list
      await loadPersonas();
      handleBackToList();
    } catch (error) {
      const errorMessage = error instanceof Error 
        ? error.message 
        : 'Failed to save persona. Please try again.';
      alert(errorMessage);
      logger.error('‚ùå Failed to save persona:', error);
    }
  }, [activeProject, activeProjectId, viewMode, editingPersona, loadPersonas, handleBackToList]);
  
  /**
   * Handle delete persona - show confirmation modal
   */
  const handleDelete = useCallback((persona: Persona) => {
    setPersonaToDelete(persona);
  }, []);
  
  /**
   * Confirm delete persona
   */
  const confirmDelete = useCallback(async () => {
    if (!activeProjectId || !personaToDelete) return;
    
    setIsDeleting(true);
    
    try {
      await deletePersona(activeProjectId, personaToDelete.id);
      await loadPersonas();
      logger.log('‚úÖ Persona deleted');
      
      // Close modal
      setPersonaToDelete(null);
    } catch (error) {
      logger.error('‚ùå Failed to delete persona:', error);
      alert(error instanceof Error ? error.message : 'Failed to delete persona');
    } finally {
      setIsDeleting(false);
    }
  }, [activeProjectId, personaToDelete, loadPersonas]);
  
  /**
   * Cancel delete
   */
  const cancelDelete = useCallback(() => {
    setPersonaToDelete(null);
  }, []);
  
  // Panel footer - varies by view mode
  const panelFooter = viewMode === 'list' ? (
    <Button
      variant="brand"
      size="default"
      onClick={handleCreateNew}
      disabled={!activeProject}
      className="w-full"
    >
      <Plus className="h-4 w-4 mr-2" />
      Create New Persona
    </Button>
  ) : null;
  
  return (
    <>
    <SlideOutPanel
      isOpen={isOpen}
      onClose={onClose}
      side="right"
      title={
        viewMode === 'list' 
          ? 'Personas' 
          : viewMode === 'create' 
          ? 'Create Persona' 
          : 'Edit Persona'
      }
      subtitle={
        viewMode === 'list'
          ? `${personas.length} persona${personas.length !== 1 ? 's' : ''}`
          : 'Define your target audience profile'
      }
      footer={panelFooter}
    >
      <div className="space-y-6">
        {/* Active Project Indicator */}
        {activeProject ? (
          <div className="flex items-center gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
            <Folder className="w-4 h-4 text-blue-600 flex-shrink-0" />
            <div className="flex-1 min-w-0">
              <p className="text-xs font-medium text-blue-900">
                {viewMode === 'list' ? 'Personas for:' : 'Creating persona for:'}
              </p>
              <p className="text-sm font-semibold text-blue-700 truncate">
                {activeProject.name}
              </p>
            </div>
          </div>
        ) : (
          <div className="flex items-start gap-2 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
            <AlertTriangle className="w-4 h-4 text-yellow-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-sm font-medium text-yellow-900">
                No Active Project
              </p>
              <p className="text-xs text-yellow-700 mt-0.5">
                Please create or select a project to manage personas
              </p>
            </div>
          </div>
        )}
        
        {/* LIST VIEW */}
        {viewMode === 'list' && (
          <div className="space-y-4">
            {personas.length > 0 ? (
              <div className="space-y-3">
                {personas.map((persona) => (
                  <PersonaCard
                    key={persona.id}
                    persona={persona}
                    onEdit={() => handleEdit(persona)}
                    onDelete={() => handleDelete(persona)}
                  />
                ))}
              </div>
            ) : (
              <div className="text-center py-12">
                <Users className="w-12 h-12 mx-auto text-gray-300 mb-3" />
                <p className="text-sm font-medium text-gray-600 mb-1">
                  No Personas Yet
                </p>
                <p className="text-xs text-gray-500">
                  Create personas to target specific audience profiles
                </p>
              </div>
            )}
          </div>
        )}
        
        {/* CREATE/EDIT VIEW */}
        {(viewMode === 'create' || viewMode === 'edit') && (
          <PersonaForm
            persona={editingPersona}
            onSave={handleSave}
            onCancel={handleBackToList}
          />
        )}
      </div>
    </SlideOutPanel>
    
    {/* Delete Confirmation Modal */}
    <ConfirmationModal
      isOpen={!!personaToDelete}
      title="Delete Persona"
      message={`Delete "${personaToDelete?.name}"?`}
      description="This will permanently remove this persona. This cannot be undone."
      confirmLabel="Delete Persona"
      onClose={cancelDelete}
      onConfirm={confirmDelete}
      isConfirming={isDeleting}
      isDestructive={true}
    />
    </>
  );
}


=== FILE: components/workspace/PersonasTool.tsx ===

/**
 * @file components/workspace/PersonasTool.tsx
 * @description Main personas management tool
 * 
 * Features:
 * - List view with persona cards
 * - Create/edit form view
 * - Full CRUD operations
 * - Project-scoped personas
 * 
 * @example
 * ```tsx
 * <PersonasTool editor={editorInstance} />
 * ```
 */

'use client';

import React, { useState, useEffect } from 'react';
import { logger } from '@/lib/utils/logger';
import {
  Users,
  Plus,
  ArrowLeft,
  Folder,
  AlertTriangle,
} from 'lucide-react';
import type { Editor } from '@tiptap/react';
import type { Persona } from '@/lib/types/project';
import { useWorkspaceStore, useActiveProjectId, useProjects } from '@/lib/stores/workspaceStore';
import {
  getProjectPersonas,
  createPersona,
  updatePersona,
  deletePersona,
} from '@/lib/storage/unified-storage';
import { PersonaCard } from './PersonaCard';
import { PersonaForm } from './PersonaForm';
import { cn } from '@/lib/utils';

interface PersonasToolProps {
  /** TipTap editor instance */
  editor: Editor | null;
  
  /** Optional CSS classes */
  className?: string;
}

type ViewMode = 'list' | 'create' | 'edit';

/**
 * PersonasTool component - Main personas management interface
 */
export function PersonasTool({ editor, className }: PersonasToolProps) {
  const activeProjectId = useActiveProjectId();
  const projects = useProjects();
  // Memoize the find operation to avoid creating new references on every render
  const activeProject = React.useMemo(
    () => projects.find((p) => p.id === activeProjectId),
    [projects, activeProjectId]
  );

  // State
  const [viewMode, setViewMode] = useState<ViewMode>('list');
  const [personas, setPersonas] = useState<Persona[]>([]);
  const [editingPersona, setEditingPersona] = useState<Persona | null>(null);

  // Load personas when project changes
  useEffect(() => {
    if (activeProjectId) {
      loadPersonas();
    } else {
      setPersonas([]);
    }
  }, [activeProjectId]);

  /**
   * Load personas from storage
   */
  const loadPersonas = async () => {
    if (!activeProjectId) return;
    
    const projectPersonas = await getProjectPersonas(activeProjectId);
    setPersonas(projectPersonas);
    logger.log(`üìã Loaded ${projectPersonas.length} persona(s)`);
  };

  /**
   * Handle create new persona
   */
  const handleCreate = () => {
    setEditingPersona(null);
    setViewMode('create');
  };

  /**
   * Handle edit persona
   */
  const handleEdit = (persona: Persona) => {
    setEditingPersona(persona);
    setViewMode('edit');
  };

  /**
   * Handle save persona (create or update)
   */
  const handleSave = async (personaData: Omit<Persona, 'id' | 'createdAt' | 'updatedAt'>) => {
    if (!activeProjectId) {
      alert('No active project');
      return;
    }

    try {
      if (viewMode === 'edit' && editingPersona) {
        // Update existing persona
        await updatePersona(activeProjectId, editingPersona.id, personaData);
        logger.log('‚úÖ Persona updated');
      } else {
        // Create new persona
        await createPersona(activeProjectId, personaData);
        logger.log('‚úÖ Persona created');
      }

      // Reload personas and return to list
      await loadPersonas();
      setViewMode('list');
      setEditingPersona(null);
    } catch (error) {
      logger.error('‚ùå Failed to save persona:', error);
      alert(error instanceof Error ? error.message : 'Failed to save persona');
    }
  };

  /**
   * Handle delete persona
   */
  const handleDelete = async (personaId: string) => {
    if (!activeProjectId) return;

    const persona = personas.find((p) => p.id === personaId);
    if (!persona) return;

    const confirmed = confirm(
      `Are you sure you want to delete "${persona.name}"?\n\nThis action cannot be undone.`
    );

    if (!confirmed) return;

    try {
      await deletePersona(activeProjectId, personaId);
      await loadPersonas();
      logger.log('üóëÔ∏è Persona deleted');
    } catch (error) {
      logger.error('‚ùå Failed to delete persona:', error);
      alert(error instanceof Error ? error.message : 'Failed to delete persona');
    }
  };

  /**
   * Handle cancel form
   */
  const handleCancel = () => {
    setViewMode('list');
    setEditingPersona(null);
  };

  // Check if we have an active project
  const hasActiveProject = !!activeProject;

  return (
    <div className={cn('flex flex-col h-full', className)}>
      {/* Header */}
      <div className="flex-shrink-0 space-y-3 pb-4 border-b border-gray-200">
        <div className="flex items-center gap-2">
          <Users className="w-5 h-5 text-purple-600" />
          <h2 className="text-lg font-semibold text-gray-900">
            Persona Manager
          </h2>
        </div>

        {/* Active Project Indicator */}
        {activeProject ? (
          <div className="flex items-center gap-2 px-3 py-2 bg-purple-50 border border-purple-200 rounded-lg">
            <Folder className="w-4 h-4 text-purple-600 flex-shrink-0" />
            <div className="flex-1 min-w-0">
              <p className="text-xs font-medium text-purple-900">
                Personas for:
              </p>
              <p className="text-sm font-semibold text-purple-700 truncate">
                {activeProject.name}
              </p>
            </div>
          </div>
        ) : (
          <div className="flex items-start gap-2 px-3 py-2 bg-yellow-50 border border-yellow-200 rounded-lg">
            <AlertTriangle className="w-4 h-4 text-yellow-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-xs font-medium text-yellow-900">
                No Active Project
              </p>
              <p className="text-xs text-yellow-700 mt-0.5">
                Please select a project to manage personas
              </p>
            </div>
          </div>
        )}
      </div>

      {/* Content */}
      <div className="flex-1 overflow-y-auto custom-scrollbar pt-6">
        {!hasActiveProject ? (
          // No Project State
          <div className="text-center py-12 text-gray-400">
            <Users className="w-16 h-16 mx-auto mb-4 opacity-20" />
            <p className="text-sm font-medium text-gray-600 mb-1">
              No Project Selected
            </p>
            <p className="text-xs text-gray-500">
              Select a project from the sidebar to manage personas
            </p>
          </div>
        ) : viewMode === 'list' ? (
          // List View
          <div className="space-y-4">
            {/* Create Button */}
            <button
              onClick={handleCreate}
              className={cn(
                'w-full flex items-center justify-center gap-2 px-4 py-3',
                'bg-gradient-to-r from-purple-600 to-blue-600',
                'text-white font-medium rounded-lg',
                'hover:from-purple-700 hover:to-blue-700',
                'transition-all duration-200',
                'shadow-md hover:shadow-lg'
              )}
            >
              <Plus className="w-5 h-5" />
              Create New Persona
            </button>

            {/* Personas List */}
            {personas.length > 0 ? (
              <div className="space-y-3">
                {personas.map((persona) => (
                  <PersonaCard
                    key={persona.id}
                    persona={persona}
                    onEdit={() => handleEdit(persona)}
                    onDelete={() => handleDelete(persona.id)}
                  />
                ))}
              </div>
            ) : (
              // Empty State
              <div className="text-center py-12 border-2 border-dashed border-gray-300 rounded-lg">
                <Users className="w-16 h-16 mx-auto mb-4 text-gray-300" />
                <p className="text-sm font-medium text-gray-600 mb-1">
                  No Personas Yet
                </p>
                <p className="text-xs text-gray-500 mb-4">
                  Create your first persona to get started
                </p>
                <button
                  onClick={handleCreate}
                  className="inline-flex items-center gap-2 px-4 py-2 bg-purple-600 text-white text-sm font-medium rounded-lg hover:bg-purple-700 transition-colors"
                >
                  <Plus className="w-4 h-4" />
                  Create First Persona
                </button>
              </div>
            )}
          </div>
        ) : (
          // Form View (Create or Edit)
          <div className="space-y-4">
            {/* Back Button */}
            <button
              onClick={handleCancel}
              className="flex items-center gap-2 text-gray-600 hover:text-gray-900 transition-colors"
            >
              <ArrowLeft className="w-4 h-4" />
              <span className="text-sm font-medium">Back to Personas</span>
            </button>

            {/* Form */}
            <div className="bg-white rounded-lg border border-gray-200 p-6">
              <h3 className="text-lg font-semibold text-gray-900 mb-6">
                {viewMode === 'edit' ? 'Edit Persona' : 'Create New Persona'}
              </h3>
              <PersonaForm
                persona={editingPersona}
                onSave={handleSave}
                onCancel={handleCancel}
              />
            </div>
          </div>
        )}
      </div>
    </div>
  );
}


=== FILE: components/workspace/ProjectSelector.tsx ===

/**
 * @file components/workspace/ProjectSelector.tsx
 * @description Project selector dropdown component
 * 
 * Features:
 * - Shows current active project
 * - Dropdown menu to switch between projects
 * - Create new project option
 * - Rename/delete project actions
 * - Apple-style design aesthetic
 * 
 * @example
 * ```tsx
 * <ProjectSelector />
 * ```
 */

'use client';

import React, { useState, useRef, useEffect } from 'react';
import { logger } from '@/lib/utils/logger';
import {
  Folder,
  ChevronDown,
  Plus,
  MoreVertical,
  Check,
  Edit2,
  Trash2,
  X,
} from 'lucide-react';
import { useProjects, useActiveProjectId, useProjectActions } from '@/lib/stores/workspaceStore';
import { cn } from '@/lib/utils';

interface ProjectSelectorProps {
  /** Optional CSS classes */
  className?: string;
}

/**
 * ProjectSelector component - Dropdown for switching between projects
 */
export function ProjectSelector({ className }: ProjectSelectorProps) {
  const projects = useProjects();
  const activeProjectId = useActiveProjectId();
  const { setActiveProjectId, deleteProject, updateProject } = useProjectActions();

  // UI state
  const [isOpen, setIsOpen] = useState(false);
  const [showNewProjectDialog, setShowNewProjectDialog] = useState(false);
  const [editingProjectId, setEditingProjectId] = useState<string | null>(null);
  const [editingName, setEditingName] = useState('');
  const [showDeleteConfirm, setShowDeleteConfirm] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Refs
  const dropdownRef = useRef<HTMLDivElement>(null);

  // Get active project - memoize to avoid new references on every render
  const activeProject = React.useMemo(
    () => projects.find((p) => p.id === activeProjectId),
    [projects, activeProjectId]
  );

  // Close dropdown when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
        setEditingProjectId(null);
        setShowDeleteConfirm(null);
      }
    }

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
      return () => document.removeEventListener('mousedown', handleClickOutside);
    }
  }, [isOpen]);

  /**
   * Handle project switch
   */
  const handleProjectSwitch = (projectId: string): void => {
    if (projectId === activeProjectId) {
      setIsOpen(false);
      return;
    }

    setActiveProjectId(projectId);
    setIsOpen(false);
    logger.log('üîÑ Switched to project:', projectId);
  };

  /**
   * Handle start editing project name
   */
  const handleStartEdit = (projectId: string, currentName: string): void => {
    setEditingProjectId(projectId);
    setEditingName(currentName);
  };

  /**
   * Handle save edited project name
   */
  const handleSaveEdit = (projectId: string): void => {
    const trimmedName = editingName.trim();
    
    if (!trimmedName) {
      setError('Project name cannot be empty');
      return;
    }

    try {
      updateProject(projectId, { name: trimmedName });
      setEditingProjectId(null);
      setEditingName('');
      setError(null);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to update project');
    }
  };

  /**
   * Handle cancel editing
   */
  const handleCancelEdit = (): void => {
    setEditingProjectId(null);
    setEditingName('');
  };

  /**
   * Handle delete project
   */
  const handleDeleteProject = (projectId: string): void => {
    if (projects.length <= 1) {
      setError('Cannot delete the last project. At least one project must exist.');
      setShowDeleteConfirm(null);
      return;
    }

    try {
      deleteProject(projectId);
      setShowDeleteConfirm(null);
      setError(null);
    } catch (error) {
      setError(error instanceof Error ? error.message : 'Failed to delete project');
      setShowDeleteConfirm(null);
    }
  };

  return (
    <div className={cn('relative', className)} ref={dropdownRef}>
      {/* Selector Button */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={cn(
          'w-full flex items-center justify-between px-3 py-2.5 rounded-lg',
          'bg-white border border-gray-200',
          'hover:bg-gray-50 hover:border-gray-300',
          'transition-all duration-200',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          isOpen && 'ring-2 ring-apple-blue border-apple-blue'
        )}
        aria-expanded={isOpen}
        aria-haspopup="true"
      >
        <div className="flex items-center gap-2 flex-1 min-w-0">
          <Folder className="w-4 h-4 text-apple-blue flex-shrink-0" />
          <span className="text-sm font-medium text-apple-text-dark truncate">
            {activeProject?.name || 'No Project'}
          </span>
        </div>
        <ChevronDown
          className={cn(
            'w-4 h-4 text-gray-400 flex-shrink-0 transition-transform duration-200',
            isOpen && 'transform rotate-180'
          )}
        />
      </button>

      {/* Dropdown Menu */}
      {isOpen && (
        <div
          className={cn(
            'absolute top-full left-0 right-0 mt-1 z-50',
            'bg-white border border-gray-200 rounded-lg shadow-lg',
            'max-h-80 overflow-y-auto custom-scrollbar',
            'py-1'
          )}
        >
          {/* Project List */}
          {projects.map((project) => (
            <div key={project.id}>
              {editingProjectId === project.id ? (
                // Edit Mode
                <div className="px-2 py-2 flex items-center gap-2">
                  <input
                    type="text"
                    value={editingName}
                    onChange={(e) => setEditingName(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter') handleSaveEdit(project.id);
                      if (e.key === 'Escape') handleCancelEdit();
                    }}
                    className="flex-1 px-2 py-1 text-sm border border-apple-blue rounded focus:outline-none focus:ring-1 focus:ring-apple-blue"
                    autoFocus
                  />
                  <button
                    onClick={() => handleSaveEdit(project.id)}
                    className="p-1 text-green-600 hover:bg-green-50 rounded"
                    title="Save"
                  >
                    <Check className="w-4 h-4" />
                  </button>
                  <button
                    onClick={handleCancelEdit}
                    className="p-1 text-gray-600 hover:bg-gray-100 rounded"
                    title="Cancel"
                  >
                    <X className="w-4 h-4" />
                  </button>
                </div>
              ) : showDeleteConfirm === project.id ? (
                // Delete Confirmation
                <div className="px-3 py-2 bg-red-50 border-l-2 border-red-500">
                  <p className="text-xs text-red-900 font-medium mb-2">
                    Delete "{project.name}"?
                  </p>
                  <div className="flex gap-2">
                    <button
                      onClick={() => handleDeleteProject(project.id)}
                      className="flex-1 px-2 py-1 text-xs font-medium text-white bg-red-600 hover:bg-red-700 rounded"
                    >
                      Delete
                    </button>
                    <button
                      onClick={() => setShowDeleteConfirm(null)}
                      className="flex-1 px-2 py-1 text-xs font-medium text-gray-700 bg-gray-200 hover:bg-gray-300 rounded"
                    >
                      Cancel
                    </button>
                  </div>
                </div>
              ) : (
                // Normal Mode
                <div className="flex items-center group hover:bg-gray-50">
                  <button
                    onClick={() => handleProjectSwitch(project.id)}
                    className="flex-1 flex items-center gap-2 px-3 py-2 text-left"
                  >
                    <Folder className="w-4 h-4 text-gray-400 flex-shrink-0" />
                    <span className="text-sm text-apple-text-dark flex-1 truncate">
                      {project.name}
                    </span>
                    {project.id === activeProjectId && (
                      <Check className="w-4 h-4 text-apple-blue flex-shrink-0" />
                    )}
                  </button>

                  {/* Actions Menu */}
                  <div className="relative pr-2">
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        // Toggle actions menu (simplified - just show inline)
                      }}
                      className="p-1 opacity-0 group-hover:opacity-100 hover:bg-gray-200 rounded transition-opacity"
                      title="More actions"
                    >
                      <MoreVertical className="w-4 h-4 text-gray-600" />
                    </button>

                    {/* Inline actions on hover */}
                    <div className="absolute right-full top-0 mr-1 opacity-0 group-hover:opacity-100 flex gap-1 transition-opacity pointer-events-none group-hover:pointer-events-auto">
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          handleStartEdit(project.id, project.name);
                        }}
                        className="p-1 bg-white border border-gray-200 hover:bg-blue-50 hover:border-blue-300 rounded shadow-sm"
                        title="Rename"
                      >
                        <Edit2 className="w-3.5 h-3.5 text-blue-600" />
                      </button>
                      {projects.length > 1 && (
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setShowDeleteConfirm(project.id);
                          }}
                          className="p-1 bg-white border border-gray-200 hover:bg-red-50 hover:border-red-300 rounded shadow-sm"
                          title="Delete"
                        >
                          <Trash2 className="w-3.5 h-3.5 text-red-600" />
                        </button>
                      )}
                    </div>
                  </div>
                </div>
              )}
            </div>
          ))}

          {/* Separator */}
          <div className="border-t border-gray-200 my-1" />

          {/* New Project Button */}
          <button
            onClick={() => {
              setIsOpen(false);
              setShowNewProjectDialog(true);
            }}
            className="w-full flex items-center gap-2 px-3 py-2 text-left hover:bg-blue-50 transition-colors"
          >
            <Plus className="w-4 h-4 text-apple-blue" />
            <span className="text-sm font-medium text-apple-blue">New Project</span>
          </button>
        </div>
      )}

      {/* New Project Dialog */}
      {showNewProjectDialog && (
        <NewProjectDialog
          onClose={() => setShowNewProjectDialog(false)}
          onProjectCreated={(projectId) => {
            setShowNewProjectDialog(false);
            setActiveProjectId(projectId);
          }}
        />
      )}
    </div>
  );
}

/**
 * New Project Dialog Component (inline for now)
 */
function NewProjectDialog({
  onClose,
  onProjectCreated,
}: {
  onClose: () => void;
  onProjectCreated: (projectId: string) => void;
}) {
  const [projectName, setProjectName] = useState('');
  const { addProject, refreshProjects } = useProjectActions();
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  const [createError, setCreateError] = useState<string | null>(null);

  const handleCreate = () => {
    const trimmedName = projectName.trim();

    if (!trimmedName) {
      setCreateError('Project name cannot be empty');
      return;
    }

    try {
      // Import dynamically to avoid SSR issues
      const { createProject } = require('@/lib/storage/project-storage');
      const newProject = createProject(trimmedName);
      
      // Refresh projects in store
      refreshProjects();
      
      // Notify parent
      onProjectCreated(newProject.id);
      
      logger.log('‚úÖ Project created:', newProject.name);
    } catch (error) {
      setCreateError(error instanceof Error ? error.message : 'Failed to create project');
    }
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black/50"
      onClick={onClose}
    >
      <div
        className="bg-white rounded-lg shadow-xl p-6 w-full max-w-md"
        onClick={(e) => e.stopPropagation()}
      >
        <h2 className="text-lg font-semibold text-apple-text-dark mb-4">
          Create New Project
        </h2>

        <div className="mb-6">
          <label className="block text-sm font-medium text-gray-700 mb-2">
            Project Name
          </label>
          <input
            ref={inputRef}
            type="text"
            value={projectName}
            onChange={(e) => {
              setProjectName(e.target.value);
              setCreateError(null);
            }}
            onKeyDown={(e) => {
              if (e.key === 'Enter') handleCreate();
              if (e.key === 'Escape') onClose();
            }}
            placeholder="e.g., Marketing Campaign 2024"
            className="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-apple-blue focus:border-transparent"
          />
          {createError && (
            <p className="mt-2 text-sm text-red-600">{createError}</p>
          )}
        </div>

        <div className="flex gap-3 justify-end">
          <button
            onClick={onClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-100 rounded-lg transition-colors"
          >
            Cancel
          </button>
          <button
            onClick={handleCreate}
            className="px-4 py-2 text-sm font-medium text-white bg-apple-blue hover:bg-blue-600 rounded-lg transition-colors"
          >
            Create Project
          </button>
        </div>
      </div>
    </div>
  );
}


=== FILE: components/workspace/RewriteChannelTool.tsx ===

/**
 * @file components/workspace/RewriteChannelTool.tsx
 * @description AI-powered channel-specific copy rewriting component
 * 
 * Features:
 * - Five channel options: LinkedIn, Twitter, Instagram, Facebook, Email
 * - Platform-optimized copy rewriting
 * - Real-time loading states
 * - Result preview with insert/copy options
 * - Apple-style design aesthetic
 * - Full integration with Zustand store and TipTap editor
 * 
 * @example
 * ```tsx
 * <RewriteChannelTool editor={editorInstance} />
 * ```
 */

'use client';

import React, { useState } from 'react';
import { logger } from '@/lib/utils/logger';
import { 
  Repeat,
  Linkedin,
  Instagram,
  Facebook,
  Mail,
  Check, 
  X,
  Copy,
  Sparkles
} from 'lucide-react';
import { 
  useSelectedText,
  useSelectedHTML,
  useSelectionRange,
  useRewriteChannelResult,
  useRewriteChannelLoading,
  useRewriteChannelError,
  useRewriteChannelActions,
} from '@/lib/stores/workspaceStore';
import { insertTextAtSelection } from '@/lib/editor-utils';
import { formatGeneratedContent } from '@/lib/utils/content-formatting';
import { AIWorxButtonLoader } from '@/components/ui/AIWorxLoader';
import type { Editor } from '@tiptap/react';
import { cn } from '@/lib/utils';

/**
 * X (Twitter) social media logo icon component
 */
function XLogo({ className }: { className?: string }) {
  return (
    <svg
      viewBox="0 0 24 24"
      className={className}
      fill="currentColor"
      xmlns="http://www.w3.org/2000/svg"
    >
      <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z" />
    </svg>
  );
}

interface RewriteChannelToolProps {
  /** TipTap editor instance */
  editor: Editor | null;
  
  /** Optional CSS classes */
  className?: string;
}

/**
 * Channel type definition
 */
export type ChannelType = 'linkedin' | 'twitter' | 'instagram' | 'facebook' | 'email';

/**
 * Channel option configuration with icon and metadata
 */
const CHANNEL_OPTIONS: {
  value: ChannelType;
  label: string;
  icon: React.ComponentType<{ className?: string }>;
  description: string;
  color: string;
}[] = [
  {
    value: 'linkedin',
    label: 'LinkedIn',
    icon: Linkedin,
    description: 'Professional & thought leadership',
    color: 'blue',
  },
  {
    value: 'twitter',
    label: 'X',
    icon: XLogo,
    description: 'Punchy & conversational',
    color: 'sky',
  },
  {
    value: 'instagram',
    label: 'Instagram',
    icon: Instagram,
    description: 'Emotional & story-driven',
    color: 'pink',
  },
  {
    value: 'facebook',
    label: 'Facebook',
    icon: Facebook,
    description: 'Community-focused & relatable',
    color: 'indigo',
  },
  {
    value: 'email',
    label: 'Email',
    icon: Mail,
    description: 'Direct & action-oriented',
    color: 'gray',
  },
];

/**
 * RewriteChannelTool component - AI-powered channel-specific copy rewriting
 */
export function RewriteChannelTool({ editor, className }: RewriteChannelToolProps) {
  // Optimized selectors - only re-render when these specific values change
  const selectedText = useSelectedText();
  const selectedHTML = useSelectedHTML();
  const selectionRange = useSelectionRange();
  const rewriteChannelResult = useRewriteChannelResult();
  const rewriteChannelLoading = useRewriteChannelLoading();
  const rewriteChannelError = useRewriteChannelError();
  const { runRewriteChannel, clearRewriteChannelResult } = useRewriteChannelActions();

  // Local state for selected channel
  const [selectedChannel, setSelectedChannel] = useState<ChannelType | null>(null);

  // Check if user has text selected
  const hasSelection = selectedText && selectedText.trim().length > 0;
  const canRewrite = hasSelection && selectedChannel && !rewriteChannelLoading;

  /**
   * Handle channel selection
   */
  const handleChannelSelect = (channel: ChannelType): void => {
    setSelectedChannel(channel === selectedChannel ? null : channel);
    // Clear previous results when switching channels
    if (channel !== selectedChannel) {
      clearRewriteChannelResult();
    }
  };

  /**
   * Handle rewrite action
   * Uses HTML content to preserve formatting (bullets, headings, etc.)
   */
  const handleRewrite = async () => {
    if (!selectedChannel) return;
    
    // Prefer HTML for formatting preservation, fallback to plain text
    const contentToRewrite = selectedHTML || selectedText;
    if (!contentToRewrite) return;
    
    logger.log('üìù Rewriting for channel with formatting:', {
      hasHTML: !!selectedHTML,
      textLength: selectedText?.length || 0,
      htmlLength: selectedHTML?.length || 0,
      channel: selectedChannel,
    });
    
    await runRewriteChannel(contentToRewrite, selectedChannel);
  };

  /**
   * Handle replace selection with result
   */
  const handleReplaceSelection = (): void => {
    if (!editor || !rewriteChannelResult || !selectionRange) return;
    
    // Format the HTML result (sanitize and remove excess whitespace)
    const formattedHTML = formatGeneratedContent(rewriteChannelResult, false);
    
    // Use editor utils to replace the selection with formatted HTML
    const success = insertTextAtSelection(editor, formattedHTML, { isHTML: true });
    
    if (success) {
      // Clear the result after replacing
      clearRewriteChannelResult();
      logger.log('‚úÖ Rewritten content inserted with formatting preserved');
    }
  };

  /**
   * Handle copy result to clipboard
   */
  const handleCopyResult = async () => {
    if (!rewriteChannelResult) return;
    
    try {
      await navigator.clipboard.writeText(rewriteChannelResult);
      logger.log('‚úÖ Copied to clipboard');
    } catch (error) {
      logger.error('‚ùå Failed to copy:', error);
    }
  };

  return (
    <div className={cn('flex flex-col gap-6', className)}>
      {/* Header */}
      <div className="flex flex-col gap-2">
        <div className="flex items-center gap-2">
          <Repeat className="w-5 h-5 text-apple-blue" />
          <h2 className="text-lg font-semibold text-apple-text-dark">
            Rewrite for Channel
          </h2>
        </div>
        <p className="text-sm text-apple-text-light">
          Optimize your copy for different platforms
        </p>
      </div>

      {/* Selected Text Preview */}
      {hasSelection ? (
        <div className="flex flex-col gap-2">
          <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide flex items-center gap-1.5">
            <Sparkles className="w-3.5 h-3.5 text-apple-blue" />
            Selected Text ({selectedText?.length || 0} characters)
          </label>
          <div className="bg-apple-gray-bg border border-apple-gray-light rounded-lg p-3 max-h-32 overflow-y-auto custom-scrollbar">
            <p className="text-sm text-apple-text-dark whitespace-pre-wrap">
              {selectedText}
            </p>
          </div>
        </div>
      ) : (
        <div className="flex items-center gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
          <Sparkles className="w-4 h-4 text-blue-600 flex-shrink-0" />
          <p className="text-xs text-blue-700">
            Highlight text in the editor to rewrite
          </p>
        </div>
      )}

      {/* Channel Selection Buttons */}
      <div className="flex flex-col gap-3">
        <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide">
          Select Channel
        </label>
        <div className="flex flex-wrap gap-2">
          {CHANNEL_OPTIONS.map((channel) => {
            const Icon = channel.icon;
            const isSelected = selectedChannel === channel.value;
            
            return (
              <button
                key={channel.value}
                onClick={() => handleChannelSelect(channel.value)}
                disabled={rewriteChannelLoading}
                className={cn(
                  'flex items-center justify-center gap-2 px-4 py-2.5 rounded-lg',
                  'border transition-all duration-200',
                  'hover:shadow-sm focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
                  'disabled:opacity-50 disabled:cursor-not-allowed',
                  isSelected
                    ? 'bg-apple-blue text-white border-apple-blue shadow-sm'
                    : 'bg-white text-apple-text-dark border-apple-gray-light hover:border-apple-gray hover:bg-apple-gray-bg'
                )}
                title={channel.description}
              >
                <Icon className={cn('w-4 h-4', isSelected ? 'text-white' : 'text-apple-blue')} />
                {channel.value !== 'twitter' && (
                  <span className="text-sm font-medium">{channel.label}</span>
                )}
              </button>
            );
          })}
        </div>
        {selectedChannel && (
          <p className="text-xs text-apple-text-light mt-1">
            {CHANNEL_OPTIONS.find(c => c.value === selectedChannel)?.description}
          </p>
        )}
      </div>

      {/* Action Button */}
      <button
        onClick={handleRewrite}
        disabled={!canRewrite}
        className={cn(
          'w-full py-3 px-4 rounded-lg',
          'font-medium text-sm text-white',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          // Animated gradient when loading
          rewriteChannelLoading && 'aiworx-gradient-animated cursor-wait',
          // Brand button with blue‚Üípurple active when not loading
          !rewriteChannelLoading && (hasSelection && selectedChannel) && 'bg-[#006EE6] hover:bg-[#0062CC] active:bg-[#7A3991] active:scale-[0.98] shadow-sm hover:shadow transition-all duration-200',
          // Gray background when truly disabled (not loading)
          (!hasSelection || !selectedChannel) && !rewriteChannelLoading && 'bg-apple-gray-light text-apple-text-light cursor-not-allowed'
        )}
      >
        {rewriteChannelLoading ? (
          <AIWorxButtonLoader />
        ) : selectedChannel ? (
          `Rewrite for ${CHANNEL_OPTIONS.find(c => c.value === selectedChannel)?.label}`
        ) : (
          'Select a Channel'
        )}
      </button>

      {/* Helper Text */}
      {!hasSelection && (
        <p className="text-xs text-apple-text-light text-center">
          Select text in the editor to rewrite for different platforms
        </p>
      )}

      {/* Error Display */}
      {rewriteChannelError && (
        <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
          <X className="w-4 h-4 text-red-600 flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <p className="text-sm font-medium text-red-900">Error</p>
            <p className="text-xs text-red-700 mt-1">{rewriteChannelError}</p>
          </div>
          <button
            onClick={clearRewriteChannelResult}
            className="text-red-600 hover:text-red-800 focus:outline-none"
            aria-label="Dismiss error"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
      )}

      {/* Result Display */}
      {rewriteChannelResult && (
        <div className="flex flex-col gap-3 p-4 bg-green-50 border border-green-200 rounded-lg">
          {/* Success Header */}
          <div className="flex items-center gap-2">
            <Check className="w-5 h-5 text-green-600" />
            <span className="text-sm font-medium text-green-900">
              Rewrite Complete for {CHANNEL_OPTIONS.find(c => c.value === selectedChannel)?.label}
            </span>
          </div>

          {/* Result Preview */}
          <div className="bg-white border border-green-200 rounded p-3 max-h-48 overflow-y-auto custom-scrollbar">
            <div 
              className="text-sm text-apple-text-dark prose prose-sm max-w-none"
              dangerouslySetInnerHTML={{ __html: rewriteChannelResult }}
            />
          </div>

          {/* Action Buttons */}
          <div className="flex gap-2">
            <button
              onClick={handleReplaceSelection}
              className={cn(
                'flex-1 py-2 px-3 rounded-lg',
                'bg-green-600 text-white text-sm font-medium',
                'hover:bg-green-700 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              disabled={!selectionRange}
              title="Replace selected text with rewritten version"
            >
              <Check className="w-4 h-4" />
              Replace Selection
            </button>
            <button
              onClick={handleCopyResult}
              className={cn(
                'py-2 px-3 rounded-lg',
                'bg-white border border-green-300 text-green-700 text-sm font-medium',
                'hover:bg-green-50 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              title="Copy to clipboard"
            >
              <Copy className="w-4 h-4" />
            </button>
            <button
              onClick={clearRewriteChannelResult}
              className={cn(
                'py-2 px-3 rounded-lg',
                'bg-white border border-green-300 text-green-700 text-sm font-medium',
                'hover:bg-green-50 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              title="Clear result"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>
      )}
    </div>
  );
}


=== FILE: components/workspace/RightSidebarContent.tsx ===

/**
 * @file components/workspace/RightSidebarContent.tsx
 * @description Right sidebar content with dynamic tool rendering
 * 
 * IMPORTANT: This component is extracted to its own file to prevent
 * infinite re-render loops. Defining components inline inside parent
 * components causes React to treat them as new component types on
 * every render, triggering unmount/remount cycles.
 * 
 * Features:
 * - Dynamic tool component rendering based on activeToolId
 * - Template generator integration
 * - Empty state handling
 * - Placeholder components for tools under development
 */

'use client';

import React, { useCallback, useMemo } from 'react';
import { Sparkles, Layers } from 'lucide-react';
import { ToneShifter } from '@/components/workspace/ToneShifter';
import { TemplateGenerator } from '@/components/workspace/TemplateGenerator';
import { BrochureMultiSectionTemplate } from '@/components/workspace/BrochureMultiSectionTemplate';
import { ExpandTool } from '@/components/workspace/ExpandTool';
import { ShortenTool } from '@/components/workspace/ShortenTool';
import { RewriteChannelTool } from '@/components/workspace/RewriteChannelTool';
import { BrandVoiceTool } from '@/components/workspace/BrandVoiceTool';
import { PersonasTool } from '@/components/workspace/PersonasTool';
import { BrandAlignmentTool } from '@/components/workspace/BrandAlignmentTool';
import { PersonaAlignmentTool } from '@/components/workspace/PersonaAlignmentTool';
import { useWorkspaceStore } from '@/lib/stores/workspaceStore';
import { getTemplateById } from '@/lib/data/templates';

/**
 * Multi-section template IDs that use special components
 */
const MULTI_SECTION_TEMPLATE_IDS = ['brochure-multi-section'];
import { cn } from '@/lib/utils';
import type { Editor } from '@tiptap/react';
import type { Project } from '@/lib/types/project';

interface RightSidebarContentProps {
  /** TipTap editor instance */
  editor: Editor | null;
}

/**
 * Placeholder component for tools under development
 */
function PlaceholderTool({ 
  title, 
  description 
}: { 
  title: string; 
  description: string; 
  editor: Editor | null;
}) {
  return (
    <div className="flex flex-col gap-6">
      <div className="flex flex-col gap-2">
        <h2 className="text-lg font-semibold text-apple-text-dark">{title}</h2>
        <p className="text-sm text-apple-text-light">{description}</p>
      </div>
      <div className="p-12 text-center bg-gray-50 rounded-lg border-2 border-dashed border-gray-300">
        <p className="text-sm font-medium text-gray-600 mb-1">Coming Soon</p>
        <p className="text-xs text-gray-500">This tool is under development</p>
      </div>
    </div>
  );
}

/**
 * Tool component map - Maps tool IDs to their components
 * Defined outside component to prevent recreation on every render
 */
const TOOL_COMPONENTS: Record<string, React.ComponentType<{ editor: Editor | null }>> = {
  // MY COPY OPTIMIZER
  'tone-shifter': ToneShifter,
  'expand': ExpandTool,
  'shorten': ShortenTool,
  'rewrite-channel': RewriteChannelTool,
  
  // MY BRAND & AUDIENCE
  'personas': PersonasTool,
  'brand-voice': BrandVoiceTool,
  
  // MY INSIGHTS
  'competitor-analyzer': (props) => (
    <PlaceholderTool {...props} title="Competitor Analyzer" description="Analyze competitor copy" />
  ),
  'persona-alignment': PersonaAlignmentTool,
  'brand-alignment': BrandAlignmentTool,
};

/**
 * Right sidebar content - Dynamic tool rendering
 * 
 * Extracted to prevent infinite re-render loops when defined inline.
 */
export function RightSidebarContent({ editor }: RightSidebarContentProps) {
  // Use stable selectors for primitives
  const activeToolId = useWorkspaceStore((state) => state.activeToolId);
  const activeDocumentId = useWorkspaceStore((state) => state.activeDocumentId);
  const selectedTemplateId = useWorkspaceStore((state) => state.selectedTemplateId);
  const activeProjectId = useWorkspaceStore((state) => state.activeProjectId);
  const projects = useWorkspaceStore((state) => state.projects);
  
  // Check if we have an active document
  const hasActiveDocument = !!activeDocumentId;
  
  // Memoize the active project to prevent new object references on every render
  const activeProject = useMemo((): Project | null => {
    if (!activeProjectId) return null;
    return projects.find((p) => p.id === activeProjectId) || null;
  }, [activeProjectId, projects]);

  // Get the active tool component
  const ActiveToolComponent = activeToolId ? TOOL_COMPONENTS[activeToolId] : null;
  
  /**
   * Handle template generator cancel
   * Uses getState() to avoid stale closures and dependency issues
   */
  const handleTemplateCancel = useCallback(() => {
    const store = useWorkspaceStore.getState();
    store.setSelectedTemplateId(null);
    store.setActiveTool(null);
  }, []);

  // PRIORITY 1: Check for templates FIRST (before showing empty tool state)
  // Check the template ID directly to avoid race conditions with memos
  
  // Special case: Multi-Section Template (e.g., Brochure)
  // Check the ID directly - don't rely on memoized values
  if (selectedTemplateId && MULTI_SECTION_TEMPLATE_IDS.includes(selectedTemplateId)) {
    return (
      <div className="h-full">
        <BrochureMultiSectionTemplate
          onClose={handleTemplateCancel}
          editor={editor}
          activeProject={activeProject}
        />
      </div>
    );
  }

  // Special case: Regular Template Generator
  // Only render if we have a template ID and it's NOT a multi-section template
  if (selectedTemplateId && !MULTI_SECTION_TEMPLATE_IDS.includes(selectedTemplateId)) {
    const selectedTemplate = getTemplateById(selectedTemplateId);
    if (selectedTemplate) {
      return (
        <div className="h-full">
          <TemplateGenerator
            template={selectedTemplate}
            editor={editor}
            activeProject={activeProject}
            onCancel={handleTemplateCancel}
          />
        </div>
      );
    }
  }

  // PRIORITY 2: If no template is selected, show tools or empty state
  // Only show the toolbox header and empty states if NO template is active
  // Don't show anything if we're waiting for a template to load
  if (!ActiveToolComponent && !selectedTemplateId) {
    return (
      <div className="space-y-6">
        {/* Header - Always Shows "AI@Worx‚Ñ¢ ToolBox" */}
        <div className={cn(
          'flex items-center gap-2 px-3 py-2.5 rounded-lg',
          'bg-gray-50',
          'relative pl-5 border-l-[3px] border-transparent',
          'before:content-[""] before:absolute before:left-0 before:top-0 before:bottom-0',
          'before:w-[3px] before:rounded-l-lg',
          'before:bg-gradient-to-b before:from-[#006EE6] before:to-[#7A3991]'
        )}>
          <Sparkles className="w-5 h-5 text-apple-blue" />
          <h2 className="text-sm font-semibold text-apple-text-dark uppercase tracking-wide">
            AI@Worx‚Ñ¢ ToolBox
          </h2>
        </div>

        {/* Empty state - no tool selected */}
        <div className="text-center py-16 text-gray-400">
          <Layers className="w-16 h-16 mx-auto mb-4 opacity-20" />
          <p className="text-sm font-medium text-gray-600 mb-1">
            Select a Tool
          </p>
          <p className="text-xs text-gray-500">
            Choose a tool from the left sidebar to get started
          </p>
        </div>
      </div>
    );
  }

  // Show tool content if a tool is selected
  if (ActiveToolComponent) {
    return (
      <div className="space-y-6">
        {/* Header - Always Shows "AI@Worx‚Ñ¢ ToolBox" */}
        <div className={cn(
          'flex items-center gap-2 px-3 py-2.5 rounded-lg',
          'bg-gray-50',
          'relative pl-5 border-l-[3px] border-transparent',
          'before:content-[""] before:absolute before:left-0 before:top-0 before:bottom-0',
          'before:w-[3px] before:rounded-l-lg',
          'before:bg-gradient-to-b before:from-[#006EE6] before:to-[#7A3991]'
        )}>
          <Sparkles className="w-5 h-5 text-apple-blue" />
          <h2 className="text-sm font-semibold text-apple-text-dark uppercase tracking-wide">
            AI@Worx‚Ñ¢ ToolBox
          </h2>
        </div>

        {/* Dynamic Tool Rendering */}
        {!hasActiveDocument ? (
          // Tool selected but no document open
          <div className="text-center py-16 text-gray-400">
            <Sparkles className="w-16 h-16 mx-auto mb-4 opacity-20" />
            <p className="text-sm font-medium text-gray-600 mb-1">
              No Document Open
            </p>
            <p className="text-xs text-gray-500">
              Create a document to use this tool
            </p>
          </div>
        ) : (
          // Render active tool
          <ActiveToolComponent editor={editor} />
        )}
      </div>
    );
  }

  // If we get here, something is loading (likely a template that hasn't rendered yet)
  // Show nothing or a minimal loading state
  return null;
}


=== FILE: components/workspace/SaveAsSnippetButton.tsx ===

/**
 * @file components/workspace/SaveAsSnippetButton.tsx
 * @description Button component to save selected text as a snippet
 * 
 * Features:
 * - Appears when text is selected in the editor
 * - Opens the Save as Snippet modal
 * - Shows disabled state when no selection
 */

'use client';

import React, { useCallback } from 'react';
import { Scissors } from 'lucide-react';
import { cn } from '@/lib/utils';
import { useSelectedText, useActiveProjectId } from '@/lib/stores/workspaceStore';
import { useSnippetActions } from '@/lib/stores/snippetStore';

interface SaveAsSnippetButtonProps {
  /** Optional CSS classes */
  className?: string;
  /** Whether to show label text */
  showLabel?: boolean;
  /** Button variant */
  variant?: 'default' | 'toolbar';
  /** Optional data-tour attribute for product tour */
  dataTour?: string;
}

/**
 * Button to save selected text as a snippet
 * 
 * @example
 * ```tsx
 * // In toolbar
 * <SaveAsSnippetButton variant="toolbar" />
 * 
 * // In context menu
 * <SaveAsSnippetButton showLabel />
 * ```
 */
export function SaveAsSnippetButton({
  className,
  showLabel = false,
  variant = 'default',
  dataTour,
}: SaveAsSnippetButtonProps) {
  const selectedText = useSelectedText();
  const activeProjectId = useActiveProjectId();
  const { openSaveAsSnippet, loadSnippets } = useSnippetActions();
  
  // Check if we have text selected and a project
  const hasSelection = selectedText && selectedText.trim().length > 0;
  const hasProject = !!activeProjectId;
  const isDisabled = !hasSelection || !hasProject;
  
  // Handle click - open save as snippet modal
  const handleClick = useCallback(() => {
    if (isDisabled || !selectedText) return;
    
    // Load snippets for current project first
    if (activeProjectId) {
      loadSnippets(activeProjectId);
    }
    
    // Open the modal with selected text
    openSaveAsSnippet(selectedText);
  }, [isDisabled, selectedText, activeProjectId, loadSnippets, openSaveAsSnippet]);
  
  // Get button styles based on variant
  const buttonStyles = variant === 'toolbar'
    ? cn(
        'w-8 h-8 rounded-md',
        'flex items-center justify-center',
        'transition-all duration-150',
        'focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2',
        isDisabled
          ? 'opacity-30 cursor-not-allowed'
          : hasSelection
          ? 'bg-purple-100 text-purple-600 hover:bg-purple-200'
          : 'text-apple-text-dark hover:bg-apple-gray-bg'
      )
    : cn(
        'px-3 py-2 rounded-lg',
        'text-sm font-medium',
        'flex items-center gap-2',
        'transition-colors duration-150',
        'focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2',
        isDisabled
          ? 'opacity-50 cursor-not-allowed text-gray-400'
          : 'text-purple-600 hover:bg-purple-50'
      );
  
  // Get title/tooltip
  const title = isDisabled
    ? !hasProject
      ? 'Select a project first'
      : 'Select text to save as snippet'
    : 'Save selection as snippet';

  return (
    <button
      onClick={handleClick}
      disabled={isDisabled}
      title={title}
      className={cn(buttonStyles, className)}
      data-tour={dataTour}
    >
      <Scissors className={cn(
        variant === 'toolbar' ? 'w-4 h-4' : 'w-4 h-4',
        hasSelection && !isDisabled && 'text-purple-600'
      )} />
      {showLabel && (
        <span>Save as Snippet</span>
      )}
    </button>
  );
}

export default SaveAsSnippetButton;


=== FILE: components/workspace/ShortenTool.tsx ===

/**
 * @file components/workspace/ShortenTool.tsx
 * @description AI-powered copy shortening component
 * 
 * Features:
 * - Shortens copy while preserving core message and impact
 * - Real-time loading states
 * - Result preview with insert/copy options
 * - Apple-style design aesthetic
 * - Full integration with Zustand store and TipTap editor
 * 
 * @example
 * ```tsx
 * <ShortenTool editor={editorInstance} />
 * ```
 */

'use client';

import React from 'react';
import { 
  Minimize2, 
  Check, 
  X,
  Copy,
  FileText,
  Sparkles
} from 'lucide-react';
import { 
  useSelectedText,
  useSelectedHTML,
  useSelectionRange,
  useShortenResult,
  useShortenLoading,
  useShortenError,
  useShortenActions,
} from '@/lib/stores/workspaceStore';
import { insertTextAtSelection } from '@/lib/editor-utils';
import { formatGeneratedContent } from '@/lib/utils/content-formatting';
import { AIWorxButtonLoader } from '@/components/ui/AIWorxLoader';
import type { Editor } from '@tiptap/react';
import { cn } from '@/lib/utils';
import { logger } from '@/lib/utils/logger';

interface ShortenToolProps {
  /** TipTap editor instance */
  editor: Editor | null;
  
  /** Optional CSS classes */
  className?: string;
}

/**
 * ShortenTool component - AI-powered copy shortening tool
 */
export function ShortenTool({ editor, className }: ShortenToolProps) {
  // Optimized selectors - only re-render when these specific values change
  const selectedText = useSelectedText();
  const selectedHTML = useSelectedHTML();
  const selectionRange = useSelectionRange();
  const shortenResult = useShortenResult();
  const shortenLoading = useShortenLoading();
  const shortenError = useShortenError();
  const { runShorten, clearShortenResult, insertShortenResult } = useShortenActions();

  // Check if user has text selected
  const hasSelection = selectedText && selectedText.trim().length > 0;
  const canShorten = hasSelection && !shortenLoading;

  /**
   * Handle shorten action
   * Uses HTML content to preserve formatting (bullets, headings, etc.)
   */
  const handleShorten = async () => {
    // Prefer HTML for formatting preservation, fallback to plain text
    const contentToShorten = selectedHTML || selectedText;
    if (!contentToShorten) return;
    
    logger.log('üìù Shortening with formatting:', {
      hasHTML: !!selectedHTML,
      textLength: selectedText?.length || 0,
      htmlLength: selectedHTML?.length || 0,
    });
    
    await runShorten(contentToShorten);
  };

  /**
   * Handle replace selection with result
   */
  const handleReplaceSelection = (): void => {
    if (!editor || !shortenResult || !selectionRange) return;
    
    // Format the HTML result (sanitize and remove excess whitespace)
    const formattedHTML = formatGeneratedContent(shortenResult, false);
    
    // Use editor utils to replace the selection with formatted HTML
    const success = insertTextAtSelection(editor, formattedHTML, { isHTML: true });
    
    if (success) {
      // Clear the result after replacing
      clearShortenResult();
      logger.log('‚úÖ Shortened content inserted with formatting preserved');
    }
  };

  /**
   * Handle insert result into editor (replaces entire document)
   */
  const handleInsertResult = (): void => {
    if (!editor) return;
    insertShortenResult(editor);
  };

  /**
   * Handle copy result to clipboard
   */
  const handleCopyResult = async (): Promise<void> => {
    if (!shortenResult) return;
    
    try {
      await navigator.clipboard.writeText(shortenResult);
      // TODO: Show toast notification
      logger.log('‚úÖ Copied to clipboard');
    } catch (error) {
      logger.error('‚ùå Failed to copy:', error);
    }
  };

  return (
    <div className={cn('flex flex-col gap-6', className)}>
      {/* Header */}
      <div className="flex flex-col gap-2">
        <div className="flex items-center gap-2">
          <Minimize2 className="w-5 h-5 text-apple-blue" />
          <h2 className="text-lg font-semibold text-apple-text-dark">
            Shorten Copy
          </h2>
        </div>
        <p className="text-sm text-apple-text-light">
          Make your copy concise and impactful
        </p>
      </div>

      {/* Selected Text Preview */}
      {hasSelection ? (
        <div className="flex flex-col gap-2">
          <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide flex items-center gap-1.5">
            <Sparkles className="w-3.5 h-3.5 text-apple-blue" />
            Selected Text ({selectedText?.length || 0} characters)
          </label>
          <div className="bg-apple-gray-bg border border-apple-gray-light rounded-lg p-3 max-h-32 overflow-y-auto custom-scrollbar">
            <p className="text-sm text-apple-text-dark whitespace-pre-wrap">
              {selectedText}
            </p>
          </div>
        </div>
      ) : (
        <div className="flex items-center gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
          <Sparkles className="w-4 h-4 text-blue-600 flex-shrink-0" />
          <p className="text-xs text-blue-700">
            Highlight text in the editor to shorten
          </p>
        </div>
      )}

      {/* Action Button */}
      <button
        onClick={handleShorten}
        disabled={!canShorten}
        className={cn(
          'w-full py-3 px-4 rounded-lg',
          'font-medium text-sm text-white',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          // Animated gradient when loading
          shortenLoading && 'aiworx-gradient-animated cursor-wait',
          // Brand button with blue‚Üípurple active when not loading
          !shortenLoading && hasSelection && 'bg-[#006EE6] hover:bg-[#0062CC] active:bg-[#7A3991] active:scale-[0.98] shadow-sm hover:shadow transition-all duration-200',
          // Gray background when truly disabled (not loading)
          !hasSelection && !shortenLoading && 'bg-apple-gray-light text-apple-text-light cursor-not-allowed'
        )}
      >
        {shortenLoading ? (
          <AIWorxButtonLoader />
        ) : (
          'Shorten Copy'
        )}
      </button>

      {/* Helper Text */}
      {!hasSelection && (
        <p className="text-xs text-apple-text-light text-center">
          Select text in the editor to use Shorten
        </p>
      )}

      {/* Error Display */}
      {shortenError && (
        <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
          <X className="w-4 h-4 text-red-600 flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <p className="text-sm font-medium text-red-900">Error</p>
            <p className="text-xs text-red-700 mt-1">{shortenError}</p>
          </div>
          <button
            onClick={clearShortenResult}
            className="text-red-600 hover:text-red-800 focus:outline-none"
            aria-label="Dismiss error"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
      )}

      {/* Result Display */}
      {shortenResult && (
        <div className="flex flex-col gap-3 p-4 bg-green-50 border border-green-200 rounded-lg">
          {/* Success Header */}
          <div className="flex items-center gap-2">
            <Check className="w-5 h-5 text-green-600" />
            <span className="text-sm font-medium text-green-900">
              Shortened Complete
            </span>
          </div>

          {/* Result Preview */}
          <div className="bg-white border border-green-200 rounded p-3 max-h-48 overflow-y-auto custom-scrollbar">
            <div 
              className="text-sm text-apple-text-dark prose prose-sm max-w-none"
              dangerouslySetInnerHTML={{ __html: shortenResult }}
            />
          </div>

          {/* Action Buttons */}
          <div className="flex gap-2">
            <button
              onClick={handleReplaceSelection}
              className={cn(
                'flex-1 py-2 px-3 rounded-lg',
                'bg-green-600 text-white text-sm font-medium',
                'hover:bg-green-700 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              disabled={!selectionRange}
              title="Replace selected text with shortened version"
            >
              <Check className="w-4 h-4" />
              Replace Selection
            </button>
            <button
              onClick={handleCopyResult}
              className={cn(
                'py-2 px-3 rounded-lg',
                'bg-white border border-green-300 text-green-700 text-sm font-medium',
                'hover:bg-green-50 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              title="Copy to clipboard"
            >
              <Copy className="w-4 h-4" />
            </button>
            <button
              onClick={clearShortenResult}
              className={cn(
                'py-2 px-3 rounded-lg',
                'bg-white border border-green-300 text-green-700 text-sm font-medium',
                'hover:bg-green-50 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              title="Clear result"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>
      )}
    </div>
  );
}


=== FILE: components/workspace/Sidebar.tsx ===

/**
 * @file components/workspace/Sidebar.tsx
 * @description Reusable collapsible sidebar component for workspace
 * 
 * Features:
 * - Smooth slide animation (300ms)
 * - Collapse/expand button
 * - Works for both left and right sidebars
 * - Responsive design
 * - Apple-style aesthetic
 * 
 * @example
 * ```tsx
 * <Sidebar
 *   side="left"
 *   isOpen={leftSidebarOpen}
 *   onToggle={toggleLeftSidebar}
 * >
 *   <div>Sidebar content</div>
 * </Sidebar>
 * ```
 */

'use client';

import React from 'react';
import { ChevronLeft, ChevronRight } from 'lucide-react';
import { cn } from '@/lib/utils';

interface SidebarProps {
  /** Which side of the screen this sidebar appears on */
  side: 'left' | 'right';
  
  /** Controls sidebar visibility */
  isOpen: boolean;
  
  /** Callback when toggle button is clicked */
  onToggle: () => void;
  
  /** Sidebar content */
  children: React.ReactNode;
  
  /** Optional CSS classes */
  className?: string;
  
  /** Optional width override (default: 280px for left, 320px for right) */
  width?: number;
}

/**
 * Collapsible sidebar component with smooth animations
 */
export function Sidebar({
  side,
  isOpen,
  onToggle,
  children,
  className,
  width,
}: SidebarProps) {
  const defaultWidth = side === 'left' ? 300 : 320;
  const sidebarWidth = width || defaultWidth;

  return (
    <div className="relative h-full">
      {/* Toggle button - always visible outside sidebar */}
      <button
        onClick={onToggle}
        className={cn(
          'absolute top-4 z-20',
          'w-6 h-6 rounded-full',
          'bg-white border border-apple-gray-light',
          'flex items-center justify-center',
          'hover:bg-apple-gray-bg hover:border-apple-gray',
          'transition-all duration-200',
          'shadow-sm hover:shadow',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          side === 'left' 
            ? (isOpen ? 'left-[297px]' : 'left-0')
            : (isOpen ? 'right-[317px]' : 'right-0')
        )}
        aria-label={`${isOpen ? 'Collapse' : 'Expand'} ${side} sidebar`}
        title={`${isOpen ? 'Collapse' : 'Expand'} ${side} sidebar`}
        data-print-hide
      >
        {side === 'left' ? (
          isOpen ? (
            <ChevronLeft className="w-4 h-4 text-apple-text-dark" />
          ) : (
            <ChevronRight className="w-4 h-4 text-apple-text-dark" />
          )
        ) : isOpen ? (
          <ChevronRight className="w-4 h-4 text-apple-text-dark" />
        ) : (
          <ChevronLeft className="w-4 h-4 text-apple-text-dark" />
        )}
      </button>

      {/* Sidebar */}
      <aside
        className={cn(
          'relative h-full bg-white border-apple-gray-light',
          'transition-all duration-300 ease-in-out',
          'shadow-sm',
          side === 'left' ? 'border-r' : 'border-l',
          className
        )}
        style={{
          width: isOpen ? `${sidebarWidth}px` : '0px',
          minWidth: isOpen ? `${sidebarWidth}px` : '0px',
          maxWidth: isOpen ? `${sidebarWidth}px` : '0px',
        }}
        aria-label={`${side} sidebar`}
        aria-expanded={isOpen}
        data-sidebar={side}
        data-tour={side === 'right' ? 'toolbox' : undefined}
        data-print-hide
      >
        {/* Sidebar content with overflow handling */}
        <div
          className={cn(
            'h-full overflow-hidden',
            'transition-opacity duration-300',
            isOpen ? 'opacity-100' : 'opacity-0'
          )}
        >
          {/* py-6 px-2 - minimal breathing room from edges */}
          <div className="h-full overflow-y-auto custom-scrollbar py-6 px-2">
            {children}
          </div>
        </div>
      </aside>
    </div>
  );
}





=== FILE: components/workspace/SnippetModals.tsx ===

/**
 * @file components/workspace/SnippetModals.tsx
 * @description Modal components for creating and editing snippets
 * 
 * Components:
 * - AddSnippetModal: Modal for creating new snippets
 * - EditSnippetModal: Modal for editing existing snippets
 * - SaveAsSnippetModal: Modal for saving selected text as a new snippet
 */

'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { X, Scissors, Plus, AlertCircle, Loader2 } from 'lucide-react';
import { createPortal } from 'react-dom';
import { cn } from '@/lib/utils';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import type { Snippet, CreateSnippetInput } from '@/lib/types/snippet';
import {
  useSnippetStore,
  useAddSnippetModalOpen,
  useEditSnippetModal,
  useSaveAsSnippetModal,
  useSnippetActions,
  useSnippetError,
  useSnippetLoading,
} from '@/lib/stores/snippetStore';

// ============================================================================
// Types
// ============================================================================

interface ModalBaseProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  children: React.ReactNode;
}

interface SnippetFormProps {
  initialName?: string;
  initialContent?: string;
  initialDescription?: string;
  onSubmit: (input: CreateSnippetInput) => void;
  submitLabel: string;
  isLoading?: boolean;
  error?: string | null;
}

// ============================================================================
// Modal Base Component
// ============================================================================

function ModalBase({ isOpen, onClose, title, children }: ModalBaseProps) {
  const [isMounted, setIsMounted] = useState(false);
  
  // Handle mount state for SSR
  useEffect(() => {
    setIsMounted(true);
  }, []);
  
  // Handle ESC key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape' && isOpen) {
        onClose();
      }
    };
    
    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [isOpen, onClose]);
  
  // Prevent body scroll
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
      return () => {
        document.body.style.overflow = '';
      };
    }
  }, [isOpen]);
  
  if (!isMounted || !isOpen) return null;
  
  return createPortal(
    <div
      className="fixed inset-0 z-50 flex items-center justify-center"
      onClick={onClose}
    >
      {/* Backdrop */}
      <div className="absolute inset-0 bg-black/50 transition-opacity" />
      
      {/* Modal */}
      <div
        className={cn(
          'relative bg-white rounded-xl shadow-2xl',
          'w-full max-w-lg mx-4',
          'transform transition-all duration-200',
          'animate-in fade-in-0 zoom-in-95'
        )}
        onClick={(e) => e.stopPropagation()}
      >
        {/* Header */}
        <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200">
          <div className="flex items-center gap-3">
            <div className="p-2 bg-purple-100 rounded-lg">
              <Scissors className="h-5 w-5 text-purple-600" />
            </div>
            <h2 className="text-lg font-semibold text-gray-900">{title}</h2>
          </div>
          <button
            onClick={onClose}
            className={cn(
              'p-2 rounded-lg text-gray-400',
              'hover:text-gray-600 hover:bg-gray-100',
              'transition-colors'
            )}
          >
            <X className="h-5 w-5" />
          </button>
        </div>
        
        {/* Content */}
        <div className="px-6 py-5">
          {children}
        </div>
      </div>
    </div>,
    document.body
  );
}

// ============================================================================
// Snippet Form Component
// ============================================================================

function SnippetForm({
  initialName = '',
  initialContent = '',
  initialDescription = '',
  onSubmit,
  submitLabel,
  isLoading = false,
  error = null,
}: SnippetFormProps) {
  const [name, setName] = useState(initialName);
  const [content, setContent] = useState(initialContent);
  const [description, setDescription] = useState(initialDescription);
  const [validationError, setValidationError] = useState<string | null>(null);
  
  // Reset form when initial values change
  useEffect(() => {
    setName(initialName);
    setContent(initialContent);
    setDescription(initialDescription);
  }, [initialName, initialContent, initialDescription]);
  
  // Handle form submission
  const handleSubmit = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate
    if (!name.trim()) {
      setValidationError('Snippet name is required');
      return;
    }
    
    if (!content.trim()) {
      setValidationError('Snippet content is required');
      return;
    }
    
    setValidationError(null);
    
    onSubmit({
      name: name.trim(),
      content: content.trim(),
      description: description.trim() || undefined,
    });
  }, [name, content, description, onSubmit]);
  
  const displayError = validationError || error;

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      {/* Error display */}
      {displayError && (
        <div className="flex items-center gap-2 p-3 bg-red-50 border border-red-200 rounded-lg text-red-600 text-sm">
          <AlertCircle className="h-4 w-4 flex-shrink-0" />
          <span>{displayError}</span>
        </div>
      )}
      
      {/* Name field */}
      <div>
        <label htmlFor="snippet-name" className="block text-sm font-medium text-gray-700 mb-1.5">
          Snippet Name <span className="text-red-500">*</span>
        </label>
        <Input
          id="snippet-name"
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="e.g., Hero CTA, Email Sign-off"
          className="w-full"
          autoFocus
          maxLength={100}
        />
        <p className="mt-1 text-xs text-gray-400">
          A short, memorable name for this snippet
        </p>
      </div>
      
      {/* Content field */}
      <div>
        <label htmlFor="snippet-content" className="block text-sm font-medium text-gray-700 mb-1.5">
          Content <span className="text-red-500">*</span>
        </label>
        <textarea
          id="snippet-content"
          value={content}
          onChange={(e) => setContent(e.target.value)}
          placeholder="Enter the reusable copy text..."
          className={cn(
            'w-full min-h-[120px] px-3 py-2 text-sm',
            'border border-gray-300 rounded-lg',
            'focus:outline-none focus:ring-2 focus:ring-purple-500 focus:border-transparent',
            'placeholder:text-gray-400 resize-y'
          )}
          maxLength={50000}
        />
        <p className="mt-1 text-xs text-gray-400">
          The actual copy text that will be inserted
        </p>
      </div>
      
      {/* Description field (optional) */}
      <div>
        <label htmlFor="snippet-description" className="block text-sm font-medium text-gray-700 mb-1.5">
          Description <span className="text-gray-400">(optional)</span>
        </label>
        <Input
          id="snippet-description"
          type="text"
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          placeholder="When to use this snippet..."
          className="w-full"
          maxLength={200}
        />
      </div>
      
      {/* Submit button */}
      <div className="flex justify-end gap-3 pt-2">
        <Button
          type="submit"
          disabled={isLoading}
          className="bg-purple-600 hover:bg-purple-700 text-white"
        >
          {isLoading ? (
            <>
              <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              Saving...
            </>
          ) : (
            <>
              <Plus className="h-4 w-4 mr-2" />
              {submitLabel}
            </>
          )}
        </Button>
      </div>
    </form>
  );
}

// ============================================================================
// Add Snippet Modal
// ============================================================================

export function AddSnippetModal() {
  const isOpen = useAddSnippetModalOpen();
  const isLoading = useSnippetLoading();
  const error = useSnippetError();
  const { createSnippet, closeAddModal, clearError } = useSnippetActions();
  
  // Handle close
  const handleClose = useCallback(() => {
    clearError();
    closeAddModal();
  }, [clearError, closeAddModal]);
  
  // Handle submit
  const handleSubmit = useCallback(async (input: CreateSnippetInput) => {
    await createSnippet(input);
  }, [createSnippet]);
  
  return (
    <ModalBase
      isOpen={isOpen}
      onClose={handleClose}
      title="Add New Snippet"
    >
      <SnippetForm
        onSubmit={handleSubmit}
        submitLabel="Add Snippet"
        isLoading={isLoading}
        error={error}
      />
    </ModalBase>
  );
}

// ============================================================================
// Edit Snippet Modal
// ============================================================================

export function EditSnippetModal() {
  const { isOpen, snippet } = useEditSnippetModal();
  const isLoading = useSnippetLoading();
  const error = useSnippetError();
  const { updateSnippet, closeEditModal, clearError } = useSnippetActions();
  
  // Handle close
  const handleClose = useCallback(() => {
    clearError();
    closeEditModal();
  }, [clearError, closeEditModal]);
  
  // Handle submit
  const handleSubmit = useCallback(async (input: CreateSnippetInput) => {
    if (!snippet) return;
    
    await updateSnippet(snippet.id, {
      name: input.name,
      content: input.content,
      description: input.description,
    });
  }, [snippet, updateSnippet]);
  
  if (!snippet) return null;
  
  return (
    <ModalBase
      isOpen={isOpen}
      onClose={handleClose}
      title="Edit Snippet"
    >
      <SnippetForm
        initialName={snippet.name}
        initialContent={snippet.content}
        initialDescription={snippet.description || ''}
        onSubmit={handleSubmit}
        submitLabel="Save Changes"
        isLoading={isLoading}
        error={error}
      />
    </ModalBase>
  );
}

// ============================================================================
// Save As Snippet Modal
// ============================================================================

export function SaveAsSnippetModal() {
  const { isOpen, selectedText } = useSaveAsSnippetModal();
  const isLoading = useSnippetLoading();
  const error = useSnippetError();
  const { createSnippet, closeSaveAsSnippet, clearError } = useSnippetActions();
  
  // Handle close
  const handleClose = useCallback(() => {
    clearError();
    closeSaveAsSnippet();
  }, [clearError, closeSaveAsSnippet]);
  
  // Handle submit
  const handleSubmit = useCallback(async (input: CreateSnippetInput) => {
    await createSnippet(input);
  }, [createSnippet]);
  
  return (
    <ModalBase
      isOpen={isOpen}
      onClose={handleClose}
      title="Save as Snippet"
    >
      <div className="mb-4 p-3 bg-gray-50 rounded-lg border border-gray-200">
        <p className="text-xs text-gray-500 mb-1">Selected text:</p>
        <p className="text-sm text-gray-700 max-h-20 overflow-y-auto">
          {selectedText ? (
            selectedText.length > 200 
              ? selectedText.substring(0, 200) + '...' 
              : selectedText
          ) : (
            <span className="text-gray-400 italic">No text selected</span>
          )}
        </p>
      </div>
      
      <SnippetForm
        initialContent={selectedText}
        onSubmit={handleSubmit}
        submitLabel="Save Snippet"
        isLoading={isLoading}
        error={error}
      />
    </ModalBase>
  );
}

// ============================================================================
// Combined Export for Convenience
// ============================================================================

export function SnippetModals() {
  return (
    <>
      <AddSnippetModal />
      <EditSnippetModal />
      <SaveAsSnippetModal />
    </>
  );
}

export default SnippetModals;


=== FILE: components/workspace/SnippetSection.tsx ===

/**
 * @file components/workspace/SnippetSection.tsx
 * @description Snippet list section for the My Projects slide-out
 * 
 * Features:
 * - Displays snippets for a project
 * - Click to insert snippet at cursor position
 * - Add new snippet button
 * - Edit/delete options on hover
 * - Search filter integration
 * - Collapsible section
 */

'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { logger } from '@/lib/utils/logger';
import {
  Scissors,
  Plus,
  ChevronRight,
  ChevronDown,
  Pencil,
  Trash2,
  Copy,
  Check,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import type { Snippet } from '@/lib/types/snippet';
import { getAllSnippets, deleteSnippet } from '@/lib/storage/snippet-storage';
import { useSnippetStore } from '@/lib/stores/snippetStore';

// ============================================================================
// Types
// ============================================================================

interface SnippetSectionProps {
  /** Project ID to load snippets for */
  projectId: string;
  /** Whether this project section is expanded */
  isExpanded: boolean;
  /** Search query for filtering */
  searchQuery?: string;
  /** Callback when a snippet is clicked (for insertion) */
  onSnippetClick?: (snippet: Snippet) => void;
  /** Callback to open add snippet modal - receives projectId */
  onAddSnippet?: (projectId: string) => void;
  /** Callback to open edit snippet modal */
  onEditSnippet?: (snippet: Snippet) => void;
}

interface SnippetRowProps {
  snippet: Snippet;
  onSelect: (snippet: Snippet) => void;
  onEdit: (snippet: Snippet) => void;
  onDelete: (snippet: Snippet) => void;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Truncate text with ellipsis
 */
function truncateText(text: string, maxLength: number): string {
  if (text.length <= maxLength) return text;
  return text.substring(0, maxLength).trim() + '...';
}

/**
 * Strip HTML tags from content for preview
 */
function stripHtml(html: string): string {
  return html.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
}

/**
 * Format relative date
 */
function formatRelativeDate(dateString: string): string {
  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffDays = Math.floor(diffMs / 86400000);

  if (diffDays < 1) return 'Today';
  if (diffDays === 1) return 'Yesterday';
  if (diffDays < 7) return `${diffDays}d ago`;
  
  return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
}

// ============================================================================
// SnippetRow Component
// ============================================================================

function SnippetRow({ snippet, onSelect, onEdit, onDelete }: SnippetRowProps) {
  const [copied, setCopied] = useState(false);
  
  // Handle copy to clipboard
  const handleCopy = useCallback(async (e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      const plainText = stripHtml(snippet.content);
      await navigator.clipboard.writeText(plainText);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    } catch (error) {
      logger.error('Failed to copy:', error);
    }
  }, [snippet.content]);
  
  // Handle delete with confirmation
  const handleDelete = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    if (window.confirm(`Delete snippet "${snippet.name}"? This cannot be undone.`)) {
      onDelete(snippet);
    }
  }, [snippet, onDelete]);
  
  // Handle edit
  const handleEdit = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onEdit(snippet);
  }, [snippet, onEdit]);
  
  // Get preview text
  const previewText = truncateText(stripHtml(snippet.content), 60);

  return (
    <div
      className={cn(
        'group flex items-start gap-3 px-3 py-2.5 rounded-lg cursor-pointer',
        'transition-colors duration-150',
        'hover:bg-purple-50 border border-transparent hover:border-purple-200'
      )}
      onClick={() => onSelect(snippet)}
      title={`Click to insert "${snippet.name}" at cursor position`}
    >
      <Scissors className="h-4 w-4 text-purple-500 flex-shrink-0 mt-0.5" />
      
      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2">
          <span className="text-sm font-medium text-gray-900 truncate">
            {snippet.name}
          </span>
          {snippet.usageCount > 0 && (
            <span className="text-xs text-gray-400 bg-gray-100 px-1.5 py-0.5 rounded">
              {snippet.usageCount}√ó
            </span>
          )}
        </div>
        <p className="text-xs text-gray-500 truncate mt-0.5">
          {previewText}
        </p>
        {snippet.description && (
          <p className="text-xs text-gray-400 italic truncate mt-0.5">
            {truncateText(snippet.description, 40)}
          </p>
        )}
      </div>
      
      {/* Actions - visible on hover */}
      <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0">
        <button
          onClick={handleCopy}
          className={cn(
            'p-1.5 rounded transition-colors',
            copied ? 'bg-green-100 text-green-600' : 'hover:bg-gray-200 text-gray-500'
          )}
          title="Copy to clipboard"
        >
          {copied ? <Check className="h-3.5 w-3.5" /> : <Copy className="h-3.5 w-3.5" />}
        </button>
        <button
          onClick={handleEdit}
          className="p-1.5 rounded hover:bg-gray-200 transition-colors"
          title="Edit snippet"
        >
          <Pencil className="h-3.5 w-3.5 text-gray-500" />
        </button>
        <button
          onClick={handleDelete}
          className="p-1.5 rounded hover:bg-red-100 transition-colors"
          title="Delete snippet"
        >
          <Trash2 className="h-3.5 w-3.5 text-red-500" />
        </button>
      </div>
    </div>
  );
}

// ============================================================================
// SnippetSection Component
// ============================================================================

export function SnippetSection({
  projectId,
  isExpanded,
  searchQuery = '',
  onSnippetClick,
  onAddSnippet,
  onEditSnippet,
}: SnippetSectionProps) {
  const [snippets, setSnippets] = useState<Snippet[]>([]);
  const [sectionExpanded, setSectionExpanded] = useState(true);
  const [refreshTrigger, setRefreshTrigger] = useState(0);
  
  // Get store state and actions
  const insertSnippet = useSnippetStore((state) => state.insertSnippet);
  const storeSnippets = useSnippetStore((state) => state.snippets);
  const currentProjectId = useSnippetStore((state) => state.currentProjectId);
  
  // Load snippets when project section is expanded or store updates
  useEffect(() => {
    if (isExpanded && projectId) {
      const projectSnippets = getAllSnippets(projectId);
      setSnippets(projectSnippets);
    }
  }, [isExpanded, projectId, refreshTrigger]);
  
  // Sync with store when it updates for this project
  useEffect(() => {
    if (currentProjectId === projectId && storeSnippets.length >= 0) {
      // Store was updated for this project, refresh from localStorage
      const projectSnippets = getAllSnippets(projectId);
      setSnippets(projectSnippets);
    }
  }, [storeSnippets, currentProjectId, projectId]);
  
  // Filter snippets by search query
  const filteredSnippets = React.useMemo(() => {
    if (!searchQuery.trim()) return snippets;
    
    const query = searchQuery.toLowerCase();
    return snippets.filter(snippet =>
      snippet.name.toLowerCase().includes(query) ||
      snippet.content.toLowerCase().includes(query) ||
      snippet.description?.toLowerCase().includes(query)
    );
  }, [snippets, searchQuery]);
  
  // Handle snippet selection (insert into editor)
  const handleSnippetSelect = useCallback((snippet: Snippet) => {
    if (onSnippetClick) {
      onSnippetClick(snippet);
    } else {
      // Use store's insertSnippet method
      insertSnippet(snippet);
    }
  }, [onSnippetClick, insertSnippet]);
  
  // Handle snippet edit
  const handleEditSnippet = useCallback((snippet: Snippet) => {
    if (onEditSnippet) {
      onEditSnippet(snippet);
    }
  }, [onEditSnippet]);
  
  // Handle snippet delete
  const handleDeleteSnippet = useCallback((snippet: Snippet) => {
    try {
      deleteSnippet(projectId, snippet.id);
      // Trigger refresh
      setRefreshTrigger(prev => prev + 1);
    } catch (error) {
      logger.error('Failed to delete snippet:', error);
      window.alert(error instanceof Error ? error.message : 'Failed to delete snippet');
    }
  }, [projectId]);
  
  // Don't render if project section is collapsed
  if (!isExpanded) {
    return null;
  }
  
  // Toggle section expanded state
  const toggleSection = () => {
    setSectionExpanded(prev => !prev);
  };
  
  return (
    <div className="mt-2 ml-2 pl-2 border-l-2 border-purple-200">
      {/* Section header */}
      <div
        className={cn(
          'flex items-center gap-2 px-3 py-2 rounded-lg cursor-pointer',
          'hover:bg-purple-50 transition-colors duration-150'
        )}
        onClick={toggleSection}
      >
        {sectionExpanded ? (
          <ChevronDown className="h-4 w-4 text-purple-400 flex-shrink-0" />
        ) : (
          <ChevronRight className="h-4 w-4 text-purple-400 flex-shrink-0" />
        )}
        
        <Scissors className="h-4 w-4 text-purple-500 flex-shrink-0" />
        
        <span className="flex-1 text-sm font-semibold text-purple-900">
          Snippets
        </span>
        
        <span className="text-xs text-purple-500 px-2 py-0.5 bg-purple-100 rounded-full">
          {snippets.length}
        </span>
        
        {/* Add button */}
        <button
          onClick={(e) => {
            e.stopPropagation();
            onAddSnippet?.(projectId);
          }}
          className={cn(
            'p-1.5 rounded transition-colors',
            'hover:bg-purple-200 text-purple-600',
            'opacity-0 group-hover:opacity-100'
          )}
          title="Add new snippet"
          style={{ opacity: 1 }} // Always show for now
        >
          <Plus className="h-3.5 w-3.5" />
        </button>
      </div>
      
      {/* Snippet list */}
      {sectionExpanded && (
        <div className="mt-1 space-y-1">
          {filteredSnippets.length > 0 ? (
            filteredSnippets.map(snippet => (
              <SnippetRow
                key={snippet.id}
                snippet={snippet}
                onSelect={handleSnippetSelect}
                onEdit={handleEditSnippet}
                onDelete={handleDeleteSnippet}
              />
            ))
          ) : snippets.length === 0 ? (
            <div className="text-center py-4">
              <p className="text-xs text-gray-400">
                No snippets yet
              </p>
              <button
                onClick={() => onAddSnippet?.(projectId)}
                className="mt-2 text-xs text-purple-600 hover:text-purple-700 font-medium"
              >
                + Add your first snippet
              </button>
            </div>
          ) : (
            <div className="text-xs text-gray-400 italic py-2 px-3">
              No snippets match &quot;{searchQuery}&quot;
            </div>
          )}
        </div>
      )}
    </div>
  );
}

export default SnippetSection;


=== FILE: components/workspace/TemplateFormField.tsx ===

/**
 * @file components/workspace/TemplateFormField.tsx
 * @description Reusable form field component for template forms
 * 
 * Renders different field types (text, textarea, select, number) based on
 * the field definition. Handles validation, character counts, errors,
 * and "Other (specify)" custom input for select fields.
 */

'use client';

import React from 'react';
import { cn } from '@/lib/utils';
import { AutoExpandTextarea } from '@/components/ui/AutoExpandTextarea';
import type { TemplateField } from '@/lib/types/template';

/** Special value for "Other" option in select fields */
export const OTHER_OPTION_VALUE = 'Other (specify)';

/** Maximum character length for custom "Other" input */
const OTHER_INPUT_MAX_LENGTH = 100;

interface TemplateFormFieldProps {
  /** Field definition from template */
  field: TemplateField;
  
  /** Current field value */
  value: string;
  
  /** Change handler */
  onChange: (value: string) => void;
  
  /** Custom "Other" value when "Other (specify)" is selected */
  otherValue?: string;
  
  /** Change handler for custom "Other" value */
  onOtherChange?: (value: string) => void;
  
  /** Error message if validation failed */
  error?: string;
  
  /** Error message for custom "Other" input */
  otherError?: string;
  
  /** Whether field is disabled */
  disabled?: boolean;
}

/**
 * Get placeholder text for "Other" custom input based on field label
 */
function getOtherPlaceholder(label: string): string {
  const labelLower = label.toLowerCase();
  
  if (labelLower.includes('tone')) {
    return 'e.g., Authoritative yet approachable';
  }
  if (labelLower.includes('benefit')) {
    return 'e.g., Build Community';
  }
  if (labelLower.includes('call-to-action') || labelLower.includes('cta')) {
    return 'e.g., Join the Waitlist';
  }
  if (labelLower.includes('platform')) {
    return 'e.g., Threads, Mastodon';
  }
  if (labelLower.includes('trigger')) {
    return 'e.g., Nostalgia, Belonging';
  }
  if (labelLower.includes('hook')) {
    return 'e.g., Metaphor, Challenge';
  }
  if (labelLower.includes('post type')) {
    return 'e.g., Carousel, Thread';
  }
  if (labelLower.includes('headline')) {
    return 'e.g., Testimonial-Based';
  }
  if (labelLower.includes('publication')) {
    return 'e.g., Industry Newsletter';
  }
  if (labelLower.includes('campaign')) {
    return 'e.g., Post-webinar nurture sequence';
  }
  if (labelLower.includes('email goal')) {
    return 'e.g., Re-engage dormant subscribers';
  }
  if (labelLower.includes('goal')) {
    return 'e.g., Event Promotion';
  }
  if (labelLower.includes('urgency')) {
    return 'e.g., End of quarter deadline';
  }
  
  return 'Specify your custom option';
}

/**
 * TemplateFormField Component
 * Renders a single form field based on its type
 * 
 * Supports "Other (specify)" option in select fields, showing a
 * custom text input when selected.
 * 
 * Performance: Memoized to prevent re-renders when props haven't changed
 */
export const TemplateFormField = React.memo(function TemplateFormField({
  field,
  value,
  onChange,
  otherValue = '',
  onOtherChange,
  error,
  otherError,
  disabled = false,
}: TemplateFormFieldProps) {
  const { id, label, type, placeholder, helperText, required, maxLength, options } = field;
  
  // Calculate remaining characters for main field
  const remainingChars = maxLength ? maxLength - value.length : null;
  const isNearLimit = remainingChars !== null && remainingChars < 50;
  const isOverLimit = remainingChars !== null && remainingChars < 0;
  
  // Check if "Other" is selected (for select fields)
  const isOtherSelected = type === 'select' && value === OTHER_OPTION_VALUE;
  
  // Check if this field has "Other" option
  const hasOtherOption = type === 'select' && options?.includes(OTHER_OPTION_VALUE);
  
  // Calculate remaining characters for "Other" input
  const otherRemainingChars = OTHER_INPUT_MAX_LENGTH - otherValue.length;
  const isOtherNearLimit = otherRemainingChars < 20;
  const isOtherOverLimit = otherRemainingChars < 0;
  
  /**
   * Render input based on field type
   */
  const renderInput = () => {
    const baseInputClasses = cn(
      'w-full px-3 py-2 rounded-lg',
      'border transition-all duration-200',
      'text-sm text-apple-text-dark',
      'placeholder:text-apple-text-light',
      'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
      'disabled:bg-gray-50 disabled:cursor-not-allowed disabled:opacity-50',
      error
        ? 'border-red-300 bg-red-50'
        : 'border-apple-gray-light bg-white hover:border-apple-gray'
    );
    
    switch (type) {
      case 'textarea':
        return (
          <AutoExpandTextarea
            id={id}
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder={placeholder}
            disabled={disabled}
            maxLength={maxLength}
            minHeight={100}
            maxHeight={400}
            className={baseInputClasses}
            aria-invalid={!!error}
            aria-describedby={error ? `${id}-error` : helperText ? `${id}-helper` : undefined}
          />
        );
      
      case 'select':
        return (
          <>
            <select
              id={id}
              value={value}
              onChange={(e) => onChange(e.target.value)}
              disabled={disabled}
              className={baseInputClasses}
              aria-invalid={!!error}
              aria-describedby={error ? `${id}-error` : helperText ? `${id}-helper` : undefined}
            >
              <option value="">Select an option...</option>
              {options?.map((option) => (
                <option key={option} value={option}>
                  {option}
                </option>
              ))}
            </select>
            
            {/* Custom "Other" input - shown when "Other (specify)" is selected */}
            {isOtherSelected && hasOtherOption && (
              <div className="mt-3 animate-in slide-in-from-top-2 duration-200">
                <div className="flex items-baseline justify-between mb-1.5">
                  <label
                    htmlFor={`${id}-other`}
                    className="text-xs font-medium text-apple-text-dark"
                  >
                    Specify your custom option
                    {required && <span className="text-red-500 ml-1">*</span>}
                  </label>
                  <span
                    className={cn(
                      'text-xs tabular-nums transition-colors',
                      isOtherOverLimit
                        ? 'text-red-600 font-medium'
                        : isOtherNearLimit
                        ? 'text-orange-600'
                        : 'text-apple-text-light'
                    )}
                  >
                    {otherValue.length}/{OTHER_INPUT_MAX_LENGTH}
                  </span>
                </div>
                <input
                  id={`${id}-other`}
                  type="text"
                  value={otherValue}
                  onChange={(e) => onOtherChange?.(e.target.value)}
                  placeholder={getOtherPlaceholder(label)}
                  disabled={disabled}
                  maxLength={OTHER_INPUT_MAX_LENGTH}
                  className={cn(
                    'w-full px-3 py-2 rounded-lg',
                    'border transition-all duration-200',
                    'text-sm text-apple-text-dark',
                    'placeholder:text-apple-text-light',
                    'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
                    'disabled:bg-gray-50 disabled:cursor-not-allowed disabled:opacity-50',
                    otherError
                      ? 'border-red-300 bg-red-50'
                      : 'border-blue-200 bg-blue-50/30 hover:border-blue-300'
                  )}
                  aria-invalid={!!otherError}
                  aria-describedby={otherError ? `${id}-other-error` : undefined}
                />
                {otherError && (
                  <p
                    id={`${id}-other-error`}
                    className="text-xs text-red-600 mt-1.5 flex items-center gap-1"
                    role="alert"
                  >
                    <span className="font-medium">Error:</span>
                    {otherError}
                  </p>
                )}
              </div>
            )}
          </>
        );
      
      case 'number':
        return (
          <input
            id={id}
            type="number"
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder={placeholder}
            disabled={disabled}
            className={baseInputClasses}
            aria-invalid={!!error}
            aria-describedby={error ? `${id}-error` : helperText ? `${id}-helper` : undefined}
          />
        );
      
      case 'text':
      default:
        return (
          <input
            id={id}
            type="text"
            value={value}
            onChange={(e) => onChange(e.target.value)}
            placeholder={placeholder}
            disabled={disabled}
            maxLength={maxLength}
            className={baseInputClasses}
            aria-invalid={!!error}
            aria-describedby={error ? `${id}-error` : helperText ? `${id}-helper` : undefined}
          />
        );
    }
  };
  
  return (
    <div className="flex flex-col gap-2">
      {/* Label */}
      <label
        htmlFor={id}
        className="flex items-baseline justify-between text-sm font-medium text-apple-text-dark"
      >
        <span>
          {label}
          {required && <span className="text-red-500 ml-1" aria-label="required">*</span>}
        </span>
        
        {/* Character count */}
        {maxLength && type !== 'select' && (
          <span
            className={cn(
              'text-xs font-normal tabular-nums transition-colors',
              isOverLimit
                ? 'text-red-600 font-medium'
                : isNearLimit
                ? 'text-orange-600'
                : 'text-apple-text-light'
            )}
            aria-live="polite"
          >
            {value.length}/{maxLength}
          </span>
        )}
      </label>
      
      {/* Input */}
      {renderInput()}
      
      {/* Helper text */}
      {helperText && !error && (
        <p
          id={`${id}-helper`}
          className="text-xs text-apple-text-light"
        >
          {helperText}
        </p>
      )}
      
      {/* Error message */}
      {error && (
        <p
          id={`${id}-error`}
          className="text-xs text-red-600 flex items-center gap-1"
          role="alert"
        >
          <span className="font-medium">Error:</span>
          {error}
        </p>
      )}
      
      {/* Character limit warning */}
      {isOverLimit && (
        <p className="text-xs text-red-600" role="alert">
          Character limit exceeded by {Math.abs(remainingChars!)} characters
        </p>
      )}
    </div>
  );
});


=== FILE: components/workspace/TemplateFormSlideOut.tsx ===

/**
 * @file components/workspace/TemplateFormSlideOut.tsx
 * @description Template form slide-out panel - Opens from right when template is selected
 * 
 * Features:
 * - 550px wide right slide-out panel
 * - Dynamic form fields based on selected template
 * - Brand voice integration
 * - Persona selection
 * - Form validation
 * - Generates copy and inserts into editor
 * - Can be open simultaneously with templates browser (left)
 */

'use client';

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { logger } from '@/lib/utils/logger';
import {
  Sparkles,
  Clock,
  CheckCircle,
  AlertCircle,
  X,
} from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import type { LucideIcon } from 'lucide-react';
import { SlideOutPanel } from '@/components/ui/SlideOutPanel';
import { Button } from '@/components/ui/button';
import { AIWorxButtonLoader } from '@/components/ui/AIWorxLoader';
import { TemplateFormField, OTHER_OPTION_VALUE } from './TemplateFormField';
import { cn } from '@/lib/utils';
import { formatGeneratedContent } from '@/lib/utils/content-formatting';
import { createDocument, updateDocument as updateDocumentInStorage, getProjectPersonas } from '@/lib/storage/unified-storage';
import { useWorkspaceStore } from '@/lib/stores/workspaceStore';
import { useSlideOutActions } from '@/lib/stores/slideOutStore';
import type { Template, TemplateFormData } from '@/lib/types/template';
import type { Project, Persona } from '@/lib/types/project';
import type { Editor } from '@tiptap/react';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/** Unique ID for the template form slide-out panel */
export const TEMPLATE_FORM_PANEL_ID = 'template-form';

/**
 * Get the suffix used for storing custom "Other" values
 */
const getOtherFieldId = (fieldId: string): string => `${fieldId}_other`;

/**
 * Generate a document title from template name and current timestamp
 * Format: "Template Name - Jan 21, 2026 10:30am"
 */
function generateDocumentTitle(templateName: string): string {
  const now = new Date();
  const formattedDate = now.toLocaleDateString('en-US', { 
    month: 'short', 
    day: 'numeric', 
    year: 'numeric' 
  });
  const formattedTime = now.toLocaleTimeString('en-US', { 
    hour: 'numeric', 
    minute: '2-digit',
    hour12: true 
  }).toLowerCase().replace(' ', '');
  
  return `${templateName} - ${formattedDate} ${formattedTime}`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TYPES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

interface TemplateFormSlideOutProps {
  /** Whether the slide-out is open */
  isOpen: boolean;
  
  /** Callback when slide-out should close */
  onClose: () => void;
  
  /** Selected template to generate from */
  template: Template | null;
  
  /** TipTap editor instance */
  editor: Editor | null;
  
  /** Active project for brand voice and personas */
  activeProject: Project | null;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export function TemplateFormSlideOut({
  isOpen,
  onClose,
  template,
  editor,
  activeProject,
}: TemplateFormSlideOutProps) {
  // Store actions
  const { closeSlideOut } = useSlideOutActions();
  const activeDocumentId = useWorkspaceStore((state) => state.activeDocumentId);
  
  // Form state
  const [formData, setFormData] = useState<TemplateFormData>({});
  const [errors, setErrors] = useState<{ [fieldId: string]: string }>({});
  
  // Settings state
  const [applyBrandVoice, setApplyBrandVoice] = useState(false);
  const [selectedPersonaId, setSelectedPersonaId] = useState<string | null>(null);
  
  // Generation state
  const [isGenerating, setIsGenerating] = useState(false);
  const [generationError, setGenerationError] = useState<string | null>(null);
  const [generationSuccess, setGenerationSuccess] = useState(false);
  
  // Personas state
  const [personas, setPersonas] = useState<Persona[]>([]);
  
  const hasBrandVoice = activeProject?.brandVoice?.brandName ? true : false;
  
  // Get the icon component from lucide-react
  const IconComponent = template 
    ? ((LucideIcons as unknown as Record<string, LucideIcon>)[template.icon] || Sparkles)
    : Sparkles;
  
  /**
   * Get dynamic loading message for email sequences
   * Returns null for simple templates (loader is self-explanatory)
   * Returns descriptive text only when there's meaningful context to add
   */
  const getLoadingMessage = useCallback((): string | null => {
    if (!template) return null;
    
    // Check if this is an email sequence template
    if (template.id === 'email-sequence-kickoff') {
      const numEmails = formData.numberOfEmails;
      if (numEmails) {
        // Extract number from "X emails" format
        const match = numEmails.match(/^(\d+)/);
        if (match) {
          return `Generating ${match[1]}-email sequence...`;
        }
      }
      return 'Generating email sequence...';
    }
    
    // For all other templates, just show the loader without text
    return null;
  }, [template, formData.numberOfEmails]);
  
  // Initialize form data when template changes
  useEffect(() => {
    if (!template) return;
    
    const initialData: TemplateFormData = {};
    template.fields.forEach((field) => {
      initialData[field.id] = '';
      // Also initialize the _other field for select fields that have "Other" option
      if (field.type === 'select' && field.options?.includes(OTHER_OPTION_VALUE)) {
        initialData[getOtherFieldId(field.id)] = '';
      }
    });
    setFormData(initialData);
    setErrors({});
    setGenerationError(null);
    setGenerationSuccess(false);
  }, [template]);
  
  // Load personas for current project
  useEffect(() => {
    const loadPersonas = async () => {
      if (!activeProject) {
        setPersonas([]);
        return;
      }
      
      try {
        const projectPersonas = await getProjectPersonas(activeProject.id);
        setPersonas(projectPersonas);
      } catch (error) {
        logger.error('‚ùå Failed to load personas:', error);
        setPersonas([]);
      }
    };
    
    loadPersonas();
  }, [activeProject]);
  
  /**
   * Validate form fields
   */
  const validateForm = useCallback((): boolean => {
    if (!template) return false;
    
    const newErrors: { [fieldId: string]: string } = {};
    
    template.fields.forEach((field) => {
      const value = formData[field.id] || '';
      
      // Required field check
      if (field.required && !value.trim()) {
        newErrors[field.id] = `${field.label} is required`;
        return;
      }
      
      // Check if "Other" is selected but custom value not provided
      if (
        field.type === 'select' &&
        value === OTHER_OPTION_VALUE &&
        field.options?.includes(OTHER_OPTION_VALUE)
      ) {
        const otherValue = formData[getOtherFieldId(field.id)] || '';
        if (!otherValue.trim()) {
          newErrors[getOtherFieldId(field.id)] = 'Please specify your custom option';
          return;
        }
      }
      
      // Max length check
      if (field.maxLength && value.length > field.maxLength) {
        newErrors[field.id] = `Maximum ${field.maxLength} characters allowed`;
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [template, formData]);
  
  /**
   * Handle form field change
   */
  const handleFieldChange = useCallback((fieldId: string, value: string) => {
    setFormData((prev) => ({ ...prev, [fieldId]: value }));
    // Clear error for this field
    setErrors((prev) => {
      const next = { ...prev };
      delete next[fieldId];
      return next;
    });
  }, []);
  
  /**
   * Handle template generation
   * Auto-creates a document if none is currently open
   */
  const handleGenerate = useCallback(async () => {
    // Must have template, editor, and active project
    if (!template || !editor || !activeProject) return;
    
    // Track the document ID to use (existing or newly created)
    let targetDocumentId = activeDocumentId;
    
    // Auto-create document if none is open
    if (!targetDocumentId) {
      try {
        const docTitle = generateDocumentTitle(template.name);
        const newDoc = await createDocument(activeProject.id, docTitle);
        targetDocumentId = newDoc.id;
        
        // Set as active document in store
        useWorkspaceStore.getState().setActiveDocumentId(newDoc.id);
        
        logger.log('üìÑ Auto-created document for template:', {
          title: newDoc.title,
          id: newDoc.id,
          templateName: template.name,
        });
        
        // Brief delay to allow EditorArea to react to the new activeDocumentId
        await new Promise(resolve => setTimeout(resolve, 150));
      } catch (createError) {
        logger.error('‚ùå Failed to create document:', createError);
        setGenerationError('Failed to create document. Please try again.');
        return;
      }
    }
    
    // Validate form
    if (!validateForm()) {
      setGenerationError('Please fill in all required fields');
      return;
    }
    
    // Validate brand voice if checkbox is checked
    if (applyBrandVoice && !activeProject?.brandVoice?.brandName) {
      setGenerationError('Brand Voice is enabled but not configured. Please set up your Brand Voice first or uncheck the option.');
      return;
    }
    
    setIsGenerating(true);
    setGenerationError(null);
    setGenerationSuccess(false);
    
    try {
      // Get the selected persona if one is chosen
      const selectedPersona = selectedPersonaId 
        ? personas.find((p) => p.id === selectedPersonaId) 
        : undefined;
      
      logger.log('üé® Generating template copy:', template.name);
      logger.log('üéØ Brand Voice:', applyBrandVoice ? activeProject?.brandVoice?.brandName : 'disabled');
      logger.log('üë§ Persona:', selectedPersona?.name || 'none');
      
      // Call Claude API - send brand voice and persona data for server-side prompt building
      const response = await fetch('/api/generate-template', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          templateId: template.id,
          formData,
          applyBrandVoice,
          brandVoice: applyBrandVoice ? activeProject?.brandVoice : undefined,
          persona: selectedPersona,
        }),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to generate copy');
      }
      
      const data = await response.json();
      const generatedCopy = data.generatedCopy;
      
      logger.log('‚úÖ Generated copy length:', generatedCopy.length);
      
      // Format the generated content
      const formattedContent = formatGeneratedContent(generatedCopy);
      
      // Insert into editor
      editor.commands.setContent(formattedContent);
      
      // Update document in storage
      try {
        updateDocumentInStorage(activeProject.id, targetDocumentId, {
          content: formattedContent,
        });
        logger.log('üíæ Document saved with generated content');
      } catch (storageError) {
        logger.error('‚ö†Ô∏è Failed to save document:', storageError);
        // Continue anyway - content is in editor
      }
      
      // Success!
      setGenerationSuccess(true);
      
      // Close both slide-outs after 1.5 seconds
      setTimeout(() => {
        closeSlideOut(TEMPLATE_FORM_PANEL_ID);
        // Also close templates browser if open
        closeSlideOut('templates-browser');
        
        // Clear selected template
        useWorkspaceStore.getState().setSelectedTemplateId(null);
      }, 1500);
      
    } catch (error) {
      logger.error('‚ùå Template generation error:', error);
      setGenerationError(
        error instanceof Error ? error.message : 'Failed to generate copy'
      );
    } finally {
      setIsGenerating(false);
    }
  }, [template, editor, activeDocumentId, activeProject, validateForm, formData, applyBrandVoice, selectedPersonaId, personas, closeSlideOut]);
  
  /**
   * Handle cancel
   */
  const handleCancel = useCallback(() => {
    onClose();
  }, [onClose]);
  
  // If no template, don't render
  if (!template) return null;
  
  // Panel footer with action buttons
  const panelFooter = (
    <div className="flex gap-3">
      <Button
        variant="outline"
        size="default"
        onClick={handleCancel}
        disabled={isGenerating}
        className="flex-1"
      >
        Cancel
      </Button>
      <Button
        variant={generationSuccess ? 'default' : isGenerating ? 'default' : 'brand'}
        size="default"
        onClick={handleGenerate}
        disabled={isGenerating || !editor || !activeProject || generationSuccess}
        className={cn(
          'flex-1',
          // Animated gradient when generating (override background)
          isGenerating && 'aiworx-gradient-animated',
          // Green when success
          generationSuccess && 'bg-green-500 hover:bg-green-600'
        )}
      >
        {isGenerating ? (
          <div className="flex flex-col items-center gap-1">
            <AIWorxButtonLoader />
            {getLoadingMessage() && (
              <span className="text-xs">{getLoadingMessage()}</span>
            )}
          </div>
        ) : generationSuccess ? (
          <>
            <CheckCircle className="h-4 w-4 mr-2" />
            Generated!
          </>
        ) : (
          <>
            <Sparkles className="h-4 w-4 mr-2" />
            Generate Copy
          </>
        )}
      </Button>
    </div>
  );
  
  return (
    <SlideOutPanel
      isOpen={isOpen}
      onClose={onClose}
      side="right"
      title={template.name}
      subtitle={template.description}
      footer={panelFooter}
    >
      <div className="space-y-6">
        {/* Template info */}
        <div className="flex items-center gap-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
          <div className="flex-shrink-0 w-12 h-12 rounded-lg bg-apple-blue flex items-center justify-center">
            <IconComponent className="w-6 h-6 text-white" />
          </div>
          <div className="flex-1">
            <div className="flex items-center gap-2 mb-1">
              <span className="px-2 py-0.5 text-xs font-medium rounded-full bg-blue-100 text-blue-700 border border-blue-200">
                {template.complexity}
              </span>
              <div className="flex items-center gap-1 text-xs text-blue-600">
                <Clock className="w-3 h-3" />
                <span>{template.estimatedTime}</span>
              </div>
            </div>
            <p className="text-sm text-blue-700">
              Fill out the form below to generate professional copy
            </p>
          </div>
        </div>

        {/* Generation error */}
        {generationError && (
          <div className="p-4 bg-red-50 border border-red-200 rounded-lg flex items-start gap-3">
            <AlertCircle className="w-5 h-5 text-red-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-sm font-medium text-red-900 mb-1">
                Generation Failed
              </p>
              <p className="text-sm text-red-700">{generationError}</p>
            </div>
          </div>
        )}

        {/* Generation success */}
        {generationSuccess && (
          <div className="p-4 bg-green-50 border border-green-200 rounded-lg flex items-start gap-3">
            <CheckCircle className="w-5 h-5 text-green-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-sm font-medium text-green-900 mb-1">
                Copy Generated Successfully!
              </p>
              <p className="text-sm text-green-700">
                The generated content has been inserted into your document
              </p>
            </div>
          </div>
        )}

        {/* Brand voice toggle */}
        {hasBrandVoice && (
          <div className="p-4 border border-gray-200 rounded-lg">
            <label className="flex items-start gap-3 cursor-pointer group">
              <input
                type="checkbox"
                checked={applyBrandVoice}
                onChange={(e) => setApplyBrandVoice(e.target.checked)}
                disabled={isGenerating}
                className="mt-0.5 h-4 w-4 rounded border-gray-300 text-apple-blue focus:ring-apple-blue disabled:opacity-50"
              />
              <div className="flex-1">
                <span className="text-sm font-medium text-gray-900 group-hover:text-apple-blue transition-colors">
                  Apply Brand Voice
                </span>
                <p className="text-xs text-gray-500 mt-0.5">
                  Generate copy using {activeProject?.brandVoice?.brandName}'s brand guidelines
                </p>
              </div>
            </label>
          </div>
        )}

        {/* Persona selector */}
        {personas.length > 0 && (
          <div className="space-y-2">
            <label
              htmlFor="persona-select"
              className="text-sm font-medium text-gray-900"
            >
              Target Persona (Optional)
            </label>
            <select
              id="persona-select"
              value={selectedPersonaId || ''}
              onChange={(e) => setSelectedPersonaId(e.target.value || null)}
              disabled={isGenerating}
              className={cn(
                'w-full px-3 py-2 rounded-lg border transition-all duration-200',
                'text-sm text-gray-900 bg-white',
                'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
                'disabled:bg-gray-50 disabled:opacity-50'
              )}
            >
              <option value="">No specific persona</option>
              {personas.map((persona) => (
                <option key={persona.id} value={persona.id}>
                  {persona.name}
                </option>
              ))}
            </select>
            <p className="text-xs text-gray-500">
              Tailor the copy to a specific audience persona
            </p>
          </div>
        )}

        {/* Divider */}
        <div className="border-t border-gray-200" />

        {/* Dynamic form fields */}
        <div className="space-y-4">
          {template.fields.map((field) => (
            <TemplateFormField
              key={field.id}
              field={field}
              value={formData[field.id] || ''}
              onChange={(value) => handleFieldChange(field.id, value)}
              otherValue={formData[getOtherFieldId(field.id)] || ''}
              onOtherChange={(value) => handleFieldChange(getOtherFieldId(field.id), value)}
              error={errors[field.id]}
              otherError={errors[getOtherFieldId(field.id)]}
              disabled={isGenerating || generationSuccess}
            />
          ))}
        </div>

      </div>
    </SlideOutPanel>
  );
}


=== FILE: components/workspace/TemplateGenerator.tsx ===

/**
 * @file components/workspace/TemplateGenerator.tsx
 * @description Main template generation component with dynamic form
 * 
 * Features:
 * - Renders dynamic form based on template definition
 * - Brand voice integration toggle
 * - Persona selection dropdown
 * - Form validation (including "Other" custom fields)
 * - Loading states during generation
 * - Inserts generated copy into editor
 */

'use client';

import React, { useState, useEffect, useCallback } from 'react';
import {
  Sparkles,
  Clock,
  X,
  CheckCircle,
  AlertCircle,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { useWorkspaceStore } from '@/lib/stores/workspaceStore';
import { getProjectPersonas, updateDocument as updateDocumentInStorage } from '@/lib/storage/unified-storage';
import { formatGeneratedContent } from '@/lib/utils/content-formatting';
import { AIWorxButtonLoader } from '@/components/ui/AIWorxLoader';
import { TemplateFormField, OTHER_OPTION_VALUE } from './TemplateFormField';
import type { Editor } from '@tiptap/react';
import type { Template, TemplateFormData } from '@/lib/types/template';
import type { Project, Persona } from '@/lib/types/project';
import type { LucideIcon } from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import { logger } from '@/lib/utils/logger';

interface TemplateGeneratorProps {
  /** Selected template to generate from */
  template: Template;
  
  /** TipTap editor instance */
  editor: Editor | null;
  
  /** Active project for brand voice and personas */
  activeProject: Project | null;
  
  /** Callback when user cancels */
  onCancel: () => void;
}

/**
 * Get the suffix used for storing custom "Other" values
 */
const getOtherFieldId = (fieldId: string): string => `${fieldId}_other`;

/**
 * TemplateGenerator Component
 * Dynamic form for generating copy from templates
 */
export function TemplateGenerator({
  template,
  editor,
  activeProject,
  onCancel,
}: TemplateGeneratorProps) {
  // Form state
  const [formData, setFormData] = useState<TemplateFormData>({});
  const [errors, setErrors] = useState<{ [fieldId: string]: string }>({});
  
  // Settings state
  const [applyBrandVoice, setApplyBrandVoice] = useState(false);
  const [selectedPersonaId, setSelectedPersonaId] = useState<string | null>(null);
  
  // Generation state
  const [isGenerating, setIsGenerating] = useState(false);
  const [generationError, setGenerationError] = useState<string | null>(null);
  const [generationSuccess, setGenerationSuccess] = useState(false);
  
  // Personas state
  const [personas, setPersonas] = useState<Persona[]>([]);
  
  const hasBrandVoice = activeProject?.brandVoice?.brandName ? true : false;
  
  // Get the icon component from lucide-react
  const IconComponent = (LucideIcons as unknown as Record<string, LucideIcon>)[template.icon] || Sparkles;
  
  // Initialize form data with empty strings
  useEffect(() => {
    const initialData: TemplateFormData = {};
    template.fields.forEach((field) => {
      initialData[field.id] = '';
      // Also initialize the _other field for select fields that have "Other" option
      if (field.type === 'select' && field.options?.includes(OTHER_OPTION_VALUE)) {
        initialData[getOtherFieldId(field.id)] = '';
      }
    });
    setFormData(initialData);
  }, [template]);
  
  // Load personas for current project
  useEffect(() => {
    const loadPersonas = async () => {
      if (!activeProject) {
        setPersonas([]);
        return;
      }
      
      try {
        const projectPersonas = await getProjectPersonas(activeProject.id);
        setPersonas(projectPersonas);
      } catch (error) {
        logger.error('‚ùå Failed to load personas:', error);
        setPersonas([]);
      }
    };
    
    loadPersonas();
  }, [activeProject]);
  
  /**
   * Validate form fields
   * @returns true if valid, false if errors
   */
  const validateForm = (): boolean => {
    const newErrors: { [fieldId: string]: string } = {};
    
    template.fields.forEach((field) => {
      const value = formData[field.id] || '';
      const otherValue = formData[getOtherFieldId(field.id)] || '';
      
      // Check required fields
      if (field.required && value.trim().length === 0) {
        newErrors[field.id] = 'This field is required';
      }
      
      // Check max length
      if (field.maxLength && value.length > field.maxLength) {
        newErrors[field.id] = `Exceeds maximum length of ${field.maxLength} characters`;
      }
      
      // Check select has value
      if (field.type === 'select' && field.required && !value) {
        newErrors[field.id] = 'Please select an option';
      }
      
      // Check "Other" custom value when "Other (specify)" is selected
      if (
        field.type === 'select' &&
        value === OTHER_OPTION_VALUE &&
        field.options?.includes(OTHER_OPTION_VALUE)
      ) {
        if (field.required && otherValue.trim().length === 0) {
          newErrors[getOtherFieldId(field.id)] = 'Please specify your custom option';
        }
        if (otherValue.length > 100) {
          newErrors[getOtherFieldId(field.id)] = 'Custom option must be 100 characters or less';
        }
      }
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  /**
   * Resolve form data, replacing "Other (specify)" with actual custom values
   * This is what gets sent to the AI
   */
  const resolveFormData = (): TemplateFormData => {
    const resolved: TemplateFormData = {};
    
    template.fields.forEach((field) => {
      const value = formData[field.id] || '';
      const otherValue = formData[getOtherFieldId(field.id)] || '';
      
      // If "Other (specify)" is selected, use the custom value instead
      if (
        field.type === 'select' &&
        value === OTHER_OPTION_VALUE &&
        otherValue.trim().length > 0
      ) {
        resolved[field.id] = otherValue.trim();
      } else {
        resolved[field.id] = value;
      }
    });
    
    return resolved;
  };
  
  /**
   * Handle field change
   * Performance: Memoized to prevent re-creating on every render
   */
  const handleFieldChange = useCallback((fieldId: string, value: string): void => {
    setFormData((prev) => ({
      ...prev,
      [fieldId]: value,
    }));
    
    // Clear error for this field when typing
    setErrors((prev) => {
      if (!prev[fieldId]) return prev;
      const newErrors = { ...prev };
      delete newErrors[fieldId];
      return newErrors;
    });
  }, []);
  
  /**
   * Handle "Other" custom value change
   */
  const handleOtherChange = useCallback((fieldId: string, value: string): void => {
    const otherFieldId = getOtherFieldId(fieldId);
    setFormData((prev) => ({
      ...prev,
      [otherFieldId]: value,
    }));
    
    // Clear error for this "Other" field when typing
    setErrors((prev) => {
      if (!prev[otherFieldId]) return prev;
      const newErrors = { ...prev };
      delete newErrors[otherFieldId];
      return newErrors;
    });
  }, []);
  
  /**
   * Handle form submission
   */
  const handleGenerate = async () => {
    // Validate form
    if (!validateForm()) {
      logger.warn('‚ö†Ô∏è Form validation failed');
      return;
    }
    
    // Check editor is available
    if (!editor) {
      setGenerationError('Editor not available. Please try again.');
      return;
    }
    
    // Set loading state
    setIsGenerating(true);
    setGenerationError(null);
    setGenerationSuccess(false);
    
    try {
      // Get selected persona if any
      const selectedPersona = selectedPersonaId
        ? personas.find((p) => p.id === selectedPersonaId)
        : null;
      
      // Resolve form data (replace "Other" with custom values)
      const resolvedFormData = resolveFormData();
      
      // Build request body
      const requestBody = {
        templateId: template.id,
        formData: resolvedFormData,
        applyBrandVoice: applyBrandVoice && hasBrandVoice,
        brandVoice: applyBrandVoice && activeProject?.brandVoice ? activeProject.brandVoice : undefined,
        personaId: selectedPersonaId || undefined,
        persona: selectedPersona || undefined,
      };
      
      logger.log('üöÄ Generating template:', {
        templateId: template.id,
        applyBrandVoice,
        personaId: selectedPersonaId,
        resolvedFormData,
      });
      
      // Call API
      const response = await fetch('/api/generate-template', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody),
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({
          error: 'API request failed',
          details: `Status: ${response.status}`,
        }));
        
        throw new Error(errorData.details || errorData.error || 'Failed to generate copy');
      }
      
      // Parse response
      const data = await response.json();
      
      if (!data.generatedCopy) {
        throw new Error('No generated copy received from API');
      }
      
      // Check if editor has content - prompt for confirmation
      const currentContent = editor.getText().trim();
      if (currentContent.length > 0) {
        const confirmed = window.confirm(
          'The editor has existing content. Replace it with the generated copy?'
        );
        
        if (!confirmed) {
          setIsGenerating(false);
          return;
        }
      }
      
      // Format HTML content from Claude (use email processor for email templates)
      const isEmailTemplate = template.id.includes('email') || template.category === 'email';
      const formattedContent = formatGeneratedContent(data.generatedCopy, isEmailTemplate);
      
      logger.log('üìù Formatted content for editor:', {
        templateType: isEmailTemplate ? 'email' : 'regular',
        originalLength: data.generatedCopy.length,
        formattedLength: formattedContent.length,
      });
      
      // Insert formatted copy into editor
      editor
        .chain()
        .focus()
        .clearContent()
        .insertContent(formattedContent)
        .run();
      
      // Save to localStorage directly
      const { activeProjectId, activeDocumentId } = useWorkspaceStore.getState();
      if (activeProjectId && activeDocumentId) {
        updateDocumentInStorage(activeProjectId, activeDocumentId, { content: formattedContent });
        logger.log('üíæ Template content saved to localStorage');
      }
      
      logger.log('‚úÖ Template generation successful');
      
      // Show success state
      setGenerationSuccess(true);
      
      // Reset form after 2 seconds
      setTimeout(() => {
        setFormData({});
        setGenerationSuccess(false);
        
        // Re-initialize form
        const initialData: TemplateFormData = {};
        template.fields.forEach((field) => {
          initialData[field.id] = '';
          if (field.type === 'select' && field.options?.includes(OTHER_OPTION_VALUE)) {
            initialData[getOtherFieldId(field.id)] = '';
          }
        });
        setFormData(initialData);
      }, 2000);
      
    } catch (error) {
      const errorMessage = error instanceof Error
        ? error.message
        : 'An unexpected error occurred';
      
      setGenerationError(errorMessage);
      logger.error('‚ùå Template generation error:', errorMessage);
    } finally {
      setIsGenerating(false);
    }
  };
  
  /**
   * Get complexity badge color
   */
  const getComplexityColor = () => {
    switch (template.complexity) {
      case 'Beginner':
        return 'bg-green-100 text-green-700 border-green-200';
      case 'Intermediate':
        return 'bg-blue-100 text-blue-700 border-blue-200';
      case 'Advanced':
        return 'bg-purple-100 text-purple-700 border-purple-200';
    }
  };
  
  return (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div className="flex-shrink-0 bg-gradient-to-r from-blue-500 to-blue-600 text-white p-4 rounded-t-lg">
        <div className="flex items-start justify-between mb-3">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 bg-white/20 rounded-lg flex items-center justify-center">
              <IconComponent className="w-6 h-6" />
            </div>
            <div>
              <h2 className="text-lg font-semibold">{template.name}</h2>
              <p className="text-sm text-blue-100 mt-0.5">{template.description}</p>
            </div>
          </div>
          <button
            onClick={onCancel}
            className="p-1 hover:bg-white/20 rounded transition-colors"
            aria-label="Close"
          >
            <X className="w-5 h-5" />
          </button>
        </div>
        
        {/* Meta info */}
        <div className="flex items-center gap-3 text-sm">
          <span className={cn('px-2 py-0.5 rounded border bg-white/10 border-white/20')}>
            {template.complexity}
          </span>
          <div className="flex items-center gap-1.5">
            <Clock className="w-4 h-4" />
            <span>{template.estimatedTime}</span>
          </div>
        </div>
      </div>
      
      {/* Form content - scrollable */}
      <div className="flex-1 overflow-y-auto custom-scrollbar p-4 space-y-6">
        {/* Brand Voice Toggle */}
        {hasBrandVoice && (
          <div className="flex items-center justify-between p-3 bg-blue-50 border border-blue-200 rounded-lg">
            <div className="flex-1">
              <label
                htmlFor="apply-brand-voice"
                className="text-sm font-medium text-blue-900 cursor-pointer"
              >
                Apply Brand Voice
              </label>
              <p className="text-xs text-blue-700 mt-0.5">
                Use {activeProject?.brandVoice?.brandName} brand guidelines
              </p>
            </div>
            <input
              id="apply-brand-voice"
              type="checkbox"
              checked={applyBrandVoice}
              onChange={(e) => setApplyBrandVoice(e.target.checked)}
              disabled={isGenerating}
              className="w-5 h-5 text-blue-600 rounded focus:ring-2 focus:ring-blue-500 cursor-pointer"
            />
          </div>
        )}
        
        {/* No Brand Voice Message */}
        {!hasBrandVoice && (
          <div className="p-3 bg-gray-50 border border-gray-200 rounded-lg">
            <p className="text-xs text-gray-600">
              Set up brand voice in your project to apply it to generated copy
            </p>
          </div>
        )}
        
        {/* Persona Selection */}
        {personas.length > 0 && (
          <div className="flex flex-col gap-2">
            <label
              htmlFor="persona-select"
              className="text-sm font-medium text-apple-text-dark"
            >
              Target Persona (Optional)
            </label>
            <select
              id="persona-select"
              value={selectedPersonaId || ''}
              onChange={(e) => setSelectedPersonaId(e.target.value || null)}
              disabled={isGenerating}
              className={cn(
                'w-full px-3 py-2 rounded-lg border transition-all duration-200',
                'text-sm text-apple-text-dark bg-white',
                'border-apple-gray-light hover:border-apple-gray',
                'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
                'disabled:bg-gray-50 disabled:cursor-not-allowed'
              )}
            >
              <option value="">No persona selected</option>
              {personas.map((persona) => (
                <option key={persona.id} value={persona.id}>
                  {persona.name}
                </option>
              ))}
            </select>
            <p className="text-xs text-apple-text-light">
              Generate copy specifically for this persona
            </p>
          </div>
        )}
        
        {/* No Personas Message */}
        {personas.length === 0 && (
          <div className="p-3 bg-gray-50 border border-gray-200 rounded-lg">
            <p className="text-xs text-gray-600">
              Create personas in your project to target specific audiences
            </p>
          </div>
        )}
        
        {/* Divider */}
        <div className="border-t border-gray-200" />
        
        {/* Dynamic form fields */}
        <div className="space-y-4">
          {template.fields.map((field) => (
            <TemplateFormField
              key={field.id}
              field={field}
              value={formData[field.id] || ''}
              onChange={(value) => handleFieldChange(field.id, value)}
              otherValue={formData[getOtherFieldId(field.id)] || ''}
              onOtherChange={(value) => handleOtherChange(field.id, value)}
              error={errors[field.id]}
              otherError={errors[getOtherFieldId(field.id)]}
              disabled={isGenerating}
            />
          ))}
        </div>
        
        {/* Generation Error */}
        {generationError && (
          <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
            <AlertCircle className="w-5 h-5 text-red-600 flex-shrink-0 mt-0.5" />
            <div className="flex-1">
              <p className="text-sm font-medium text-red-900">Generation Failed</p>
              <p className="text-xs text-red-700 mt-1">{generationError}</p>
            </div>
            <button
              onClick={() => setGenerationError(null)}
              className="text-red-600 hover:text-red-800"
              aria-label="Dismiss error"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        )}
        
        {/* Success Message */}
        {generationSuccess && (
          <div className="flex items-center gap-2 p-3 bg-green-50 border border-green-200 rounded-lg">
            <CheckCircle className="w-5 h-5 text-green-600" />
            <p className="text-sm text-green-900 font-medium">
              Copy generated and inserted into editor!
            </p>
          </div>
        )}
      </div>
      
      {/* Action buttons */}
      <div className="flex-shrink-0 p-4 border-t border-gray-200 space-y-2">
        <button
          onClick={handleGenerate}
          disabled={isGenerating || generationSuccess}
          className={cn(
            'w-full py-3 px-4 rounded-lg font-medium text-sm text-white',
            'focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2',
            'flex items-center justify-center gap-2',
            // Animated gradient when generating
            isGenerating && 'aiworx-gradient-animated cursor-wait',
            // Brand button with blue‚Üípurple active when not generating
            !isGenerating && !generationSuccess && 'bg-[#006EE6] hover:bg-[#0062CC] active:bg-[#7A3991] active:scale-[0.98] shadow-sm hover:shadow transition-all duration-200',
            // Green background only for success state
            generationSuccess && 'bg-green-500'
          )}
        >
          {isGenerating ? (
            <AIWorxButtonLoader />
          ) : generationSuccess ? (
            <>
              <CheckCircle className="w-5 h-5" />
              Generated!
            </>
          ) : (
            <>
              <Sparkles className="w-5 h-5" />
              Generate with AI
            </>
          )}
        </button>
        
        <button
          onClick={onCancel}
          disabled={isGenerating}
          className={cn(
            'w-full py-2 px-4 rounded-lg font-medium text-sm',
            'border border-gray-300 text-gray-700 bg-white',
            'hover:bg-gray-50 transition-colors duration-200',
            'focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2',
            'disabled:opacity-50 disabled:cursor-not-allowed'
          )}
        >
          Cancel
        </button>
      </div>
    </div>
  );
}


=== FILE: components/workspace/TemplateResumeBanner.tsx ===

/**
 * @file components/workspace/TemplateResumeBanner.tsx
 * @description Banner component that appears when a document has incomplete template progress
 * 
 * Shows:
 * - Template name and current section
 * - Continue button to resume generation
 * - View Progress button to see completed sections
 * - Exit button to clear template mode
 */

'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { logger } from '@/lib/utils/logger';
import {
  Play,
  ListChecks,
  X,
  BookOpen,
  ChevronRight,
} from 'lucide-react';
import { cn } from '@/lib/utils';
import { useWorkspaceStore } from '@/lib/stores/workspaceStore';
import { getDocument, updateDocument as updateDocumentInStorage } from '@/lib/storage/unified-storage';
import { BROCHURE_SECTIONS } from '@/lib/templates/brochure-multi-section-config';
import type { TemplateProgress } from '@/lib/types/template-progress';

interface TemplateResumeBannerProps {
  /** Callback when Continue is clicked */
  onContinue?: () => void;
}

/**
 * Resume banner that appears when a document has incomplete template progress
 */
export function TemplateResumeBanner({ onContinue }: TemplateResumeBannerProps) {
  const activeDocumentId = useWorkspaceStore((state) => state.activeDocumentId);
  const activeProjectId = useWorkspaceStore((state) => state.activeProjectId);
  const selectedTemplateId = useWorkspaceStore((state) => state.selectedTemplateId);
  
  const [templateProgress, setTemplateProgress] = useState<TemplateProgress | null>(null);
  const [isDismissed, setIsDismissed] = useState(false);
  
  // Check for template progress when document changes
  useEffect(() => {
    const checkTemplateProgress = async () => {
      logger.log('üéóÔ∏è TemplateResumeBanner: Checking for progress...', {
        activeDocumentId,
        activeProjectId,
        selectedTemplateId
      });
      
      if (!activeDocumentId || !activeProjectId) {
        logger.log('‚ö†Ô∏è Banner: No active document or project');
        setTemplateProgress(null);
        setIsDismissed(false);
        return;
      }
      
      const doc = await getDocument(activeProjectId, activeDocumentId);
      logger.log('üìÑ Banner: Document loaded', {
        hasDoc: !!doc,
        hasProgress: !!doc?.templateProgress,
        isComplete: doc?.templateProgress?.isComplete,
        templateId: doc?.templateProgress?.templateId
      });
      
      if (doc?.templateProgress && !doc.templateProgress.isComplete) {
        logger.log('‚úÖ Banner: Found incomplete progress - SHOWING BANNER');
        setTemplateProgress(doc.templateProgress);
        setIsDismissed(false);
      } else {
        logger.log('‚ùå Banner: No incomplete progress found');
        setTemplateProgress(null);
      }
    };
    checkTemplateProgress();
  }, [activeDocumentId, activeProjectId, selectedTemplateId]);
  
  /**
   * Handle Continue - opens the multi-section template
   */
  const handleContinue = useCallback(() => {
    if (!templateProgress) return;
    
    // Set the template ID in store to open the multi-section template
    useWorkspaceStore.getState().setSelectedTemplateId(templateProgress.templateId);
    useWorkspaceStore.getState().setRightSidebarOpen(true);
    
    onContinue?.();
  }, [templateProgress, onContinue]);
  
  /**
   * Handle Exit - clears template progress from document
   */
  const handleExit = useCallback(async () => {
    if (!activeProjectId || !activeDocumentId) return;
    
    const confirmed = window.confirm(
      'Exit template mode? Your generated sections will be kept, but you won\'t be able to continue the template workflow.'
    );
    
    if (!confirmed) return;
    
    try {
      await updateDocumentInStorage(activeProjectId, activeDocumentId, {
        templateProgress: undefined,
      });
      setTemplateProgress(null);
    } catch (error) {
      logger.error('‚ùå Failed to clear template progress:', error);
    }
  }, [activeProjectId, activeDocumentId]);
  
  /**
   * Handle dismiss - temporarily hides the banner
   */
  const handleDismiss = useCallback(() => {
    setIsDismissed(true);
  }, []);
  
  // Don't show if no template progress, already complete, dismissed, or template already open
  if (!templateProgress || templateProgress.isComplete || isDismissed || selectedTemplateId) {
    logger.log('üö´ Banner: Hidden because:', {
      noProgress: !templateProgress,
      isComplete: templateProgress?.isComplete,
      isDismissed,
      templateIsOpen: !!selectedTemplateId
    });
    return null;
  }
  
  logger.log('‚ú® Banner: RENDERING - showing resume button');
  
  // Get current section info
  const currentSectionIndex = templateProgress.currentSection;
  const currentSection = BROCHURE_SECTIONS[currentSectionIndex];
  const completedCount = templateProgress.completedSections.length;
  const totalCount = templateProgress.totalSections;
  
  return (
    <div 
      className={cn(
        'mx-4 mt-4 p-4 rounded-lg border',
        'bg-purple-50 border-purple-200',
        'animate-in fade-in slide-in-from-top-2 duration-300'
      )}
      data-print-hide
    >
      <div className="flex items-start gap-3">
        {/* Icon */}
        <div className="flex-shrink-0 w-10 h-10 rounded-lg bg-purple-500 flex items-center justify-center">
          <BookOpen className="w-5 h-5 text-white" />
        </div>
        
        {/* Content */}
        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2 mb-1">
            <h3 className="font-semibold text-purple-900">
              Continue Brochure Generation
            </h3>
            <span className="px-2 py-0.5 text-xs font-medium bg-purple-100 text-purple-700 rounded-full">
              {completedCount}/{totalCount} sections
            </span>
          </div>
          
          <p className="text-sm text-purple-700 mb-3">
            Next up: <strong>{currentSection?.name || 'Unknown Section'}</strong>
          </p>
          
          {/* Progress bar */}
          <div className="h-1.5 bg-purple-200 rounded-full overflow-hidden mb-3">
            <div 
              className="h-full bg-purple-500 rounded-full transition-all duration-300"
              style={{ width: `${(completedCount / totalCount) * 100}%` }}
            />
          </div>
          
          {/* Actions */}
          <div className="flex items-center gap-2">
            <button
              onClick={handleContinue}
              className={cn(
                'px-4 py-2 rounded-lg text-sm font-medium',
                'bg-purple-500 text-white',
                'hover:bg-purple-600 transition-colors duration-200',
                'flex items-center gap-2'
              )}
            >
              <Play className="w-4 h-4" />
              Continue
              <ChevronRight className="w-4 h-4" />
            </button>
            
            <button
              onClick={handleExit}
              className={cn(
                'px-3 py-2 rounded-lg text-sm font-medium',
                'text-purple-700 hover:bg-purple-100',
                'transition-colors duration-200'
              )}
            >
              Exit Template Mode
            </button>
          </div>
        </div>
        
        {/* Dismiss button */}
        <button
          onClick={handleDismiss}
          className="flex-shrink-0 p-1 text-purple-400 hover:text-purple-600 hover:bg-purple-100 rounded transition-colors"
          aria-label="Dismiss"
        >
          <X className="w-4 h-4" />
        </button>
      </div>
    </div>
  );
}


=== FILE: components/workspace/TemplatesModal.tsx ===

/**
 * @file components/workspace/TemplatesModal.tsx
 * @description AI@Worx Templates Modal - Browse and select copywriting templates
 */

'use client';

import React, { useState, useEffect } from 'react';
import { logger } from '@/lib/utils/logger';
import {
  X,
  Sparkles,
  Mail,
  Megaphone,
  Layout,
  MessageSquare,
  FileText,
  Globe,
  CheckCircle,
  Clock,
  FileEdit,
} from 'lucide-react';
import type { LucideIcon } from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import { cn } from '@/lib/utils';
import { useWorkspaceStore, useUIActions, useTemplateActions } from '@/lib/stores/workspaceStore';
import { createDocument } from '@/lib/storage/unified-storage';
import { ALL_TEMPLATES } from '@/lib/data/templates';
import type { Template, TemplateCategory as ImportedTemplateCategory } from '@/lib/types/template';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TYPES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

type ModalTemplateCategory = 'all' | ImportedTemplateCategory;

interface TemplatesModalProps {
  isOpen: boolean;
  onClose: () => void;
  /** Optional callback when a template is selected (useful for navigation from splash page) */
  onTemplateSelect?: (templateId: string) => void;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CATEGORY CONFIGURATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const CATEGORIES: { id: ModalTemplateCategory; label: string; icon: React.ComponentType<{ className?: string }> }[] = [
  { id: 'all', label: 'All', icon: Sparkles },
  { id: 'email', label: 'Email', icon: Mail },
  { id: 'advertising', label: 'Ads', icon: Megaphone },
  { id: 'landing-page', label: 'Landing', icon: Layout },
  { id: 'social', label: 'Social', icon: MessageSquare },
  { id: 'collateral', label: 'Collateral', icon: FileText },
  { id: 'website', label: 'Website', icon: Globe },
];

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DIFFICULTY COLORS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const DIFFICULTY_COLORS: Record<Template['complexity'], string> = {
  Beginner: 'bg-green-100 text-green-800 border-green-200',
  Intermediate: 'bg-blue-100 text-blue-800 border-blue-200',
  Advanced: 'bg-purple-100 text-purple-800 border-purple-200',
};

/**
 * Check if a template is a multi-section advanced template
 * These templates use a special component instead of the standard form
 */
function isMultiSectionTemplate(templateId: string): boolean {
  return templateId === 'brochure-multi-section';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COMPONENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export function TemplatesModal({ isOpen, onClose, onTemplateSelect }: TemplatesModalProps) {
  const [activeCategory, setActiveCategory] = useState<ModalTemplateCategory>('all');
  
  // Optimized action selectors - only re-render when actions change (never)
  const { setRightSidebarOpen, setActiveTool } = useUIActions();
  const { 
    setSelectedTemplateId, 
    setIsGeneratingTemplate,
    clearToneShiftResult,
    clearExpandResult,
    clearShortenResult,
    clearRewriteChannelResult,
    clearBrandAlignmentResult,
  } = useTemplateActions();

  // Close on ESC key
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent): void => {
      if (e.key === 'Escape' && isOpen) {
        onClose();
      }
    };

    document.addEventListener('keydown', handleEscape);
    return () => document.removeEventListener('keydown', handleEscape);
  }, [isOpen, onClose]);

  // Prevent body scroll when modal is open
  useEffect(() => {
    if (isOpen) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = '';
    }
    return () => {
      document.body.style.overflow = '';
    };
  }, [isOpen]);

  // Filter templates by category
  const filteredTemplates =
    activeCategory === 'all'
      ? ALL_TEMPLATES
      : ALL_TEMPLATES.filter((template) => template.category === activeCategory);

  // Handle template selection
  const handleSelectTemplate = async (template: Template): Promise<void> => {
    logger.log('üé® Selected template:', template.id, template.name);
    
    // Clear all other tool states first
    logger.log('üßπ Clearing all tool states before opening template');
    clearToneShiftResult();
    clearExpandResult();
    clearShortenResult();
    clearRewriteChannelResult();
    clearBrandAlignmentResult();
    setIsGeneratingTemplate(false);
    
    // For multi-section templates, ALWAYS create a new document
    // This ensures the template has a clean document to work with
    if (template.id === 'brochure-multi-section') {
      const store = useWorkspaceStore.getState();
      const { activeProjectId } = store;
      
      if (activeProjectId) {
        try {
          // Always create a new document for multi-section templates
          const newDoc = await createDocument(activeProjectId, template.name);
          store.setActiveDocumentId(newDoc.id);
          logger.log('‚úÖ Created new document for multi-section template:', {
            id: newDoc.id,
            title: newDoc.title
          });
        } catch (error) {
          logger.error('‚ùå Failed to create document:', error);
        }
      } else {
        logger.error('‚ùå No active project - cannot create document');
      }
    }
    
    // Set selected template ID in store
    setSelectedTemplateId(template.id);
    
    // Clear active tool (template generator is special - not a tool in the sidebar)
    setActiveTool(null);
    
    // Open right sidebar to show template form
    setRightSidebarOpen(true);
    
    // Close modal
    onClose();
    
    // Call optional callback (used for navigation from splash page)
    if (onTemplateSelect) {
      onTemplateSelect(template.id);
    }
  };

  if (!isOpen) return null;

  return (
    <>
      {/* Backdrop */}
      <div
        className="fixed inset-0 bg-black/30 backdrop-blur-sm z-50 transition-opacity duration-300"
        onClick={onClose}
        aria-hidden="true"
      />

      {/* Modal */}
      <div className="fixed inset-0 z-50 flex items-center justify-center p-4 pointer-events-none">
        <div
          className="bg-white rounded-2xl shadow-2xl w-full max-w-[1100px] max-h-[90vh] overflow-hidden pointer-events-auto transform transition-all duration-300 ease-out"
          role="dialog"
          aria-modal="true"
          aria-labelledby="templates-modal-title"
          onClick={(e) => e.stopPropagation()}
        >
          {/* Header */}
          <div className="relative px-6 py-5 border-b border-gray-200">
            <div className="flex items-start justify-between">
              <div>
                <div className="flex items-center gap-2 mb-1">
                  <Sparkles className="w-6 h-6 text-[#007AFF]" />
                  <h2
                    id="templates-modal-title"
                    className="text-xl font-semibold text-[#1d1d1f]"
                  >
                    AI@Worx‚Ñ¢ Templates
                  </h2>
                </div>
                <p className="text-sm text-[#86868b]">
                  Select a template to create high-quality content with AI assistance
                </p>
              </div>
              <button
                onClick={onClose}
                className="p-2 rounded-lg hover:bg-gray-100 transition-colors focus:outline-none focus:ring-2 focus:ring-[#007AFF] focus:ring-offset-2"
                aria-label="Close modal"
              >
                <X className="w-5 h-5 text-gray-500" />
              </button>
            </div>
          </div>

          {/* Category Tabs */}
          <div className="px-6 py-4 border-b border-gray-200 overflow-x-auto">
            <div className="flex gap-2 min-w-max">
              {CATEGORIES.map((category) => {
                const CategoryIcon = category.icon;
                const isActive = activeCategory === category.id;

                return (
                  <button
                    key={category.id}
                    onClick={() => setActiveCategory(category.id)}
                    className={cn(
                      'flex items-center gap-2 px-4 py-2 rounded-full text-sm font-medium transition-all duration-200',
                      'focus:outline-none focus:ring-2 focus:ring-[#007AFF] focus:ring-offset-2',
                      isActive
                        ? 'bg-[#007AFF] text-white shadow-md'
                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                    )}
                  >
                    <CategoryIcon className="w-4 h-4" />
                    <span>{category.label}</span>
                  </button>
                );
              })}
            </div>
          </div>

          {/* Template Grid */}
          <div className="p-6 pb-4 overflow-y-auto max-h-[calc(90vh-200px)]">
            {filteredTemplates.length === 0 ? (
              <div className="text-center py-16">
                <FileEdit className="w-16 h-16 mx-auto mb-4 text-gray-300" />
                <p className="text-gray-500">No templates in this category yet</p>
              </div>
            ) : (
              <>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {filteredTemplates.map((template) => {
                    // Get icon component dynamically from Lucide
                    const TemplateIcon = (LucideIcons as unknown as Record<string, LucideIcon>)[template.icon] || FileText;

                    return (
                      <div
                        key={template.id}
                        className={cn(
                          'group relative bg-white border border-[#d2d2d7] rounded-xl p-5',
                          'transition-all duration-200 hover:shadow-lg hover:border-[#007AFF]',
                          'flex flex-col',
                          // Highlight multi-section templates
                          isMultiSectionTemplate(template.id) && 'border-purple-200 bg-purple-50/30'
                        )}
                      >
                        {/* Category Badge */}
                        <div className="absolute top-4 right-4 flex gap-1.5">
                          {isMultiSectionTemplate(template.id) && (
                            <span className="px-2 py-0.5 text-xs font-medium bg-purple-100 text-purple-700 rounded-full">
                              Multi-Section
                            </span>
                          )}
                          <span className="px-2 py-0.5 text-xs font-medium bg-gray-100 text-gray-600 rounded-full capitalize">
                            {template.category.replace('-', ' ')}
                          </span>
                        </div>

                        {/* Icon */}
                        <div className="mb-4">
                          <div className="w-12 h-12 rounded-lg bg-blue-50 flex items-center justify-center">
                            <TemplateIcon className="w-6 h-6 text-[#007AFF]" />
                          </div>
                        </div>

                        {/* Content */}
                        <div className="flex-1 mb-4">
                          <h3 className="text-base font-semibold text-[#1d1d1f] mb-2">
                            {template.name}
                          </h3>
                          <p className="text-sm text-[#86868b] leading-relaxed">
                            {template.description}
                          </p>
                        </div>

                        {/* Meta Info */}
                        <div className="flex items-center gap-3 mb-4 text-xs">
                          <span
                            className={cn(
                              'px-2 py-1 rounded border font-medium',
                              DIFFICULTY_COLORS[template.complexity]
                            )}
                          >
                            {template.complexity}
                          </span>
                          <div className="flex items-center gap-1 text-gray-500">
                            <Clock className="w-3.5 h-3.5" />
                            <span>{template.estimatedTime}</span>
                          </div>
                        </div>

                        {/* Select Button */}
                        <button
                          onClick={() => handleSelectTemplate(template)}
                          className={cn(
                            'w-full py-2.5 px-4 rounded-lg font-medium text-sm',
                            'bg-[#007AFF] text-white',
                            'hover:bg-[#0071e3] transition-colors duration-200',
                            'focus:outline-none focus:ring-2 focus:ring-[#007AFF] focus:ring-offset-2',
                            'flex items-center justify-center gap-2'
                          )}
                        >
                          <CheckCircle className="w-4 h-4" />
                          <span>Select Template</span>
                        </button>
                      </div>
                    );
                  })}
                </div>

                {/* Complexity Legend */}
                <div className="mt-8 pt-4 border-t border-gray-200">
                  <div className="bg-gray-50 rounded-lg px-4 py-3">
                    <div className="flex items-start gap-2 mb-2">
                      <span className="text-xs font-semibold text-gray-600 uppercase tracking-wide">
                        Complexity Guide:
                      </span>
                    </div>
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-3 text-xs">
                      {/* Beginner */}
                      <div className="flex items-start gap-2">
                        <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-green-100 text-green-800 border border-green-200 flex-shrink-0">
                          Beginner
                        </span>
                        <div className="text-gray-600">
                          <div className="font-medium text-gray-700">5-10 min</div>
                          <div className="text-gray-500">3-5 fields, basic info</div>
                        </div>
                      </div>
                      
                      {/* Intermediate */}
                      <div className="flex items-start gap-2">
                        <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-blue-100 text-blue-800 border border-blue-200 flex-shrink-0">
                          Intermediate
                        </span>
                        <div className="text-gray-600">
                          <div className="font-medium text-gray-700">15-20 min</div>
                          <div className="text-gray-500">5-8 fields, strategy needed</div>
                        </div>
                      </div>
                      
                      {/* Advanced */}
                      <div className="flex items-start gap-2">
                        <span className="inline-flex items-center px-2 py-0.5 rounded text-xs font-medium bg-purple-100 text-purple-800 border border-purple-200 flex-shrink-0">
                          Advanced
                        </span>
                        <div className="text-gray-600">
                          <div className="font-medium text-gray-700">20-30 min</div>
                          <div className="text-gray-500">8-12+ fields, comprehensive</div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </>
            )}
          </div>
        </div>
      </div>
    </>
  );
}


=== FILE: components/workspace/TemplatesSlideOut.tsx ===

/**
 * @file components/workspace/TemplatesSlideOut.tsx
 * @description AI@Worx Templates slide-out panel - Browse templates from left sidebar
 * 
 * Features:
 * - 450px wide left slide-out panel
 * - Search templates by name/description
 * - Collapsible category sections
 * - Template cards with name, description, icon
 * - Clicking a template opens the template form in right slide-out
 * - Can have both browser (left) and form (right) open simultaneously
 */

'use client';

import React, { useState, useMemo, useCallback } from 'react';
import { logger } from '@/lib/utils/logger';
import {
  Search,
  ChevronDown,
  ChevronRight,
  Mail,
  Megaphone,
  Target,
  MessageSquare,
  FileEdit,
  Globe,
  Clock,
  Sparkles,
} from 'lucide-react';
import * as LucideIcons from 'lucide-react';
import type { LucideIcon } from 'lucide-react';
import { SlideOutPanel } from '@/components/ui/SlideOutPanel';
import { Input } from '@/components/ui/input';
import { cn } from '@/lib/utils';
import { ALL_TEMPLATES } from '@/lib/data/templates';
import { createDocument } from '@/lib/storage/unified-storage';
import type { Template, TemplateCategory } from '@/lib/types/template';
import { useWorkspaceStore, useUIActions, useTemplateActions } from '@/lib/stores/workspaceStore';
import { useSlideOutActions as useGlobalSlideOutActions } from '@/lib/stores/slideOutStore';
import { TEMPLATE_FORM_PANEL_ID } from './TemplateFormSlideOut';

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CONSTANTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/** Unique ID for the templates slide-out panel */
export const TEMPLATES_PANEL_ID = 'templates-browser';

/**
 * Category grouping configuration
 * Maps user-facing category names to template categories
 */
const CATEGORY_GROUPS = [
  {
    id: 'marketing-sales',
    name: 'Marketing & Sales',
    icon: Megaphone,
    categories: ['advertising' as TemplateCategory],
  },
  {
    id: 'website-digital',
    name: 'Website & Digital',
    icon: Globe,
    categories: ['website' as TemplateCategory, 'landing-page' as TemplateCategory],
  },
  {
    id: 'creative-editorial',
    name: 'Creative & Editorial',
    icon: FileEdit,
    categories: ['collateral' as TemplateCategory],
  },
  {
    id: 'social-media',
    name: 'Social Media',
    icon: MessageSquare,
    categories: ['social' as TemplateCategory],
  },
  {
    id: 'email-marketing',
    name: 'Email Marketing',
    icon: Mail,
    categories: ['email' as TemplateCategory],
  },
];

/**
 * Icon mapping from template icon names to Lucide icons
 */
const ICON_MAP: Record<string, LucideIcon> = {
  DollarSign: LucideIcons.DollarSign,
  Target,
  Mail,
  Megaphone,
  MessageSquare,
  FileText: LucideIcons.FileText,
  FileEdit,
  Globe,
};

/**
 * Difficulty badge colors
 */
const DIFFICULTY_COLORS: Record<Template['complexity'], string> = {
  Beginner: 'bg-green-100 text-green-800 border-green-200',
  Intermediate: 'bg-blue-100 text-blue-800 border-blue-200',
  Advanced: 'bg-purple-100 text-purple-800 border-purple-200',
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TYPES
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

interface TemplatesSlideOutProps {
  /** Whether the slide-out is open */
  isOpen: boolean;
  
  /** Callback when slide-out should close */
  onClose: () => void;
}

interface TemplateCategoryGroupProps {
  /** Category group configuration */
  group: typeof CATEGORY_GROUPS[number];
  
  /** Templates in this group */
  templates: Template[];
  
  /** Whether section is expanded */
  isExpanded: boolean;
  
  /** Callback to toggle expansion */
  onToggle: () => void;
  
  /** Callback when template is selected */
  onSelectTemplate: (template: Template) => void;
  
  /** Currently selected template ID */
  selectedTemplateId: string | null;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SUB-COMPONENTS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Template Card Component
 */
function TemplateCard({
  template,
  isSelected,
  onSelect,
}: {
  template: Template;
  isSelected: boolean;
  onSelect: () => void;
}) {
  const IconComponent = ICON_MAP[template.icon] || Sparkles;

  return (
    <button
      onClick={onSelect}
      className={cn(
        'w-full text-left p-4 rounded-lg border transition-all duration-200',
        'hover:shadow-md hover:border-apple-blue/50',
        'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
        'group',
        isSelected
          ? 'bg-apple-blue/5 border-apple-blue shadow-sm'
          : 'bg-white border-gray-200 hover:bg-gray-50'
      )}
    >
      <div className="flex items-start gap-3">
        {/* Icon */}
        <div
          className={cn(
            'flex-shrink-0 w-10 h-10 rounded-lg flex items-center justify-center',
            'transition-colors duration-200',
            isSelected
              ? 'bg-apple-blue text-white'
              : 'bg-gray-100 text-gray-600 group-hover:bg-apple-blue group-hover:text-white'
          )}
        >
          <IconComponent className="w-5 h-5" />
        </div>

        {/* Content */}
        <div className="flex-1 min-w-0">
          <div className="flex items-start justify-between gap-2 mb-1">
            <h4
              className={cn(
                'font-semibold text-sm',
                isSelected ? 'text-apple-blue' : 'text-gray-900'
              )}
            >
              {template.name}
            </h4>
            <span
              className={cn(
                'flex-shrink-0 px-2 py-0.5 text-[10px] font-medium rounded-full border',
                DIFFICULTY_COLORS[template.complexity]
              )}
            >
              {template.complexity}
            </span>
          </div>

          <p className="text-xs text-gray-600 mb-2 line-clamp-2">
            {template.description}
          </p>

          <div className="flex items-center gap-1 text-[11px] text-gray-500">
            <Clock className="w-3 h-3" />
            <span>{template.estimatedTime}</span>
          </div>
        </div>
      </div>
    </button>
  );
}

/**
 * Template Category Group Component
 */
function TemplateCategoryGroup({
  group,
  templates,
  isExpanded,
  onToggle,
  onSelectTemplate,
  selectedTemplateId,
}: TemplateCategoryGroupProps) {
  const GroupIcon = group.icon;

  if (templates.length === 0) return null;

  return (
    <div className="space-y-2">
      {/* Section Header */}
      <button
        onClick={onToggle}
        className={cn(
          'w-full flex items-center justify-between p-2 rounded-lg',
          'hover:bg-gray-100 transition-colors duration-200',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2'
        )}
      >
        <div className="flex items-center gap-2">
          <GroupIcon className="w-4 h-4 text-apple-blue" />
          <span className="font-semibold text-sm text-gray-900">
            {group.name}
          </span>
          <span className="text-xs text-gray-500">
            ({templates.length})
          </span>
        </div>
        {isExpanded ? (
          <ChevronDown className="w-4 h-4 text-gray-400" />
        ) : (
          <ChevronRight className="w-4 h-4 text-gray-400" />
        )}
      </button>

      {/* Templates List */}
      {isExpanded && (
        <div className="space-y-2 pl-6">
          {templates.map((template) => (
            <TemplateCard
              key={template.id}
              template={template}
              isSelected={selectedTemplateId === template.id}
              onSelect={() => onSelectTemplate(template)}
            />
          ))}
        </div>
      )}
    </div>
  );
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MAIN COMPONENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export function TemplatesSlideOut({
  isOpen,
  onClose,
}: TemplatesSlideOutProps) {
  // Store actions
  const { setActiveTool, setRightSidebarOpen } = useUIActions();
  const { 
    setSelectedTemplateId, 
    setIsGeneratingTemplate,
    clearToneShiftResult,
    clearExpandResult,
    clearShortenResult,
    clearRewriteChannelResult,
    clearBrandAlignmentResult,
  } = useTemplateActions();
  const { openSlideOut } = useGlobalSlideOutActions();

  // Local state
  const [searchQuery, setSearchQuery] = useState('');
  const [expandedGroups, setExpandedGroups] = useState<Set<string>>(
    new Set(['marketing-sales', 'website-digital', 'email-marketing']) // Start with popular categories expanded
  );
  const [selectedTemplateId, setLocalSelectedTemplateId] = useState<string | null>(null);

  // Filter templates by search query
  const filteredTemplates = useMemo(() => {
    if (!searchQuery.trim()) return ALL_TEMPLATES;
    
    const query = searchQuery.toLowerCase();
    return ALL_TEMPLATES.filter(
      (template) =>
        template.name.toLowerCase().includes(query) ||
        template.description.toLowerCase().includes(query)
    );
  }, [searchQuery]);

  // Group templates by category
  const groupedTemplates = useMemo(() => {
    return CATEGORY_GROUPS.map((group) => ({
      group,
      templates: filteredTemplates.filter((template) =>
        group.categories.includes(template.category)
      ),
    }));
  }, [filteredTemplates]);

  // Toggle category expansion
  const toggleGroup = useCallback((groupId: string) => {
    setExpandedGroups((prev) => {
      const next = new Set(prev);
      if (next.has(groupId)) {
        next.delete(groupId);
      } else {
        next.add(groupId);
      }
      return next;
    });
  }, []);

  // Handle template selection
  const handleSelectTemplate = useCallback(
    async (template: Template) => {
      logger.log('üé® Selected template:', template.id, template.name);
      
      // Set local selected state for visual feedback
      setLocalSelectedTemplateId(template.id);
      
      // Clear all other tool states first
      logger.log('üßπ Clearing all tool states before opening template');
      clearToneShiftResult();
      clearExpandResult();
      clearShortenResult();
      clearRewriteChannelResult();
      clearBrandAlignmentResult();
      setIsGeneratingTemplate(false);
      
      // For multi-section templates, ALWAYS create a new document
      const isMultiSectionTemplate = template.id === 'brochure-multi-section';
      
      if (isMultiSectionTemplate) {
        const store = useWorkspaceStore.getState();
        const { activeProjectId } = store;
        
        // Always create a new document for multi-section templates
        if (activeProjectId) {
          try {
            const newDoc = await createDocument(activeProjectId, template.name);
            store.setActiveDocumentId(newDoc.id);
            logger.log('‚úÖ Created new document for multi-section template:', {
              id: newDoc.id,
              title: newDoc.title
            });
          } catch (error) {
            logger.error('‚ùå Failed to create document:', error);
          }
        } else {
          logger.error('‚ùå No active project - cannot create document');
        }
      }
      
      // Set selected template ID in store
      setSelectedTemplateId(template.id);
      
      // Clear active tool (template generator is special - not a tool in the sidebar)
      setActiveTool(null);
      
      if (isMultiSectionTemplate) {
        // Open right sidebar to show multi-section template component (NOT the slideout)
        setRightSidebarOpen(true);
        logger.log('‚úÖ Multi-section template: Opening right sidebar (NOT slideout)');
      } else {
        // Open template form slide-out from right for regular templates
        openSlideOut(TEMPLATE_FORM_PANEL_ID);
        logger.log('‚úÖ Regular template: Opening slideout panel');
      }
      
      // NOTE: Do NOT close the templates browser - allow both panels to be open
    },
    [
      setSelectedTemplateId,
      setIsGeneratingTemplate,
      setActiveTool,
      setRightSidebarOpen,
      openSlideOut,
      clearToneShiftResult,
      clearExpandResult,
      clearShortenResult,
      clearRewriteChannelResult,
      clearBrandAlignmentResult,
    ]
  );

  return (
    <SlideOutPanel
      isOpen={isOpen}
      onClose={onClose}
      side="left"
      title="AI@Worx‚Ñ¢ Templates"
      subtitle={`${ALL_TEMPLATES.length} professional templates`}
    >
      <div className="space-y-4">
        {/* Search bar */}
        <div className="relative">
          <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-gray-400" />
          <Input
            type="text"
            placeholder="Search templates..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-10"
          />
        </div>

        {/* Info message */}
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-3">
          <p className="text-xs text-blue-700">
            <strong>Tip:</strong> Select a template to open the form in the right panel.
            Both panels can be open at the same time!
          </p>
        </div>

        {/* Category groups */}
        <div className="space-y-3">
          {groupedTemplates.map(({ group, templates }) => (
            <TemplateCategoryGroup
              key={group.id}
              group={group}
              templates={templates}
              isExpanded={expandedGroups.has(group.id)}
              onToggle={() => toggleGroup(group.id)}
              onSelectTemplate={handleSelectTemplate}
              selectedTemplateId={selectedTemplateId}
            />
          ))}

          {/* Empty state */}
          {filteredTemplates.length === 0 && (
            <div className="text-center py-8">
              <Sparkles className="h-12 w-12 mx-auto text-gray-300 mb-3" />
              <p className="text-gray-500">No templates found</p>
              <p className="text-sm text-gray-400 mt-1">
                Try a different search term
              </p>
            </div>
          )}
        </div>

        {/* Complexity Legend */}
        {filteredTemplates.length > 0 && (
          <div className="mt-6 pt-4 border-t border-gray-200">
            <div className="bg-gray-50 rounded-lg px-4 py-3">
              <div className="flex items-start gap-2 mb-3">
                <span className="text-xs font-semibold text-gray-600 uppercase tracking-wide">
                  Complexity Guide:
                </span>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-xs">
                {/* Beginner */}
                <div className="flex flex-col items-start gap-1.5">
                  <span className="inline-flex items-center px-2 py-0.5 rounded-full text-[10px] font-medium bg-green-100 text-green-800 border border-green-200">
                    Beginner
                  </span>
                  <div className="text-gray-600 space-y-0.5">
                    <div className="font-medium text-gray-700">5-10 min</div>
                    <div className="text-gray-600">3-5 fields</div>
                    <div className="text-gray-500">Basic info</div>
                  </div>
                </div>
                
                {/* Intermediate */}
                <div className="flex flex-col items-start gap-1.5">
                  <span className="inline-flex items-center px-2 py-0.5 rounded-full text-[10px] font-medium bg-blue-100 text-blue-800 border border-blue-200">
                    Intermediate
                  </span>
                  <div className="text-gray-600 space-y-0.5">
                    <div className="font-medium text-gray-700">15-20 min</div>
                    <div className="text-gray-600">5-8 fields</div>
                    <div className="text-gray-500">Strategy needed</div>
                  </div>
                </div>
                
                {/* Advanced */}
                <div className="flex flex-col items-start gap-1.5">
                  <span className="inline-flex items-center px-2 py-0.5 rounded-full text-[10px] font-medium bg-purple-100 text-purple-800 border border-purple-200">
                    Advanced
                  </span>
                  <div className="text-gray-600 space-y-0.5">
                    <div className="font-medium text-gray-700">20-30 min</div>
                    <div className="text-gray-600">8-12+ fields</div>
                    <div className="text-gray-500">Comprehensive</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </SlideOutPanel>
  );
}


=== FILE: components/workspace/ToneShifter.tsx ===

/**
 * @file components/workspace/ToneShifter.tsx
 * @description AI-powered tone shifting component for rewriting copy
 * 
 * Features:
 * - Six tone options: Professional, Casual, Urgent, Friendly, Techy, Playful
 * - Real-time loading states
 * - Result preview with insert/copy options
 * - Apple-style design aesthetic
 * - Full integration with Zustand store and TipTap editor
 * 
 * @example
 * ```tsx
 * <ToneShifter editor={editorInstance} />
 * ```
 */

'use client';

import React from 'react';
import { logger } from '@/lib/utils/logger';
import { 
  Briefcase, 
  Smile, 
  Zap, 
  Heart, 
  Check, 
  X,
  Copy,
  FileText,
  Sparkles,
  Terminal,
  PartyPopper
} from 'lucide-react';
import { 
  useSelectedText,
  useSelectedHTML,
  useSelectionRange,
  useSelectedTone,
  useToneShiftResult,
  useToneShiftLoading,
  useToneShiftError,
  useToneShiftActions,
  type ToneType 
} from '@/lib/stores/workspaceStore';
import { insertTextAtSelection } from '@/lib/editor-utils';
import { formatGeneratedContent } from '@/lib/utils/content-formatting';
import { AIWorxButtonLoader } from '@/components/ui/AIWorxLoader';
import type { Editor } from '@tiptap/react';
import { cn } from '@/lib/utils';

interface ToneShifterProps {
  /** TipTap editor instance */
  editor: Editor | null;
  
  /** Optional CSS classes */
  className?: string;
}

/**
 * Tone option configuration with icon and metadata
 */
const TONE_OPTIONS: {
  value: ToneType;
  label: string;
  icon: React.ComponentType<{ className?: string }>;
  description: string;
  color: string;
}[] = [
  {
    value: 'professional',
    label: 'Professional',
    icon: Briefcase,
    description: 'Formal and business-appropriate',
    color: 'blue',
  },
  {
    value: 'casual',
    label: 'Casual',
    icon: Smile,
    description: 'Friendly and conversational',
    color: 'green',
  },
  {
    value: 'urgent',
    label: 'Urgent',
    icon: Zap,
    description: 'Time-sensitive and action-oriented',
    color: 'red',
  },
  {
    value: 'friendly',
    label: 'Friendly',
    icon: Heart,
    description: 'Warm and approachable',
    color: 'pink',
  },
  {
    value: 'techy',
    label: 'Techy',
    icon: Terminal,
    description: 'Technical, precise, expertise-driven',
    color: 'purple',
  },
  {
    value: 'playful',
    label: 'Playful',
    icon: PartyPopper,
    description: 'Fun, energetic, lighthearted',
    color: 'orange',
  },
];

/**
 * ToneShifter component - AI-powered copy rewriting tool
 */
export function ToneShifter({ editor, className }: ToneShifterProps) {
  // Optimized selectors - only re-render when these specific values change
  const selectedText = useSelectedText();
  const selectedHTML = useSelectedHTML();
  const selectionRange = useSelectionRange();
  const selectedTone = useSelectedTone();
  const toneShiftResult = useToneShiftResult();
  const toneShiftLoading = useToneShiftLoading();
  const toneShiftError = useToneShiftError();
  const { runToneShift, clearToneShiftResult, insertToneShiftResult, setSelectedTone } = useToneShiftActions();

  // Check if user has text selected
  const hasSelection = selectedText && selectedText.trim().length > 0;
  const canShift = hasSelection && selectedTone && !toneShiftLoading;

  /**
   * Handle tone selection
   */
  const handleToneSelect = (tone: ToneType): void => {
    setSelectedTone(tone === selectedTone ? null : tone);
  };

  /**
   * Handle tone shift action
   * Uses HTML content to preserve formatting (bullets, headings, etc.)
   */
  const handleShiftTone = async (): Promise<void> => {
    if (!selectedTone) return;
    
    // Prefer HTML for formatting preservation, fallback to plain text
    const contentToShift = selectedHTML || selectedText;
    if (!contentToShift) return;
    
    logger.log('üìù Tone shifting with formatting:', {
      hasHTML: !!selectedHTML,
      textLength: selectedText?.length || 0,
      htmlLength: selectedHTML?.length || 0,
      tone: selectedTone,
    });
    
    await runToneShift(contentToShift, selectedTone);
  };

  /**
   * Handle replace selection with result
   */
  const handleReplaceSelection = (): void => {
    if (!editor || !toneShiftResult || !selectionRange) return;
    
    // Format the HTML result (sanitize and remove excess whitespace)
    const formattedHTML = formatGeneratedContent(toneShiftResult, false);
    
    // Use editor utils to replace the selection with formatted HTML
    const success = insertTextAtSelection(editor, formattedHTML, { isHTML: true });
    
    if (success) {
      // Clear the result after replacing
      clearToneShiftResult();
      logger.log('‚úÖ Tone shifted content inserted with formatting preserved');
    }
  };

  /**
   * Handle insert result into editor (replaces entire document)
   */
  const handleInsertResult = (): void => {
    if (!editor) return;
    insertToneShiftResult(editor);
  };

  /**
   * Handle copy result to clipboard
   */
  const handleCopyResult = async (): Promise<void> => {
    if (!toneShiftResult) return;
    
    try {
      // Copy the HTML to clipboard (user can paste into editor or other tools)
      await navigator.clipboard.writeText(toneShiftResult);
      logger.log('‚úÖ Copied HTML to clipboard');
    } catch (error) {
      logger.error('‚ùå Failed to copy:', error);
    }
  };

  return (
    <div className={cn('flex flex-col gap-6', className)}>
      {/* Header */}
      <div className="flex flex-col gap-2">
        <div className="flex items-center gap-2">
          <FileText className="w-5 h-5 text-apple-blue" />
          <h2 className="text-lg font-semibold text-apple-text-dark">
            Tone Shifter
          </h2>
        </div>
        <p className="text-sm text-apple-text-light">
          Rewrite your copy in a different tone
        </p>
      </div>

      {/* Selected Text Preview */}
      {hasSelection ? (
        <div className="flex flex-col gap-2">
          <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide flex items-center gap-1.5">
            <Sparkles className="w-3.5 h-3.5 text-apple-blue" />
            Selected Text ({selectedText?.length || 0} characters)
          </label>
          <div className="bg-apple-gray-bg border border-apple-gray-light rounded-lg p-3 max-h-32 overflow-y-auto custom-scrollbar">
            <p className="text-sm text-apple-text-dark whitespace-pre-wrap">
              {selectedText}
            </p>
          </div>
        </div>
      ) : (
        <div className="flex items-center gap-2 p-3 bg-blue-50 border border-blue-200 rounded-lg">
          <Sparkles className="w-4 h-4 text-blue-600 flex-shrink-0" />
          <p className="text-xs text-blue-700">
            Highlight text in the editor to shift tone
          </p>
        </div>
      )}

      {/* Tone Selection Buttons */}
      <div className="flex flex-col gap-3">
        <label className="text-xs font-medium text-apple-text-dark uppercase tracking-wide">
          Select Tone
        </label>
        <div className="grid grid-cols-2 gap-2">
          {TONE_OPTIONS.map((tone) => {
            const Icon = tone.icon;
            const isSelected = selectedTone === tone.value;
            
            return (
              <button
                key={tone.value}
                onClick={() => handleToneSelect(tone.value)}
                disabled={toneShiftLoading}
                className={cn(
                  'flex flex-col items-start gap-2 p-3 rounded-lg',
                  'border transition-all duration-200',
                  'hover:shadow-sm focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
                  'disabled:opacity-50 disabled:cursor-not-allowed',
                  isSelected
                    ? 'bg-apple-blue text-white border-apple-blue shadow-sm'
                    : 'bg-white text-apple-text-dark border-apple-gray-light hover:border-apple-gray hover:bg-apple-gray-bg'
                )}
                title={tone.description}
              >
                <Icon className={cn('w-5 h-5', isSelected ? 'text-white' : 'text-apple-blue')} />
                <div className="flex flex-col items-start gap-0.5 w-full">
                  <span className="text-sm font-medium text-left">{tone.label}</span>
                  <span className={cn(
                    'text-xs text-left',
                    isSelected ? 'text-blue-100' : 'text-apple-text-light'
                  )}>
                    {tone.description}
                  </span>
                </div>
              </button>
            );
          })}
        </div>
      </div>

      {/* Action Button */}
      <button
        onClick={handleShiftTone}
        disabled={!canShift}
        className={cn(
          'w-full py-3 px-4 rounded-lg',
          'font-medium text-sm text-white',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          // Animated gradient when loading
          toneShiftLoading && 'aiworx-gradient-animated cursor-wait',
          // Brand button with blue‚Üípurple active when not loading
          !toneShiftLoading && hasSelection && 'bg-[#006EE6] hover:bg-[#0062CC] active:bg-[#7A3991] active:scale-[0.98] shadow-sm hover:shadow transition-all duration-200',
          // Gray background when truly disabled (not loading)
          !hasSelection && !toneShiftLoading && 'bg-apple-gray-light text-apple-text-light cursor-not-allowed'
        )}
      >
        {toneShiftLoading ? (
          <AIWorxButtonLoader />
        ) : (
          'Shift Tone'
        )}
      </button>

      {/* Helper Text */}
      {!hasSelection && (
        <p className="text-xs text-apple-text-light text-center">
          Select text in the editor to use Tone Shifter
        </p>
      )}

      {/* Error Display */}
      {toneShiftError && (
        <div className="flex items-start gap-2 p-3 bg-red-50 border border-red-200 rounded-lg">
          <X className="w-4 h-4 text-red-600 flex-shrink-0 mt-0.5" />
          <div className="flex-1">
            <p className="text-sm font-medium text-red-900">Error</p>
            <p className="text-xs text-red-700 mt-1">{toneShiftError}</p>
          </div>
          <button
            onClick={clearToneShiftResult}
            className="text-red-600 hover:text-red-800 focus:outline-none"
            aria-label="Dismiss error"
          >
            <X className="w-4 h-4" />
          </button>
        </div>
      )}

      {/* Result Display */}
      {toneShiftResult && (
        <div className="flex flex-col gap-3 p-4 bg-green-50 border border-green-200 rounded-lg">
          {/* Success Header */}
          <div className="flex items-center gap-2">
            <Check className="w-5 h-5 text-green-600" />
            <span className="text-sm font-medium text-green-900">
              Rewrite Complete
            </span>
          </div>

          {/* Result Preview */}
          <div className="bg-white border border-green-200 rounded p-3 max-h-48 overflow-y-auto custom-scrollbar">
            <div 
              className="text-sm text-apple-text-dark prose prose-sm max-w-none"
              dangerouslySetInnerHTML={{ __html: toneShiftResult }}
            />
          </div>

          {/* Action Buttons */}
          <div className="flex gap-2">
            <button
              onClick={handleReplaceSelection}
              className={cn(
                'flex-1 py-2 px-3 rounded-lg',
                'bg-green-600 text-white text-sm font-medium',
                'hover:bg-green-700 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              disabled={!selectionRange}
              title="Replace selected text with rewritten version"
            >
              <Check className="w-4 h-4" />
              Replace Selection
            </button>
            <button
              onClick={handleCopyResult}
              className={cn(
                'py-2 px-3 rounded-lg',
                'bg-white border border-green-300 text-green-700 text-sm font-medium',
                'hover:bg-green-50 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              title="Copy to clipboard"
            >
              <Copy className="w-4 h-4" />
            </button>
            <button
              onClick={clearToneShiftResult}
              className={cn(
                'py-2 px-3 rounded-lg',
                'bg-white border border-green-300 text-green-700 text-sm font-medium',
                'hover:bg-green-50 transition-colors duration-200',
                'focus:outline-none focus:ring-2 focus:ring-green-600 focus:ring-offset-2',
                'flex items-center justify-center gap-2'
              )}
              title="Clear result"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        </div>
      )}
    </div>
  );
}


=== FILE: components/workspace/Toolbar.tsx ===

/**
 * @file components/workspace/Toolbar.tsx
 * @description Top toolbar with file menu, formatting controls, and view modes
 * 
 * Features:
 * - Left: File operations (Home, Undo, Redo)
 * - Center: Rich text formatting controls
 * - Right: View mode selector
 * - Apple-style aesthetic with smooth interactions
 * - Keyboard shortcut tooltips
 * 
 * @example
 * ```tsx
 * <Toolbar />
 * ```
 */

'use client';

import React, { useEffect, useState, useRef, useCallback } from 'react';
import Link from 'next/link';
import type { Editor } from '@tiptap/react';
import {
  FolderOpen,
  Undo,
  Redo,
  FileText,
  Bold,
  Italic,
  Underline as UnderlineIcon,
  List,
  ListOrdered,
  AlignLeft,
  AlignCenter,
  AlignRight,
  Link as LinkIcon,
  RemoveFormatting,
  ChevronDown,
  Paintbrush,
  Highlighter,
  X,
  FileDown,
  FileUp,
  Printer,
  ChevronRight,
} from 'lucide-react';
import { useActiveDocumentId, useActiveProjectId, useUIActions, useViewMode } from '@/lib/stores/workspaceStore';
import { getDocument, updateDocument } from '@/lib/storage/unified-storage';
import { ViewModeSelector } from './ViewModeSelector';
import { SaveAsSnippetButton } from './SaveAsSnippetButton';
import { ConfirmationModal } from '@/components/ui/ConfirmationModal';
import { cn } from '@/lib/utils';
import { logger } from '@/lib/utils/logger';

interface ToolbarProps {
  /** Optional CSS classes */
  className?: string;
  /** Callback to restart the product tour */
  onRestartTour?: () => void;
}

/**
 * Formatting button component
 */
interface FormatButtonProps {
  icon: React.ReactNode;
  title: string;
  onClick: () => void;
  isActive?: boolean;
  disabled?: boolean;
}

function FormatButton({
  icon,
  title,
  onClick,
  isActive = false,
  disabled = false,
}: FormatButtonProps) {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      title={title}
      className={cn(
        'w-8 h-8 rounded-md',
        'flex items-center justify-center',
        'transition-all duration-150',
        'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
        disabled
          ? 'opacity-30 cursor-not-allowed'
          : isActive
          ? 'bg-apple-blue text-white shadow-sm'
          : 'text-apple-text-dark hover:bg-apple-gray-bg'
      )}
    >
      {icon}
    </button>
  );
}

/**
 * Font family options - web-safe fonts plus modern fonts
 */
const FONT_FAMILIES = [
  { label: 'Default', value: '' },
  // Web-safe fonts
  { label: 'Arial', value: 'Arial' },
  { label: 'Helvetica', value: 'Helvetica' },
  { label: 'Georgia', value: 'Georgia' },
  { label: 'Times New Roman', value: 'Times New Roman' },
  { label: 'Courier New', value: 'Courier New' },
  { label: 'Verdana', value: 'Verdana' },
  { label: 'Trebuchet MS', value: 'Trebuchet MS' },
  // Modern fonts (require Google Fonts or system availability)
  { label: 'Inter', value: 'Inter' },
  { label: 'Roboto', value: 'Roboto' },
  { label: 'Open Sans', value: 'Open Sans' },
  { label: 'Lato', value: 'Lato' },
  { label: 'Montserrat', value: 'Montserrat' },
];

/**
 * Font size options
 */
const FONT_SIZES = [
  { label: '8', value: '8px' },
  { label: '10', value: '10px' },
  { label: '11', value: '11px' },
  { label: '12', value: '12px' },
  { label: '14', value: '14px' },
  { label: '16', value: '16px' },
  { label: '18', value: '18px' },
  { label: '20', value: '20px' },
  { label: '24', value: '24px' },
  { label: '28', value: '28px' },
  { label: '32', value: '32px' },
  { label: '36', value: '36px' },
  { label: '48', value: '48px' },
  { label: '72', value: '72px' },
];

/**
 * Text color options for the color picker
 */
const TEXT_COLORS = [
  { label: 'Black', value: '#000000' },
  { label: 'Dark Gray', value: '#4B5563' },
  { label: 'Gray', value: '#9CA3AF' },
  { label: 'Red', value: '#EF4444' },
  { label: 'Orange', value: '#F97316' },
  { label: 'Amber', value: '#EFBF04' },
  { label: 'Yellow', value: '#EAB308' },
  { label: 'Lime', value: '#84CC16' },
  { label: 'Green', value: '#22C55E' },
  { label: 'Emerald', value: '#10B981' },
  { label: 'Teal', value: '#14B8A6' },
  { label: 'Cyan', value: '#06B6D4' },
  { label: 'Blue', value: '#3B82F6' },
  { label: 'Indigo', value: '#6366F1' },
  { label: 'Violet', value: '#8B5CF6' },
  { label: 'Purple', value: '#A855F7' },
  { label: 'Fuchsia', value: '#D946EF' },
  { label: 'Pink', value: '#EC4899' },
  { label: 'Rose', value: '#F43F5E' },
  { label: 'Brown', value: '#92400E' },
];

/**
 * Highlight/background color options
 */
const HIGHLIGHT_COLORS = [
  { label: 'Yellow', value: '#FEF08A' },
  { label: 'Lime', value: '#D9F99D' },
  { label: 'Green', value: '#BBF7D0' },
  { label: 'Cyan', value: '#A5F3FC' },
  { label: 'Blue', value: '#BFDBFE' },
  { label: 'Purple', value: '#DDD6FE' },
  { label: 'Pink', value: '#FBCFE8' },
  { label: 'Rose', value: '#FECDD3' },
  { label: 'Orange', value: '#FED7AA' },
  { label: 'Gray', value: '#E5E7EB' },
];

/**
 * Font family dropdown component
 */
function FontFamilyDropdown({ editor }: { editor: Editor | null }) {
  const [isOpen, setIsOpen] = useState(false);

  if (!editor) return null;

  // Get current font family from editor attributes
  const currentFontFamily = editor.getAttributes('textStyle').fontFamily || '';
  const currentLabel = FONT_FAMILIES.find(f => f.value === currentFontFamily)?.label || 'Font';

  const handleSetFont = (fontFamily: string) => {
    if (fontFamily === '') {
      // Unset font family to use default
      editor.chain().focus().unsetFontFamily().run();
    } else {
      editor.chain().focus().setFontFamily(fontFamily).run();
    }
    setIsOpen(false);
  };

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={cn(
          'px-2 h-8 rounded-md',
          'flex items-center gap-1',
          'text-sm text-apple-text-dark',
          'hover:bg-apple-gray-bg',
          'transition-colors duration-150',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          'min-w-[120px] max-w-[150px]'
        )}
        title="Font Family"
      >
        <span className="truncate flex-1 text-left">{currentLabel}</span>
        <ChevronDown className="w-3 h-3 flex-shrink-0" />
      </button>

      {isOpen && (
        <>
          {/* Backdrop */}
          <div
            className="fixed inset-0 z-10"
            onClick={() => setIsOpen(false)}
          />

          {/* Dropdown menu */}
          <div className="absolute top-full left-0 mt-1 z-20 bg-white rounded-lg shadow-lg border border-gray-200 py-1 min-w-[180px] max-h-[300px] overflow-y-auto">
            {FONT_FAMILIES.map((font) => (
              <button
                key={font.label}
                onClick={() => handleSetFont(font.value)}
                className={cn(
                  'w-full px-4 py-2 text-left text-sm',
                  'hover:bg-apple-gray-bg',
                  'transition-colors duration-150',
                  currentFontFamily === font.value
                    ? 'bg-apple-blue/10 text-apple-blue font-medium'
                    : 'text-apple-text-dark'
                )}
                style={{ fontFamily: font.value || 'inherit' }}
              >
                {font.label}
              </button>
            ))}
          </div>
        </>
      )}
    </div>
  );
}

/**
 * Font size dropdown component
 */
function FontSizeDropdown({ editor }: { editor: Editor | null }) {
  const [isOpen, setIsOpen] = useState(false);

  if (!editor) return null;

  // Get current font size from editor attributes
  const currentFontSize = editor.getAttributes('textStyle').fontSize || '';
  const currentLabel = FONT_SIZES.find(s => s.value === currentFontSize)?.label || '16';

  const handleSetSize = (size: string) => {
    if (size === '16px') {
      // 16px is the default, so unset to use default
      editor.chain().focus().unsetFontSize().run();
    } else {
      editor.chain().focus().setFontSize(size).run();
    }
    setIsOpen(false);
  };

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={cn(
          'px-2 h-8 rounded-md',
          'flex items-center gap-1',
          'text-sm text-apple-text-dark',
          'hover:bg-apple-gray-bg',
          'transition-colors duration-150',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          'min-w-[60px] max-w-[80px]'
        )}
        title="Font Size"
      >
        <span className="truncate flex-1 text-left">{currentLabel}</span>
        <ChevronDown className="w-3 h-3 flex-shrink-0" />
      </button>

      {isOpen && (
        <>
          {/* Backdrop */}
          <div
            className="fixed inset-0 z-10"
            onClick={() => setIsOpen(false)}
          />

          {/* Dropdown menu */}
          <div className="absolute top-full left-0 mt-1 z-20 bg-white rounded-lg shadow-lg border border-gray-200 py-1 min-w-[80px] max-h-[300px] overflow-y-auto">
            {FONT_SIZES.map((size) => (
              <button
                key={size.value}
                onClick={() => handleSetSize(size.value)}
                className={cn(
                  'w-full px-4 py-2 text-left text-sm',
                  'hover:bg-apple-gray-bg',
                  'transition-colors duration-150',
                  currentFontSize === size.value
                    ? 'bg-apple-blue/10 text-apple-blue font-medium'
                    : 'text-apple-text-dark'
                )}
              >
                {size.label}
              </button>
            ))}
          </div>
        </>
      )}
    </div>
  );
}

/**
 * Text color picker dropdown component
 */
function TextColorDropdown({ editor }: { editor: Editor | null }) {
  const [isOpen, setIsOpen] = useState(false);

  if (!editor) return null;

  // Get current text color from editor attributes
  const currentColor = editor.getAttributes('textStyle').color || '#000000';

  const handleSetColor = (color: string) => {
    if (color === '#000000') {
      // Black is default, unset to use default
      editor.chain().focus().unsetColor().run();
    } else {
      editor.chain().focus().setColor(color).run();
    }
    setIsOpen(false);
    // Use setTimeout to ensure dropdown closes before clearing selection
    setTimeout(() => {
      editor.commands.blur();
    }, 50);
  };

  const handleRemoveColor = () => {
    editor.chain().focus().unsetColor().run();
    setIsOpen(false);
    setTimeout(() => {
      editor.commands.blur();
    }, 50);
  };

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={cn(
          'w-8 h-8 rounded-md',
          'flex items-center justify-center',
          'hover:bg-apple-gray-bg',
          'transition-colors duration-150',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          'relative'
        )}
        title="Text Color"
      >
        <Paintbrush className="w-4 h-4 text-apple-text-dark" />
        {/* Color indicator bar */}
        <div
          className="absolute bottom-1 left-1.5 right-1.5 h-0.5 rounded-full"
          style={{ backgroundColor: currentColor }}
        />
      </button>

      {isOpen && (
        <>
          {/* Backdrop */}
          <div
            className="fixed inset-0 z-10"
            onClick={() => setIsOpen(false)}
          />

          {/* Color palette dropdown */}
          <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1 z-20 bg-white rounded-lg shadow-lg border border-gray-200 p-2 w-[180px]">
            <div className="text-xs text-gray-500 mb-2 px-1">Text Color</div>
            
            {/* Color grid */}
            <div className="grid grid-cols-5 gap-1 mb-2">
              {TEXT_COLORS.map((color) => (
                <button
                  key={color.value}
                  onClick={() => handleSetColor(color.value)}
                  className={cn(
                    'w-7 h-7 rounded-md',
                    'transition-all duration-150',
                    'hover:scale-110',
                    'focus:outline-none focus:ring-2 focus:ring-apple-blue',
                    currentColor === color.value && 'ring-2 ring-apple-blue ring-offset-1'
                  )}
                  style={{ backgroundColor: color.value }}
                  title={color.label}
                />
              ))}
            </div>

            {/* Remove color button */}
            <button
              onClick={handleRemoveColor}
              className={cn(
                'w-full px-2 py-1.5 rounded-md',
                'text-xs text-apple-text-dark',
                'hover:bg-apple-gray-bg',
                'transition-colors duration-150',
                'flex items-center justify-center gap-1'
              )}
            >
              <X className="w-3 h-3" />
              <span>Remove Color</span>
            </button>
          </div>
        </>
      )}
    </div>
  );
}

/**
 * Highlight/background color picker dropdown component
 */
function HighlightColorDropdown({ editor }: { editor: Editor | null }) {
  const [isOpen, setIsOpen] = useState(false);

  if (!editor) return null;

  // Get current highlight color from editor
  const highlightAttrs = editor.getAttributes('highlight');
  const currentHighlight = highlightAttrs?.color || null;

  const handleSetHighlight = (color: string) => {
    editor.chain().focus().setHighlight({ color }).run();
    setIsOpen(false);
    // Use setTimeout to ensure dropdown closes before clearing selection
    setTimeout(() => {
      editor.commands.blur();
    }, 50);
  };

  const handleRemoveHighlight = () => {
    editor.chain().focus().unsetHighlight().run();
    setIsOpen(false);
    setTimeout(() => {
      editor.commands.blur();
    }, 50);
  };

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={cn(
          'w-8 h-8 rounded-md',
          'flex items-center justify-center',
          'hover:bg-apple-gray-bg',
          'transition-colors duration-150',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
          'relative'
        )}
        title="Highlight Color"
      >
        <Highlighter className="w-4 h-4 text-apple-text-dark" />
        {/* Highlight indicator bar */}
        {currentHighlight && (
          <div
            className="absolute bottom-1 left-1.5 right-1.5 h-0.5 rounded-full"
            style={{ backgroundColor: currentHighlight }}
          />
        )}
      </button>

      {isOpen && (
        <>
          {/* Backdrop */}
          <div
            className="fixed inset-0 z-10"
            onClick={() => setIsOpen(false)}
          />

          {/* Highlight palette dropdown */}
          <div className="absolute top-full left-1/2 -translate-x-1/2 mt-1 z-20 bg-white rounded-lg shadow-lg border border-gray-200 p-2 w-[180px]">
            <div className="text-xs text-gray-500 mb-2 px-1">Highlight Color</div>
            
            {/* Color grid */}
            <div className="grid grid-cols-5 gap-1 mb-2">
              {HIGHLIGHT_COLORS.map((color) => (
                <button
                  key={color.value}
                  onClick={() => handleSetHighlight(color.value)}
                  className={cn(
                    'w-7 h-7 rounded-md border border-gray-200',
                    'transition-all duration-150',
                    'hover:scale-110',
                    'focus:outline-none focus:ring-2 focus:ring-apple-blue',
                    currentHighlight === color.value && 'ring-2 ring-apple-blue ring-offset-1'
                  )}
                  style={{ backgroundColor: color.value }}
                  title={color.label}
                />
              ))}
            </div>

            {/* Remove highlight button */}
            <button
              onClick={handleRemoveHighlight}
              className={cn(
                'w-full px-2 py-1.5 rounded-md',
                'text-xs text-apple-text-dark',
                'hover:bg-apple-gray-bg',
                'transition-colors duration-150',
                'flex items-center justify-center gap-1'
              )}
            >
              <X className="w-3 h-3" />
              <span>Remove Highlight</span>
            </button>
          </div>
        </>
      )}
    </div>
  );
}

/**
 * Text style dropdown component
 */
function TextStyleDropdown({ editor }: { editor: Editor | null }) {
  const [isOpen, setIsOpen] = useState(false);

  if (!editor) return null;

  const currentStyle = editor.isActive('heading', { level: 1 })
    ? 'Heading 1'
    : editor.isActive('heading', { level: 2 })
    ? 'Heading 2'
    : editor.isActive('heading', { level: 3 })
    ? 'Heading 3'
    : 'Paragraph';

  const styles = [
    {
      label: 'Paragraph',
      action: () => editor.chain().focus().setParagraph().run(),
    },
    {
      label: 'Heading 1',
      action: () => editor.chain().focus().toggleHeading({ level: 1 }).run(),
    },
    {
      label: 'Heading 2',
      action: () => editor.chain().focus().toggleHeading({ level: 2 }).run(),
    },
    {
      label: 'Heading 3',
      action: () => editor.chain().focus().toggleHeading({ level: 3 }).run(),
    },
  ];

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className={cn(
          'px-3 h-8 rounded-md',
          'flex items-center gap-2',
          'text-sm font-medium text-apple-text-dark',
          'hover:bg-apple-gray-bg',
          'transition-colors duration-150',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2'
        )}
      >
        <span>{currentStyle}</span>
        <ChevronDown className="w-4 h-4" />
      </button>

      {isOpen && (
        <>
          {/* Backdrop */}
          <div
            className="fixed inset-0 z-10"
            onClick={() => setIsOpen(false)}
          />

          {/* Dropdown menu */}
          <div className="absolute top-full left-0 mt-1 z-20 bg-white rounded-lg shadow-lg border border-gray-200 py-1 min-w-[140px]">
            {styles.map((style) => (
              <button
                key={style.label}
                onClick={() => {
                  style.action();
                  setIsOpen(false);
                }}
                className={cn(
                  'w-full px-4 py-2 text-left text-sm',
                  'hover:bg-apple-gray-bg',
                  'transition-colors duration-150',
                  currentStyle === style.label
                    ? 'bg-apple-blue/10 text-apple-blue font-medium'
                    : 'text-apple-text-dark'
                )}
              >
                {style.label}
              </button>
            ))}
          </div>
        </>
      )}
    </div>
  );
}

/**
 * Document menu dropdown component
 * Handles import, export, and print operations
 */
function DocumentMenu({ 
  editor, 
  documentTitle,
  activeProjectId,
  activeDocumentId,
  onTitleUpdate,
}: { 
  editor: Editor | null; 
  documentTitle?: string;
  activeProjectId: string | null;
  activeDocumentId: string | null;
  onTitleUpdate: (newTitle: string) => void;
}) {
  const [isOpen, setIsOpen] = useState(false);
  const [showImportSubmenu, setShowImportSubmenu] = useState(false);
  const [showExportSubmenu, setShowExportSubmenu] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [exportMessage, setExportMessage] = useState<{ type: 'success' | 'error'; text: string } | null>(null);
  const [showOverwriteModal, setShowOverwriteModal] = useState(false);
  const [pendingImportType, setPendingImportType] = useState<'txt' | 'md' | 'docx' | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const menuContainerRef = useRef<HTMLDivElement>(null);

  // Clear export message after a delay
  useEffect(() => {
    if (exportMessage) {
      const timer = setTimeout(() => {
        setExportMessage(null);
      }, 3000);
      return () => clearTimeout(timer);
    }
  }, [exportMessage]);

  // Close menu and submenus
  const closeMenu = useCallback(() => {
    setIsOpen(false);
    setShowImportSubmenu(false);
    setShowExportSubmenu(false);
  }, []);

  // Handle ESC key and click outside to close menu
  useEffect(() => {
    if (!isOpen) return;

    const handleClickOutside = (event: MouseEvent) => {
      if (menuContainerRef.current && !menuContainerRef.current.contains(event.target as Node)) {
        closeMenu();
      }
    };

    const handleEscapeKey = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        closeMenu();
      }
    };

    // Add listeners after a small delay to prevent immediate closure
    // Increased from 0ms to 100ms to ensure click event finishes propagating
    const timeoutId = setTimeout(() => {
      document.addEventListener('mousedown', handleClickOutside);
      document.addEventListener('keydown', handleEscapeKey);
    }, 100);

    // Cleanup event listeners
    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('keydown', handleEscapeKey);
    };
  }, [isOpen, closeMenu]);

  // Close submenus when main menu closes
  useEffect(() => {
    if (!isOpen) {
      setShowImportSubmenu(false);
      setShowExportSubmenu(false);
    }
  }, [isOpen]);

  /**
   * Check if editor has content (not empty or just whitespace)
   * 
   * @returns true if editor has meaningful content, false if empty
   */
  const hasEditorContent = useCallback((): boolean => {
    if (!editor) return false;
    
    // Get plain text content and check if it's not just whitespace
    const text = editor.getText().trim();
    return text.length > 0;
  }, [editor]);

  /**
   * Handle confirming overwrite - proceed with file import
   */
  const handleConfirmOverwrite = useCallback(() => {
    if (!pendingImportType) return;
    
    // Close modal
    setShowOverwriteModal(false);
    
    // Proceed with import
    triggerFileInput(pendingImportType);
    
    // Clear pending import type
    setPendingImportType(null);
  }, [pendingImportType]);

  /**
   * Handle canceling overwrite - abort import
   */
  const handleCancelOverwrite = useCallback(() => {
    setShowOverwriteModal(false);
    setPendingImportType(null);
  }, []);

  /**
   * Trigger file input for import
   * 
   * @param fileType - Type of file to import
   */
  const triggerFileInput = (fileType: 'txt' | 'md' | 'docx') => {
    // Store the file type so we can validate it when file is selected
    fileInputRef.current?.setAttribute('data-import-type', fileType);
    
    // Set accept attribute based on file type
    if (fileInputRef.current) {
      switch (fileType) {
        case 'txt':
          fileInputRef.current.accept = '.txt,text/plain';
          break;
        case 'md':
          fileInputRef.current.accept = '.md,text/markdown';
          break;
        case 'docx':
          fileInputRef.current.accept = '.docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document';
          break;
      }
    }
    
    // Trigger file input
    fileInputRef.current?.click();
    closeMenu();
  };

  // Handle import file selection - check for content first
  const handleImportClick = (fileType: 'txt' | 'md' | 'docx') => {
    // Check if editor has content
    if (hasEditorContent()) {
      // Show overwrite confirmation modal
      setPendingImportType(fileType);
      setShowOverwriteModal(true);
      closeMenu();
    } else {
      // No content, proceed directly with import
      triggerFileInput(fileType);
    }
  };

  /**
   * Extract filename without extension
   * Handles edge cases like multiple dots and no extension
   * 
   * @param filename - Full filename with extension
   * @returns Filename without extension
   * @example
   * extractFilenameWithoutExtension('Marketing Brief.docx') => 'Marketing Brief'
   * extractFilenameWithoutExtension('report.v2.final.txt') => 'report.v2.final'
   * extractFilenameWithoutExtension('readme') => 'readme'
   */
  const extractFilenameWithoutExtension = (filename: string): string => {
    const lastDotIndex = filename.lastIndexOf('.');
    if (lastDotIndex === -1) {
      // No extension found, return full filename
      return filename;
    }
    // Return everything before the last dot
    return filename.substring(0, lastDotIndex);
  };

  // Handle file import after file is selected
  const handleFileImport = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file || !editor) {
      return;
    }

    try {
      setIsExporting(true);
      setExportMessage(null);

      // Import the file dynamically
      const { importDocument } = await import('@/lib/utils/document-import');
      
      const result = await importDocument(editor, file);
      
      if (result.success) {
        // Extract filename without extension
        const newTitle = extractFilenameWithoutExtension(file.name);
        
        // Update document title if we have an active document
        if (activeProjectId && activeDocumentId) {
          try {
            // FIX: Added await to ensure title update completes before continuing
            await updateDocument(activeProjectId, activeDocumentId, {
              title: newTitle,
              baseTitle: newTitle
            });
            
            // Update the Toolbar's local state so title displays immediately
            onTitleUpdate(newTitle);
            
            // Dispatch custom event to notify EditorArea to reload document
            window.dispatchEvent(new CustomEvent('documentUpdated', {
              detail: { projectId: activeProjectId, documentId: activeDocumentId }
            }));
            
            logger.log('‚úÖ Document title updated to:', newTitle);
          } catch (updateError) {
            logger.warn('‚ö†Ô∏è Could not update document title:', updateError);
            // Don't fail the import if title update fails
          }
        }
        
        setExportMessage({ 
          type: 'success', 
          text: `Imported ${file.name}` 
        });
        logger.log('‚úÖ Import successful:', file.name);
      } else {
        setExportMessage({ 
          type: 'error', 
          text: result.error || 'Import failed' 
        });
        logger.error('‚ùå Import failed:', result.error);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Import failed';
      setExportMessage({ type: 'error', text: errorMessage });
      logger.error('‚ùå Import error:', error);
    } finally {
      setIsExporting(false);
      // Reset file input so the same file can be imported again
      if (event.target) {
        event.target.value = '';
      }
    }
  };

  // Handle export with proper async handling
  const handleExportClick = async (fileType: 'txt' | 'md' | 'docx') => {
    try {
      if (!editor) {
        setExportMessage({ type: 'error', text: 'No editor available' });
        return;
      }

      // Import export function dynamically to avoid SSR issues
      const { exportDocument } = await import('@/lib/utils/document-export');
      
      setIsExporting(true);
      closeMenu();
      
      const result = await exportDocument(editor, fileType, documentTitle);
      
      if (result.success) {
        setExportMessage({ 
          type: 'success', 
          text: `Exported as ${result.filename}` 
        });
      } else {
        setExportMessage({ 
          type: 'error', 
          text: result.error || 'Export failed' 
        });
        logger.error('‚ùå Export failed:', result.error);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Export failed';
      setExportMessage({ type: 'error', text: errorMessage });
      logger.error('‚ùå Export error:', error);
    } finally {
      setIsExporting(false);
    }
  };

  // Handle print
  const handlePrintClick = () => {
    // Import print utility dynamically to avoid SSR issues
    import('@/lib/utils/pdf-export').then(({ printWithTitle }) => {
      printWithTitle(documentTitle);
    });
    closeMenu();
  };

  return (
    <div ref={menuContainerRef} className="relative z-[200]">
      <button
        onClick={(e) => {
          e.stopPropagation();
          console.log('Document button clicked, isOpen:', isOpen);
          setIsOpen(!isOpen);
        }}
        className={cn(
          'px-3 py-2 rounded-lg',
          'flex items-center gap-2',
          'text-sm font-medium text-apple-text-dark',
          'hover:bg-apple-gray-bg',
          'transition-colors duration-150',
          'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2'
        )}
        title="Document Menu"
      >
        <FileText className="w-4 h-4" />
        <span className="hidden sm:inline">Document</span>
        <ChevronDown className="w-3 h-3" />
      </button>

      {isOpen && (
        <>
          {/* Dropdown menu */}
          <div className="absolute top-full left-0 mt-1 z-[100] bg-white rounded-lg shadow-lg border border-gray-200 py-1 min-w-[220px] overflow-visible">
            {/* Import Document */}
            <div className="relative">
              <button
                onClick={() => setShowImportSubmenu(!showImportSubmenu)}
                onMouseEnter={() => setShowImportSubmenu(true)}
                className={cn(
                  'w-full px-4 py-2 text-left text-sm',
                  'hover:text-apple-blue',
                  'transition-colors duration-150',
                  'text-apple-text-dark',
                  'flex items-center justify-between'
                )}
              >
                <span className="flex items-center gap-2">
                  <FileUp className="w-4 h-4" />
                  Import Document
                </span>
                <ChevronRight className="w-3 h-3" />
              </button>

              {/* Import Submenu */}
              {showImportSubmenu && (
                <div className="absolute left-full top-0 ml-1 z-[110] bg-white rounded-lg shadow-lg border border-gray-200 py-1 min-w-[180px]">
                  <button
                    onClick={() => handleImportClick('docx')}
                    className={cn(
                      'w-full px-4 py-2 text-left text-sm',
                      'hover:text-apple-blue',
                      'transition-colors duration-150',
                      'text-apple-text-dark'
                    )}
                  >
                    Word Document (.docx)
                  </button>
                  <button
                    onClick={() => handleImportClick('txt')}
                    className={cn(
                      'w-full px-4 py-2 text-left text-sm',
                      'hover:text-apple-blue',
                      'transition-colors duration-150',
                      'text-apple-text-dark'
                    )}
                  >
                    Plain Text (.txt)
                  </button>
                  <button
                    onClick={() => handleImportClick('md')}
                    className={cn(
                      'w-full px-4 py-2 text-left text-sm',
                      'hover:text-apple-blue',
                      'transition-colors duration-150',
                      'text-apple-text-dark'
                    )}
                  >
                    Markdown (.md)
                  </button>
                </div>
              )}
            </div>

            {/* Export Document */}
            <div className="relative">
              <button
                onClick={() => setShowExportSubmenu(!showExportSubmenu)}
                onMouseEnter={() => setShowExportSubmenu(true)}
                className={cn(
                  'w-full px-4 py-2 text-left text-sm',
                  'hover:text-apple-blue',
                  'transition-colors duration-150',
                  'text-apple-text-dark',
                  'flex items-center justify-between'
                )}
              >
                <span className="flex items-center gap-2">
                  <FileDown className="w-4 h-4" />
                  Export Document
                </span>
                <ChevronRight className="w-3 h-3" />
              </button>

              {/* Export Submenu */}
              {showExportSubmenu && (
                <div className="absolute left-full top-0 ml-1 z-[110] bg-white rounded-lg shadow-lg border border-gray-200 py-1 min-w-[180px]">
                  <button
                    onClick={() => handleExportClick('docx')}
                    disabled={isExporting || !editor}
                    className={cn(
                      'w-full px-4 py-2 text-left text-sm',
                      'transition-colors duration-150',
                      'text-apple-text-dark',
                      'disabled:opacity-50 disabled:cursor-not-allowed',
                      'hover:text-apple-blue disabled:hover:text-apple-text-dark'
                    )}
                  >
                    Word Document (.docx)
                  </button>
                  <button
                    onClick={() => handleExportClick('txt')}
                    disabled={isExporting || !editor}
                    className={cn(
                      'w-full px-4 py-2 text-left text-sm',
                      'transition-colors duration-150',
                      'text-apple-text-dark',
                      'disabled:opacity-50 disabled:cursor-not-allowed',
                      'hover:text-apple-blue disabled:hover:text-apple-text-dark'
                    )}
                  >
                    Plain Text (.txt)
                  </button>
                  <button
                    onClick={() => handleExportClick('md')}
                    disabled={isExporting || !editor}
                    className={cn(
                      'w-full px-4 py-2 text-left text-sm',
                      'transition-colors duration-150',
                      'text-apple-text-dark',
                      'disabled:opacity-50 disabled:cursor-not-allowed',
                      'hover:text-apple-blue disabled:hover:text-apple-text-dark'
                    )}
                  >
                    Markdown (.md)
                  </button>
                </div>
              )}
            </div>

            {/* Divider */}
            <div className="my-1 border-t border-gray-200" />

            {/* Export PDF */}
            <button
              onClick={handlePrintClick}
              onMouseEnter={() => {
                // Close any open submenus when hovering over Export PDF
                setShowExportSubmenu(false);
                setShowImportSubmenu(false);
              }}
              className={cn(
                'w-full px-4 py-2 text-left text-sm',
                'hover:text-apple-blue',
                'transition-colors duration-150',
                'text-apple-text-dark',
                'flex items-center justify-between'
              )}
            >
              <span className="flex items-center gap-2">
                <Printer className="w-4 h-4" />
                Export PDF
              </span>
              <span className="text-xs text-gray-400">‚åòP</span>
            </button>
          </div>
        </>
      )}

      {/* Hidden file input for importing */}
      <input
        ref={fileInputRef}
        type="file"
        accept=".docx,.txt,.md"
        className="hidden"
        onChange={handleFileImport}
      />

      {/* Import/Export Loading Indicator */}
      {isExporting && (
        <div className="fixed top-20 right-6 z-50 flex items-center gap-2 bg-white px-4 py-2 rounded-lg shadow-lg border border-gray-200">
          <div className="w-4 h-4 border-2 border-apple-blue border-t-transparent rounded-full animate-spin" />
          <span className="text-sm text-apple-text-dark">Processing...</span>
        </div>
      )}

      {/* Import/Export Message Toast */}
      {exportMessage && (
        <div 
          className={cn(
            'fixed top-20 right-6 z-50 px-4 py-2 rounded-lg shadow-lg border',
            'flex items-center gap-2 animate-in fade-in slide-in-from-top-2 duration-200',
            exportMessage.type === 'success' 
              ? 'bg-green-50 border-green-200 text-green-800' 
              : 'bg-red-50 border-red-200 text-red-800'
          )}
        >
          {exportMessage.type === 'success' ? (
            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
            </svg>
          ) : (
            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          )}
          <span className="text-sm">{exportMessage.text}</span>
        </div>
      )}

      {/* Overwrite Confirmation Modal */}
      <ConfirmationModal
        isOpen={showOverwriteModal}
        title="Overwrite Current Document?"
        message={`Importing will replace all content in '${documentTitle || 'this document'}'. This action cannot be undone.`}
        confirmLabel="Import Anyway"
        cancelLabel="Cancel"
        onClose={handleCancelOverwrite}
        onConfirm={handleConfirmOverwrite}
        isDestructive={false}
      />
    </div>
  );
}

/**
 * Top toolbar component with file menu and formatting controls
 */
export function Toolbar({ className, onRestartTour }: ToolbarProps) {
  // Optimized selectors
  const activeDocumentId = useActiveDocumentId();
  const activeProjectId = useActiveProjectId();
  const { toggleRightSidebar, setViewMode } = useUIActions();
  const viewMode = useViewMode();
  
  // Check if we have an active document
  const hasActiveDocument = !!activeDocumentId;

  const [editor, setEditor] = useState<Editor | null>(null);
  const [documentTitle, setDocumentTitle] = useState<string | undefined>(undefined);
  // Force re-render counter for editor state updates (undo/redo availability)
  const [, forceUpdate] = useState(0);
  
  // Scroll indicator states
  const [isScrolledLeft, setIsScrolledLeft] = useState(false);
  const [isScrolledRight, setIsScrolledRight] = useState(false);
  const headerRef = useRef<HTMLElement>(null);

  // Get editor instance from window (set by EditorArea)
  useEffect(() => {
    const interval = setInterval(() => {
      if (typeof window !== 'undefined' && window.__tiptapEditor) {
        setEditor(window.__tiptapEditor);
        clearInterval(interval);
      }
    }, 100);

    return () => clearInterval(interval);
  }, []);

  // Subscribe to editor transactions to update undo/redo button states
  useEffect(() => {
    if (!editor) return;

    // This handler triggers re-render when editor state changes
    // so that can().undo() and can().redo() are re-evaluated
    const handleUpdate = () => {
      forceUpdate(n => n + 1);
    };

    editor.on('transaction', handleUpdate);

    return () => {
      editor.off('transaction', handleUpdate);
    };
  }, [editor]);

  // Get document title from localStorage when document changes
  useEffect(() => {
    // Safety check: only run in browser
    if (typeof window === 'undefined') return;
    
    const loadDocumentTitle = async () => {
      try {
        if (activeProjectId && activeDocumentId) {
          const document = await getDocument(activeProjectId, activeDocumentId);
          if (document) {
            // Use baseTitle for cleaner filename (without version suffix)
            setDocumentTitle(document.baseTitle || document.title);
          } else {
            setDocumentTitle(undefined);
          }
        } else {
          setDocumentTitle(undefined);
        }
      } catch (error) {
        logger.error('Error getting document title:', error);
        setDocumentTitle(undefined);
      }
    };
    
    loadDocumentTitle();
  }, [activeProjectId, activeDocumentId]);

  // Scroll indicator detection
  useEffect(() => {
    const header = headerRef.current;
    if (!header) return;

    const updateScrollIndicators = () => {
      const { scrollLeft, scrollWidth, clientWidth } = header;
      
      // Show left fade when scrolled away from left edge
      setIsScrolledLeft(scrollLeft > 0);
      
      // Show right fade when there's more content to scroll to
      // Add 1px tolerance to handle subpixel rendering issues
      setIsScrolledRight(scrollLeft < scrollWidth - clientWidth - 1);
    };

    // Check on mount
    updateScrollIndicators();

    // Listen for scroll events
    header.addEventListener('scroll', updateScrollIndicators);

    // Listen for window resize (affects clientWidth)
    window.addEventListener('resize', updateScrollIndicators);

    // Cleanup
    return () => {
      header.removeEventListener('scroll', updateScrollIndicators);
      window.removeEventListener('resize', updateScrollIndicators);
    };
  }, []);


  // Insert link handler
  const handleInsertLink = (): void => {
    if (!editor) return;

    const url = window.prompt('Enter URL:');
    if (url) {
      editor
        .chain()
        .focus()
        .extendMarkRange('link')
        .setLink({ href: url })
        .run();
    }
  };

  return (
    <div 
      className={cn(
        'relative w-full h-16',
        'sticky top-0 z-50',
        className
      )}
      data-print-hide
    >
      <header
        ref={headerRef}
        className={cn(
          'w-full bg-white',
          'px-6',
          'border-b border-gray-200',
          'transition-all duration-300',
          'h-16',
          // Horizontal scrolling support - removed overflow to allow dropdown
          // 'overflow-x-auto',
          'scrollbar-hide' // Hide scrollbar while keeping scroll functionality
        )}
        style={{
          backdropFilter: 'blur(10px)',
          backgroundColor: 'rgba(255, 255, 255, 0.98)',
          scrollBehavior: 'smooth', // Smooth scrolling
        }}
      >
      {/* Inner wrapper - forces horizontal scroll on small screens */}
      <div className={cn(
        'flex items-center justify-between',
        'gap-2 sm:gap-4 lg:gap-8',
        'min-w-[1400px]',
        'w-full',
        'h-full'
      )}>
        {/* Left section - File operations */}
        <div className={cn(
          'flex items-center gap-1.5 sm:gap-2 transition-all duration-300',
          'flex-shrink-0' // Prevent shrinking on small screens
        )}>
        <Link href="/home">
          <button
            className={cn(
              'px-3 py-2 rounded-lg',
              'text-sm font-medium text-apple-text-dark',
              'hover:bg-apple-gray-bg',
              'transition-colors duration-150',
              'flex items-center gap-2',
              'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2'
            )}
            title="Back to App Home"
          >
            <FolderOpen className="w-4 h-4" />
            <span className="hidden sm:inline">Home</span>
          </button>
        </Link>

        <DocumentMenu 
          editor={editor} 
          documentTitle={documentTitle}
          activeProjectId={activeProjectId}
          activeDocumentId={activeDocumentId}
          onTitleUpdate={setDocumentTitle}
        />

        <div className="w-px h-6 bg-gray-200 mx-1" />

        <button
          onClick={() => editor?.chain().focus().undo().run()}
          disabled={!editor?.can().undo()}
          className={cn(
            'p-2 rounded-lg',
            'text-apple-text-dark hover:bg-apple-gray-bg',
            'transition-colors duration-150',
            'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
            'disabled:opacity-30 disabled:cursor-not-allowed'
          )}
          title="Undo (‚åòZ)"
        >
          <Undo className="w-4 h-4" />
        </button>

        <button
          onClick={() => editor?.chain().focus().redo().run()}
          disabled={!editor?.can().redo()}
          className={cn(
            'p-2 rounded-lg',
            'text-apple-text-dark hover:bg-apple-gray-bg',
            'transition-colors duration-150',
            'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-offset-2',
            'disabled:opacity-30 disabled:cursor-not-allowed'
          )}
          title="Redo (‚åò‚áßZ)"
        >
          <Redo className="w-4 h-4" />
        </button>
      </div>

      {/* Center section - Formatting controls */}
      <div className={cn(
        'flex-1 flex items-center justify-center gap-0.5 sm:gap-1 transition-all duration-300',
        'min-w-0', // Allow shrinking but maintain space for content
        'overflow-hidden' // Prevent overflow from pushing other sections
      )}>
        {hasActiveDocument && editor ? (
          <>
            {/* Font controls - placed at LEFT */}
            <FontFamilyDropdown editor={editor} />
            <FontSizeDropdown editor={editor} />

            <div className="w-px h-6 bg-gray-200 mx-2" />

            {/* Text style dropdown */}
            <TextStyleDropdown editor={editor} />

            <div className="w-px h-6 bg-gray-200 mx-2" />

            {/* Text Color */}
            <TextColorDropdown editor={editor} />

            {/* Highlight Color */}
            <HighlightColorDropdown editor={editor} />

            <div className="w-px h-6 bg-gray-200 mx-2" />

            {/* Bold */}
            <FormatButton
              icon={<Bold className="w-4 h-4" />}
              title="Bold (‚åòB)"
              onClick={() => editor.chain().focus().toggleBold().run()}
              isActive={editor.isActive('bold')}
            />

            {/* Italic */}
            <FormatButton
              icon={<Italic className="w-4 h-4" />}
              title="Italic (‚åòI)"
              onClick={() => editor.chain().focus().toggleItalic().run()}
              isActive={editor.isActive('italic')}
            />

            {/* Underline */}
            <FormatButton
              icon={<UnderlineIcon className="w-4 h-4" />}
              title="Underline (‚åòU)"
              onClick={() => editor.chain().focus().toggleUnderline().run()}
              isActive={editor.isActive('underline')}
            />

            <div className="w-px h-6 bg-gray-200 mx-2" />

            {/* Bullet list */}
            <FormatButton
              icon={<List className="w-4 h-4" />}
              title="Bullet List"
              onClick={() => editor.chain().focus().toggleBulletList().run()}
              isActive={editor.isActive('bulletList')}
            />

            {/* Numbered list */}
            <FormatButton
              icon={<ListOrdered className="w-4 h-4" />}
              title="Numbered List"
              onClick={() => editor.chain().focus().toggleOrderedList().run()}
              isActive={editor.isActive('orderedList')}
            />

            <div className="w-px h-6 bg-gray-200 mx-2" />

            {/* Align left */}
            <FormatButton
              icon={<AlignLeft className="w-4 h-4" />}
              title="Align Left"
              onClick={() =>
                editor.chain().focus().setTextAlign('left').run()
              }
              isActive={editor.isActive({ textAlign: 'left' })}
            />

            {/* Align center */}
            <FormatButton
              icon={<AlignCenter className="w-4 h-4" />}
              title="Align Center"
              onClick={() =>
                editor.chain().focus().setTextAlign('center').run()
              }
              isActive={editor.isActive({ textAlign: 'center' })}
            />

            {/* Align right */}
            <FormatButton
              icon={<AlignRight className="w-4 h-4" />}
              title="Align Right"
              onClick={() =>
                editor.chain().focus().setTextAlign('right').run()
              }
              isActive={editor.isActive({ textAlign: 'right' })}
            />

            <div className="w-px h-6 bg-gray-200 mx-2" />

            {/* Insert link */}
            <FormatButton
              icon={<LinkIcon className="w-4 h-4" />}
              title="Insert Link (‚åòK)"
              onClick={handleInsertLink}
              isActive={editor.isActive('link')}
            />

            {/* Clear formatting */}
            <FormatButton
              icon={<RemoveFormatting className="w-4 h-4" />}
              title="Clear Formatting"
              onClick={() =>
                editor.chain().focus().clearNodes().unsetAllMarks().run()
              }
            />

            <div className="w-px h-6 bg-gray-200 mx-2" />

            {/* Save as Snippet */}
            <SaveAsSnippetButton variant="toolbar" dataTour="snippets" />
          </>
        ) : (
          <div className="text-sm text-gray-400 flex items-center gap-2">
            <FileText className="w-4 h-4" />
            <span>CopyWorx‚Ñ¢ Studio</span>
          </div>
        )}
      </div>

      {/* Right section - View Mode and Tour Button */}
      <div className={cn(
        'flex items-center gap-2 sm:gap-3',
        'flex-shrink-0', // Prevent shrinking on small screens
        'ml-auto' // Push to right edge
      )}>
        {/* View Mode Selector - Always visible */}
        <ViewModeSelector
          viewMode={viewMode}
          onViewModeChange={setViewMode}
          disabled={!hasActiveDocument}
          documentTitle={documentTitle}
        />
        
        {/* Product Tour Button */}
        <button 
          onClick={onRestartTour}
          className={cn(
            'w-8 h-8 rounded-full',
            'bg-gray-100 hover:bg-[#006EE6] hover:text-white',
            'text-gray-600',
            'flex items-center justify-center',
            'text-lg font-bold',
            'transition-colors duration-200',
            'focus:outline-none focus:ring-2 focus:ring-[#006EE6] focus:ring-offset-2',
            'flex-shrink-0' // Ensure button doesn't shrink
          )}
          title="Take Product Tour"
        >
          ?
        </button>
      </div>
      </div> {/* End inner wrapper */}

        {/* Hide scrollbar CSS while maintaining scroll functionality */}
        <style jsx>{`
          header::-webkit-scrollbar {
            display: none;
          }
          header {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
          }
        `}</style>
      </header>

      {/* Scroll Indicator Fades - positioned outside scrolling header */}
      {isScrolledLeft && (
        <div
          className="absolute left-0 top-0 bottom-0 w-16 pointer-events-none z-10 transition-opacity duration-300"
          style={{
            background: 'linear-gradient(to right, rgba(0, 0, 0, 0.15) 0%, transparent 100%)',
          }}
          aria-hidden="true"
        />
      )}
      
      {isScrolledRight && (
        <div
          className="absolute right-0 top-0 bottom-0 w-16 pointer-events-none z-10 transition-opacity duration-300"
          style={{
            background: 'linear-gradient(to left, rgba(0, 0, 0, 0.15) 0%, transparent 100%)',
          }}
          aria-hidden="true"
        />
      )}
    </div>
  );
}


=== FILE: components/workspace/ViewModeSelector.tsx ===

/**
 * @file components/workspace/ViewModeSelector.tsx
 * @description View mode selector with Export to PDF button
 * 
 * Features:
 * - Two view modes: Scrolling, Focus
 * - Export to PDF button (uses browser print dialog)
 */

'use client';

import React, { useCallback, useState } from 'react';
import { logger } from '@/lib/utils/logger';
import { ArrowUpDown, Focus, FileDown, Loader2 } from 'lucide-react';
import { cn } from '@/lib/utils';
import { toast } from 'sonner';
import type { ViewMode } from '@/lib/types';

interface ViewModeSelectorProps {
  viewMode: ViewMode;
  onViewModeChange: (mode: ViewMode) => void;
  disabled?: boolean;
  className?: string;
  /** Document title for PDF export filename */
  documentTitle?: string;
}

/**
 * View mode configuration
 */
const VIEW_MODES: {
  mode: ViewMode;
  icon: React.ReactNode;
  label: string;
  tooltip: string;
}[] = [
  {
    mode: 'scrolling',
    icon: <ArrowUpDown className="w-4 h-4" />,
    label: 'Scroll',
    tooltip: 'Scrolling Mode - Continuous document view',
  },
  {
    mode: 'focus',
    icon: <Focus className="w-4 h-4" />,
    label: 'Focus',
    tooltip: 'Focus Mode - Distraction-free writing',
  },
];

/**
 * ViewModeSelector with Export to PDF
 */
export function ViewModeSelector({
  viewMode,
  onViewModeChange,
  disabled = false,
  className,
  documentTitle,
}: ViewModeSelectorProps) {
  const [isExporting, setIsExporting] = useState(false);

  /**
   * Export to PDF using browser print dialog
   * User can choose "Save as PDF" in the print dialog
   * Filename will be based on document title
   */
  const handleExportPDF = useCallback(async () => {
    setIsExporting(true);
    
    try {
      // Small delay to show loading state
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // Import and use PDF export utility
      const { printWithTitle } = await import('@/lib/utils/pdf-export');
      printWithTitle(documentTitle);
      
      toast.success('Print dialog opened. Select "Save as PDF" to export.');
    } catch (error) {
      logger.error('Export failed:', error);
      toast.error('Failed to open print dialog');
    } finally {
      setIsExporting(false);
    }
  }, [documentTitle]);

  return (
    <div
      className={cn(
        'inline-flex items-center gap-2',
        disabled && 'opacity-50 pointer-events-none',
        className
      )}
    >
      {/* View Mode Toggle */}
      <div
        className={cn(
          'inline-flex items-center',
          'bg-apple-gray-bg rounded-lg p-0.5',
          'border border-gray-200/50'
        )}
        role="group"
        aria-label="View mode selector"
      >
        {VIEW_MODES.map(({ mode, icon, label, tooltip }) => {
          const isActive = viewMode === mode;
          
          return (
            <button
              key={mode}
              onClick={() => onViewModeChange(mode)}
              disabled={disabled}
              title={tooltip}
              aria-pressed={isActive}
              aria-label={tooltip}
              className={cn(
                'flex items-center gap-1.5',
                'px-2.5 py-1.5 rounded-md',
                'text-xs font-medium',
                'transition-all duration-150',
                'focus:outline-none focus:ring-2 focus:ring-apple-blue focus:ring-inset',
                isActive
                  ? 'bg-white text-apple-text-dark shadow-sm'
                  : 'text-gray-500 hover:text-apple-text-dark hover:bg-gray-100/50'
              )}
            >
              {icon}
              <span className="hidden sm:inline">{label}</span>
            </button>
          );
        })}
      </div>

      {/* Divider */}
      <div className="w-px h-6 bg-gray-200" />

      {/* Export to PDF Button */}
      <button
        onClick={handleExportPDF}
        disabled={disabled || isExporting}
        title="Export to PDF (opens print dialog)"
        aria-label="Export to PDF"
        className={cn(
          'flex items-center gap-1.5',
          'px-3 py-1.5 rounded-lg',
          'text-xs font-medium',
          'bg-gray-600 text-white',
          'hover:bg-gray-700 active:bg-gray-800',
          'transition-all duration-150',
          'focus:outline-none focus:ring-2 focus:ring-gray-400/30',
          'disabled:opacity-50 disabled:cursor-not-allowed'
        )}
      >
        {isExporting ? (
          <Loader2 className="w-4 h-4 animate-spin" />
        ) : (
          <FileDown className="w-4 h-4" />
        )}
        <span className="hidden sm:inline">Export PDF</span>
      </button>
    </div>
  );
}

export default ViewModeSelector;


=== FILE: components/workspace/WorkspaceLayout.tsx ===

/**
 * @file components/workspace/WorkspaceLayout.tsx
 * @description Three-column workspace layout container
 * 
 * Features:
 * - Three-column grid layout
 * - Left sidebar: 280px (tools/templates)
 * - Center: Flexible width (editor)
 * - Right sidebar: 320px (AI analysis)
 * - Handles sidebar collapse/expand
 * - Smooth transitions
 * - Responsive breakpoints
 * - Apple-style aesthetic
 * 
 * @example
 * ```tsx
 * <WorkspaceLayout
 *   leftSidebar={<div>Tools</div>}
 *   rightSidebar={<div>AI Analysis</div>}
 * >
 *   <EditorArea />
 * </WorkspaceLayout>
 * ```
 */

'use client';

import React from 'react';
import { Sidebar } from './Sidebar';
import { Toolbar } from './Toolbar';
import { useLeftSidebarOpen, useRightSidebarOpen, useUIActions, useViewMode } from '@/lib/stores/workspaceStore';
import { cn } from '@/lib/utils';

interface WorkspaceLayoutProps {
  /** Content for left sidebar */
  leftSidebar?: React.ReactNode;
  
  /** Content for right sidebar */
  rightSidebar?: React.ReactNode;
  
  /** Main editor content */
  children: React.ReactNode;
  
  /** Optional CSS classes */
  className?: string;
  
  /** Callback to restart the product tour */
  onRestartTour?: () => void;
}

/**
 * Three-column workspace layout with collapsible sidebars
 */
export function WorkspaceLayout({
  leftSidebar,
  rightSidebar,
  children,
  className,
  onRestartTour,
}: WorkspaceLayoutProps) {
  // Optimized selectors
  const leftSidebarOpen = useLeftSidebarOpen();
  const rightSidebarOpen = useRightSidebarOpen();
  const viewMode = useViewMode();
  const { toggleLeftSidebar, toggleRightSidebar } = useUIActions();

  // In Focus Mode, force close both sidebars but keep them in DOM
  const isFocusMode = viewMode === 'focus';

  return (
    <div 
      className={cn('h-screen w-screen flex flex-col overflow-hidden', className)}
      data-print-layout
    >
      {/* Top toolbar */}
      <Toolbar onRestartTour={onRestartTour} />

      {/* Main workspace area */}
      <div className="flex-1 flex overflow-hidden transition-all duration-300">
        {/* Left sidebar - always rendered but collapsed in Focus Mode */}
        {leftSidebar && (
          <Sidebar
            side="left"
            isOpen={leftSidebarOpen && !isFocusMode}
            onToggle={toggleLeftSidebar}
          >
            {leftSidebar}
          </Sidebar>
        )}

        {/* Center editor area */}
        <main 
          className={cn(
            'flex-1 h-full overflow-hidden transition-all duration-300',
            isFocusMode && 'mx-auto w-full'
          )}
        >
          {children}
        </main>

        {/* Right sidebar - always rendered but collapsed in Focus Mode */}
        {rightSidebar && (
          <Sidebar
            side="right"
            isOpen={rightSidebarOpen && !isFocusMode}
            onToggle={toggleRightSidebar}
          >
            {rightSidebar}
          </Sidebar>
        )}
      </div>
    </div>
  );
}





=== FILE: lib/data/templates.ts ===

/**
 * @file lib/data/templates.ts
 * @description Template definitions for copywriting generation
 * 
 * Contains all available templates with their form fields and AI prompts.
 * To add a new template, simply add it to the ALL_TEMPLATES array.
 */

import { Template, TemplateCategory } from '@/lib/types/template';

/**
 * Sales Email Template
 * Generates persuasive cold outreach sales emails
 */
export const SALES_EMAIL_TEMPLATE: Template = {
  id: 'sales-email',
  name: 'Sales Email',
  category: 'email',
  description: 'Craft a persuasive sales email that addresses pain points and drives conversions.',
  complexity: 'Intermediate',
  estimatedTime: '15-20 min',
  icon: 'DollarSign',
  fields: [
    {
      id: 'productService',
      label: 'Product/Service',
      type: 'textarea',
      placeholder: 'e.g., An AI-powered copywriting tool that generates marketing content in seconds...',
      helperText: 'What are you selling? Include key features and benefits',
      required: true,
      maxLength: 400
    },
    {
      id: 'targetAudience',
      label: 'Target Audience',
      type: 'textarea',
      placeholder: 'e.g., Small business owners who struggle to write marketing content...',
      helperText: 'Who is this email for? Be specific about their situation',
      required: true,
      maxLength: 300
    },
    {
      id: 'painPoints',
      label: 'Pain Points',
      type: 'textarea',
      placeholder: 'e.g., Spending hours writing copy, inconsistent brand voice, writer\'s block...',
      helperText: 'What problems does your audience face? (one per line)',
      required: true,
      maxLength: 400
    },
    {
      id: 'specialOffer',
      label: 'Special Offer',
      type: 'textarea',
      placeholder: 'e.g., 50% off for the first 3 months, plus free onboarding and priority support',
      helperText: 'Any special pricing or bonus to include?',
      required: false,
      maxLength: 150
    },
    {
      id: 'urgencyType',
      label: 'Urgency Type',
      type: 'select',
      helperText: 'What creates urgency to act now?',
      required: true,
      options: [
        'Limited Time Offer',
        'Limited Quantity',
        'Exclusive Access',
        'Price Increase Coming',
        'Seasonal/Event-Based',
        'No Urgency',
        'Other (specify)'
      ]
    },
    {
      id: 'callToAction',
      label: 'Call-to-Action',
      type: 'textarea',
      placeholder: 'e.g., Start Your Free Trial - No Credit Card Required',
      helperText: 'The button or link text (can include supporting text)',
      required: true,
      maxLength: 100
    }
  ],
  systemPrompt: `You are an expert sales copywriter. Create a persuasive cold outreach sales email based on the following details:

Product/Service: {productService}
Target Audience: {targetAudience}
Pain Points: {painPoints}
Special Offer: {specialOffer}
Urgency Type: {urgencyType}
Call-to-Action: {callToAction}

{brandVoiceInstructions}
{personaInstructions}

Write a compelling sales email that:
1. Opens with a hook that addresses their pain point
2. Presents the solution (product/service) with benefits
3. Includes social proof or credibility if relevant
4. Creates urgency to act
5. Ends with a clear call-to-action

Format as a complete email with subject line.`
};

/**
 * Landing Page Hero Template
 * Generates above-the-fold hero section copy
 */
export const LANDING_PAGE_HERO_TEMPLATE: Template = {
  id: 'landing-page-hero',
  name: 'Landing Page Hero',
  category: 'landing-page',
  description: 'Create a powerful above-the-fold hero section that communicates your value proposition.',
  complexity: 'Intermediate',
  estimatedTime: '15-20 min',
  icon: 'Target',
  fields: [
    {
      id: 'productService',
      label: 'Product/Service',
      type: 'textarea',
      placeholder: 'e.g., A project management tool for remote teams with task tracking and video meetings...',
      helperText: 'What are you offering?',
      required: true,
      maxLength: 500
    },
    {
      id: 'targetAudience',
      label: 'Target Audience',
      type: 'textarea',
      placeholder: 'e.g., Remote team leaders at startups frustrated with using multiple tools...',
      helperText: 'Who is this page for?',
      required: true,
      maxLength: 400
    },
    {
      id: 'primaryProblem',
      label: 'Primary Problem',
      type: 'textarea',
      placeholder: 'e.g., Remote teams waste 5+ hours per week switching between tools...',
      helperText: 'The #1 problem you solve',
      required: true,
      maxLength: 300
    },
    {
      id: 'uniqueValueProp',
      label: 'Unique Value Proposition',
      type: 'textarea',
      placeholder: 'e.g., The only platform that combines project management with AI meeting summaries...',
      helperText: 'What makes you different?',
      required: true,
      maxLength: 300
    },
    {
      id: 'socialProof',
      label: 'Social Proof',
      type: 'textarea',
      placeholder: 'e.g., Trusted by 5,000+ remote teams including Shopify and Figma',
      helperText: 'Customer count, logos, or testimonial',
      required: false,
      maxLength: 200
    },
    {
      id: 'primaryCTA',
      label: 'Primary CTA',
      type: 'textarea',
      placeholder: 'e.g., Start Free Trial - No Credit Card Required',
      helperText: 'Main button text (can include supporting text)',
      required: true,
      maxLength: 100
    },
    {
      id: 'pageGoal',
      label: 'Page Goal',
      type: 'select',
      helperText: 'Primary conversion goal',
      required: true,
      options: [
        'Free Trial Signup',
        'Demo Request',
        'Email Capture',
        'Purchase/Checkout',
        'Waitlist Signup',
        'Download Resource',
        'Other (specify)'
      ]
    }
  ],
  systemPrompt: `You are an expert conversion copywriter. Create a high-converting landing page hero section based on these details:

Product/Service: {productService}
Target Audience: {targetAudience}
Primary Problem: {primaryProblem}
Unique Value Proposition: {uniqueValueProp}
Social Proof: {socialProof}
Primary CTA: {primaryCTA}
Page Goal: {pageGoal}

{brandVoiceInstructions}
{personaInstructions}

Write hero section copy that includes:
1. Headline: Clear, benefit-driven, addresses the problem (8-12 words)
2. Subheadline: Expands on headline, communicates unique value (15-25 words)
3. Supporting Copy: 2-3 sentences elaborating on benefits and solution
4. Social Proof Line: Brief credibility statement if provided
5. CTA Copy: The button text and optional supporting microcopy

Format each element clearly labeled.`
};

/**
 * Email Sequence Template
 * Creates complete multi-email sequences (3-7 emails) with narrative arc
 */
export const EMAIL_SEQUENCE_KICKOFF_TEMPLATE: Template = {
  id: 'email-sequence-kickoff',
  name: 'Email Sequence',
  category: 'email',
  description: 'Generate a complete email sequence (3-7 emails) with strategic narrative arc and timing.',
  complexity: 'Intermediate',
  estimatedTime: '2-5 min',
  icon: 'Mail',
  fields: [
    {
      id: 'campaignType',
      label: 'Campaign Type',
      type: 'select',
      helperText: 'What type of email sequence is this?',
      required: true,
      options: [
        'Welcome Series',
        'Lead Magnet Follow-up',
        'Product Launch',
        'Course/Training',
        'Sales Sequence',
        'Onboarding',
        'Re-engagement',
        'Other (specify)'
      ]
    },
    {
      id: 'numberOfEmails',
      label: 'Number of Emails',
      type: 'select',
      helperText: 'How many emails should be in this sequence?',
      required: true,
      options: [
        '3 emails',
        '4 emails',
        '5 emails',
        '6 emails',
        '7 emails'
      ]
    },
    {
      id: 'recipientProfile',
      label: 'Recipient Profile',
      type: 'textarea',
      placeholder: 'e.g., Small business owners who signed up for our free marketing checklist...',
      helperText: 'Who receives these emails? Describe their background and interests',
      required: true,
      maxLength: 400
    },
    {
      id: 'offerValue',
      label: 'Offer/Value Proposition',
      type: 'textarea',
      placeholder: 'e.g., Weekly marketing tips, exclusive discounts, and insider strategies...',
      helperText: 'What value are you offering subscribers?',
      required: true,
      maxLength: 300
    },
    {
      id: 'endGoal',
      label: 'Sequence End Goal',
      type: 'select',
      helperText: 'What should subscribers do by the end of the sequence?',
      required: true,
      options: [
        'Purchase Product/Service',
        'Book a Call/Demo',
        'Start Free Trial',
        'Join Community/Group',
        'Upgrade Account',
        'Complete Onboarding',
        'Stay Engaged (nurture)',
        'Other (specify)'
      ]
    },
    {
      id: 'tone',
      label: 'Tone',
      type: 'select',
      helperText: 'What tone should these emails have?',
      required: true,
      options: [
        'Professional',
        'Friendly',
        'Educational',
        'Enthusiastic',
        'Authoritative',
        'Conversational',
        'Other (specify)'
      ]
    },
    {
      id: 'keyMessage',
      label: 'Key Message/Theme',
      type: 'textarea',
      placeholder: "e.g., We're here to help you grow, not sell you stuff...",
      helperText: 'Central theme or message that should run through all emails (optional)',
      required: false,
      maxLength: 250
    },
    {
      id: 'productService',
      label: 'Product/Service (if selling)',
      type: 'textarea',
      placeholder: 'e.g., Our premium marketing course that teaches...',
      helperText: 'What are you ultimately promoting? (optional for nurture sequences)',
      required: false,
      maxLength: 300
    }
  ],
  systemPrompt: `You are an expert email marketing copywriter specializing in high-converting email sequences. Create a COMPLETE email sequence with ALL emails based on these details:

Campaign Type: {campaignType}
Number of Emails: {numberOfEmails}
Recipient Profile: {recipientProfile}
Offer/Value Proposition: {offerValue}
Sequence End Goal: {endGoal}
Tone: {tone}
Key Message/Theme: {keyMessage}
Product/Service: {productService}

{brandVoiceInstructions}
{personaInstructions}

CRITICAL: You MUST generate ALL emails specified in "Number of Emails". Not just the first one.

STRATEGIC EMAIL SEQUENCE FRAMEWORK:
Based on the number of emails requested, follow this narrative arc:

FOR 3 EMAILS:
- Email 1: WELCOME + VALUE (Day 1) - Warm welcome, set expectations, deliver quick win
- Email 2: PROOF + EDUCATION (Day 3) - Share expertise, social proof, build trust
- Email 3: CLOSE (Day 5) - Clear CTA, urgency, final push toward end goal

FOR 4 EMAILS:
- Email 1: WELCOME (Day 1) - Warm intro, set stage, immediate value
- Email 2: VALUE (Day 3) - Educational content, build expertise
- Email 3: PROOF (Day 5) - Testimonials, case studies, results
- Email 4: CLOSE (Day 7) - Urgency, clear CTA, final action

FOR 5 EMAILS:
- Email 1: WELCOME (Day 1) - Introduction, expectations, quick win
- Email 2: VALUE (Day 3) - Deep educational content, build trust
- Email 3: PROOF (Day 5) - Social proof, success stories
- Email 4: ENGAGEMENT (Day 7) - Interactive, questions, deepen relationship
- Email 5: CLOSE (Day 10) - Strong CTA, urgency, final push

FOR 6 EMAILS:
- Email 1: WELCOME (Day 1) - Warm greeting, expectations, initial value
- Email 2: VALUE (Day 3) - Educational tip or insight
- Email 3: STORY (Day 5) - Case study or transformation story
- Email 4: PROOF (Day 7) - Testimonials, results, credibility
- Email 5: OBJECTIONS (Day 9) - Address concerns, FAQ style
- Email 6: CLOSE (Day 12) - Final CTA with urgency

FOR 7 EMAILS:
- Email 1: WELCOME (Day 1) - Warm introduction, set expectations
- Email 2: VALUE (Day 2) - Quick tip, immediate usefulness
- Email 3: EDUCATION (Day 4) - Deeper teaching, establish expertise
- Email 4: STORY (Day 6) - Case study, transformation narrative
- Email 5: PROOF (Day 8) - Social proof, testimonials
- Email 6: OBJECTIONS (Day 10) - Handle concerns, build confidence
- Email 7: CLOSE (Day 14) - Final push, urgency, clear CTA

REQUIREMENTS FOR EACH EMAIL:
1. Compelling subject line that creates curiosity
2. Clear purpose aligned with its position in the arc
3. Reference previous emails naturally ("As I mentioned...")
4. Escalate commitment gradually
5. Maintain consistent brand voice throughout
6. Each email: 150-300 words body (shorter is better for engagement)
7. End with soft CTA for early emails, strong CTA for final emails

OUTPUT FORMAT (CRITICAL - Follow exactly):

<h2>‚ïê‚ïê‚ïê EMAIL 1 of X: [PURPOSE] ‚ïê‚ïê‚ïê</h2>
<p><strong>üìÖ Send: Day 1</strong> (Immediately after signup)</p>
<h3>Subject: [Your Compelling Subject Line]</h3>
<p>[Email body - use multiple paragraphs]</p>
<p>[Include bullet points with <ul><li> where helpful]</p>
<p>[Signature]</p>

<hr>

<h2>‚ïê‚ïê‚ïê EMAIL 2 of X: [PURPOSE] ‚ïê‚ïê‚ïê</h2>
<p><strong>üìÖ Send: Day 3</strong> (2 days after Email 1)</p>
<h3>Subject: [Your Compelling Subject Line]</h3>
<p>[Email body...]</p>

[Continue with <hr> between each email until you've written ALL emails]

REMEMBER: 
- Generate EVERY email in the sequence, not just the first
- Use <hr> to separate emails clearly
- Include timing recommendations for each
- Build narrative momentum across the sequence
- Make each email standalone readable but part of a cohesive journey`
};

/**
 * Social Media Ad Copy Template
 * Generates high-converting copy for paid social ads
 */
export const SOCIAL_MEDIA_AD_COPY_TEMPLATE: Template = {
  id: 'social-media-ad-copy',
  name: 'Social Media Ad Copy',
  category: 'advertising',
  description: 'Generate high-converting copy for paid social ads (Facebook, LinkedIn, TikTok, Google).',
  complexity: 'Intermediate',
  estimatedTime: '10-15 min',
  icon: 'Megaphone',
  fields: [
    {
      id: 'platform',
      label: 'Platform',
      type: 'select',
      helperText: 'Which advertising platform is this for?',
      required: true,
      options: [
        'Facebook/Instagram',
        'LinkedIn',
        'TikTok',
        'Twitter/X',
        'Pinterest',
        'Google Search',
        'Other (specify)'
      ]
    },
    {
      id: 'characterLimit',
      label: 'Character Limit',
      type: 'select',
      helperText: 'How long should the ad copy be?',
      required: true,
      options: [
        'Short (100 chars)',
        'Medium (200 chars)',
        'Long (400 chars)'
      ]
    },
    {
      id: 'productService',
      label: 'Product/Service',
      type: 'textarea',
      placeholder: 'e.g., AI-powered writing assistant that helps marketers create content 10x faster...',
      helperText: 'What are you advertising? Include key features',
      required: true,
      maxLength: 600
    },
    {
      id: 'targetAudience',
      label: 'Target Audience',
      type: 'textarea',
      placeholder: 'e.g., Marketing managers at B2B SaaS companies, 30-45 years old, struggling with content creation...',
      helperText: 'Who are you trying to reach? Be specific',
      required: true,
      maxLength: 500
    },
    {
      id: 'primaryBenefit',
      label: 'Primary Benefit',
      type: 'select',
      helperText: 'Main benefit to highlight',
      required: true,
      options: [
        'Save Time',
        'Save Money',
        'Increase Revenue',
        'Solve Problem',
        'Achieve Goal',
        'Learn Skill',
        'Other (specify)'
      ]
    },
    {
      id: 'emotionalTrigger',
      label: 'Emotional Trigger',
      type: 'select',
      helperText: 'Psychology angle to leverage',
      required: true,
      options: [
        'FOMO',
        'Curiosity',
        'Aspiration',
        'Pain Point',
        'Social Proof',
        'Urgency',
        'Other (specify)'
      ]
    },
    {
      id: 'uniqueAngle',
      label: 'Unique Angle',
      type: 'textarea',
      placeholder: 'e.g., Only AI tool trained on top-performing ads, not generic content...',
      helperText: 'What makes you different from competitors?',
      required: true,
      maxLength: 400
    }
  ],
  systemPrompt: `You are a performance marketing expert who writes high-converting paid social ads. Create ad copy based on these details:

Platform: {platform}
Character Limit: {characterLimit}
Product/Service: {productService}
Target Audience: {targetAudience}
Primary Benefit: {primaryBenefit}
Emotional Trigger: {emotionalTrigger}
Unique Angle: {uniqueAngle}

{brandVoiceInstructions}
{personaInstructions}

Write 3 ad variations that:
1. Hook attention in the first line (pattern interrupt or question)
2. Speak directly to the target audience's situation
3. Highlight the primary benefit clearly
4. Leverage the emotional trigger effectively
5. Include a compelling call-to-action
6. Stay within the specified character limit

Platform-specific guidelines:
- Facebook/Instagram: Conversational, visual language, emoji optional
- LinkedIn: Professional, data-driven, business outcomes
- TikTok: Casual, trendy, authentic voice
- Twitter/X: Punchy, concise, hashtag-friendly
- Pinterest: Inspirational, action-oriented
- Google Search: Keyword-focused, benefit-driven headlines

Provide 3 distinct variations with different hooks and angles.`
};

/**
 * Social Media Post Template
 * Creates engaging organic social media content
 */
export const SOCIAL_MEDIA_POST_TEMPLATE: Template = {
  id: 'social-media-post',
  name: 'Social Media Post',
  category: 'social',
  description: 'Create engaging social media content that stops the scroll and drives engagement.',
  complexity: 'Beginner',
  estimatedTime: '5-10 min',
  icon: 'MessageSquare',
  fields: [
    {
      id: 'platform',
      label: 'Platform',
      type: 'select',
      helperText: 'Which social platform is this for?',
      required: true,
      options: [
        'LinkedIn',
        'Instagram',
        'Facebook',
        'Twitter/X',
        'TikTok',
        'Other (specify)'
      ]
    },
    {
      id: 'postType',
      label: 'Post Type',
      type: 'select',
      helperText: 'What kind of content are you creating?',
      required: true,
      options: [
        'Educational',
        'Inspirational',
        'Behind-the-Scenes',
        'Question/Poll',
        'Announcement',
        'Story',
        'Other (specify)'
      ]
    },
    {
      id: 'hookStyle',
      label: 'Hook Style',
      type: 'select',
      helperText: 'How should the post start to grab attention?',
      required: true,
      options: [
        'Question',
        'Statistic',
        'Bold Statement',
        'Personal Story',
        'Contrarian Take',
        'Other (specify)'
      ]
    },
    {
      id: 'topic',
      label: 'Topic/Main Idea',
      type: 'textarea',
      placeholder: 'e.g., Why 80% of startups fail at content marketing and how to avoid it...',
      helperText: 'What is the main message of this post?',
      required: true,
      maxLength: 300
    },
    {
      id: 'keyPoints',
      label: 'Key Points',
      type: 'textarea',
      placeholder: 'e.g., \n- Consistency beats perfection\n- Know your audience deeply\n- Repurpose content across channels',
      helperText: 'Main points to cover (one per line)',
      required: true,
      maxLength: 500
    },
    {
      id: 'targetAudience',
      label: 'Target Audience',
      type: 'textarea',
      placeholder: 'e.g., Early-stage founders and marketers',
      helperText: 'Who should resonate with this post?',
      required: true,
      maxLength: 150
    },
    {
      id: 'tone',
      label: 'Tone',
      type: 'select',
      helperText: 'What tone should the post have?',
      required: true,
      options: [
        'Professional',
        'Casual',
        'Inspirational',
        'Educational',
        'Humorous',
        'Other (specify)'
      ]
    },
    {
      id: 'callToAction',
      label: 'Call-to-Action',
      type: 'select',
      helperText: 'What action do you want readers to take? (optional)',
      required: false,
      options: [
        'Comment',
        'Share',
        'Click Link',
        'Tag Someone',
        'Save Post',
        'Other (specify)'
      ]
    }
  ],
  systemPrompt: `You are a social media expert who creates viral, engaging content. Write a social post based on these details:

Platform: {platform}
Post Type: {postType}
Hook Style: {hookStyle}
Topic: {topic}
Key Points: {keyPoints}
Target Audience: {targetAudience}
Tone: {tone}
Call-to-Action: {callToAction}

{brandVoiceInstructions}
{personaInstructions}

Create a scroll-stopping post that:
1. Opens with a powerful hook that matches the specified style
2. Delivers valuable content based on the key points
3. Uses appropriate formatting for the platform
4. Maintains the specified tone throughout
5. Ends with a clear call-to-action if specified
6. Uses line breaks strategically for readability

Platform-specific formatting:
- LinkedIn: Professional, line breaks every 1-2 sentences, no hashtags in body
- Instagram: Visual language, emojis encouraged, hashtags at end
- Facebook: Conversational, medium length, engagement questions
- Twitter/X: Punchy and concise, thread format if needed
- TikTok: Trendy, hooks viewers immediately, casual tone

Target length by platform:
- LinkedIn: 150-250 words
- Instagram: 100-200 words (caption)
- Facebook: 100-150 words
- Twitter/X: Under 280 characters (or thread)
- TikTok: 50-100 words (script style)`
};

/**
 * Print Media Template
 * Copy for print ads in magazines, newspapers, billboards, and direct mail
 */
export const PRINT_MEDIA_TEMPLATE: Template = {
  id: 'print-media',
  name: 'Print Media',
  category: 'advertising',
  description: 'Copy for print ads (magazine, newspaper, direct mail, billboards).',
  complexity: 'Intermediate',
  estimatedTime: '10-15 min',
  icon: 'FileText',
  fields: [
    {
      id: 'adFormat',
      label: 'Ad Format/Size',
      type: 'select',
      helperText: 'What format is this ad?',
      required: true,
      options: [
        'Full Page',
        'Half Page',
        'Quarter Page',
        'Billboard',
        'Direct Mail Postcard',
        'Flyer'
      ]
    },
    {
      id: 'publicationType',
      label: 'Publication Type',
      type: 'select',
      helperText: 'Where will this ad appear?',
      required: true,
      options: [
        'Trade Magazine',
        'Consumer Magazine',
        'Newspaper',
        'Direct Mail',
        'Out-of-Home',
        'Other (specify)'
      ]
    },
    {
      id: 'headlineStyle',
      label: 'Headline Style',
      type: 'select',
      helperText: 'What type of headline approach?',
      required: true,
      options: [
        'Benefit-Driven',
        'Question',
        'Command',
        'News',
        'Curiosity',
        'How-To',
        'Other (specify)'
      ]
    },
    {
      id: 'productService',
      label: 'Product/Service',
      type: 'textarea',
      placeholder: 'e.g., Premium organic coffee subscription delivered fresh weekly...',
      helperText: 'What are you advertising?',
      required: true,
      maxLength: 200
    },
    {
      id: 'targetAudience',
      label: 'Target Audience',
      type: 'textarea',
      placeholder: 'e.g., Coffee enthusiasts, 35-55, who value quality and convenience...',
      helperText: 'Who is this ad targeting?',
      required: true,
      maxLength: 300
    },
    {
      id: 'primaryBenefit',
      label: 'Primary Benefit',
      type: 'select',
      helperText: 'Main benefit to highlight',
      required: true,
      options: [
        'Save Time',
        'Save Money',
        'Improve Quality',
        'Solve Problem',
        'Enhance Status',
        'Other (specify)'
      ]
    },
    {
      id: 'tone',
      label: 'Tone',
      type: 'select',
      helperText: 'What tone should the ad convey?',
      required: true,
      options: [
        'Professional',
        'Urgent',
        'Luxurious',
        'Practical',
        'Bold',
        'Other (specify)'
      ]
    },
    {
      id: 'visualConcept',
      label: 'Visual Concept',
      type: 'textarea',
      placeholder: 'e.g., Steaming cup of coffee with sunrise over mountain backdrop...',
      helperText: 'Describe the main visual/image idea (optional)',
      required: false,
      maxLength: 250
    },
    {
      id: 'mandatories',
      label: 'Mandatories',
      type: 'textarea',
      placeholder: 'e.g., "Offer valid through 12/31. Terms apply. FDA statement required."',
      helperText: 'Legal or required copy that MUST appear (optional)',
      required: false,
      maxLength: 300
    },
    {
      id: 'ctaType',
      label: 'Call-to-Action Type',
      type: 'select',
      helperText: 'What action should readers take?',
      required: true,
      options: [
        'Visit Website',
        'Call Now',
        'Use Promo Code',
        'Visit Store',
        'Request Info',
        'Other (specify)'
      ]
    }
  ],
  systemPrompt: `You are a legendary print advertising copywriter in the tradition of David Ogilvy and Bill Bernbach. Create print ad copy based on these details:

Ad Format: {adFormat}
Publication Type: {publicationType}
Headline Style: {headlineStyle}
Product/Service: {productService}
Target Audience: {targetAudience}
Primary Benefit: {primaryBenefit}
Tone: {tone}
Visual Concept: {visualConcept}
Mandatories: {mandatories}
Call-to-Action Type: {ctaType}

{brandVoiceInstructions}
{personaInstructions}

Create print ad copy that includes:
1. HEADLINE: Compelling, attention-grabbing headline (5-10 words)
2. SUBHEADLINE: Supporting line that expands on the headline
3. BODY COPY: Persuasive copy that sells the benefit (length varies by format)
4. CTA: Clear call-to-action with contact/response info
5. TAGLINE: Memorable brand tagline (optional)

Format-specific guidelines:
- Full Page: 150-200 words body copy
- Half Page: 75-100 words body copy
- Quarter Page: 40-60 words body copy
- Billboard: 7 words or less total, no body copy
- Direct Mail Postcard: 100-150 words, urgency-focused
- Flyer: 100-150 words, benefit bullets

Remember: Every word must earn its place. Print ads are expensive‚Äîmake each word count.
Include the mandatories naturally if provided.`
};


/**
 * Website Copy (SEO-Optimized) Template
 * SEO-focused copy for homepage, service pages, and core website sections
 */
export const WEBSITE_COPY_SEO_TEMPLATE: Template = {
  id: 'website-copy-seo',
  name: 'Website Copy (SEO-Optimized)',
  category: 'website',
  description: 'Generate SEO-optimized copy for homepage, service pages, and core website sections with keyword integration.',
  complexity: 'Intermediate',
  estimatedTime: '15-20 min',
  icon: 'Globe',
  fields: [
    {
      id: 'pageType',
      label: 'Page Type',
      type: 'select',
      helperText: 'What type of page is this?',
      required: true,
      options: [
        'Homepage',
        'Service/Product Page',
        'About Page',
        'Landing Page',
        'Blog Post'
      ]
    },
    {
      id: 'pageGoal',
      label: 'Page Goal',
      type: 'select',
      helperText: 'Primary conversion goal',
      required: true,
      options: [
        'Lead Generation',
        'E-commerce/Sales',
        'Information/Education',
        'Brand Building',
        'Other (specify)'
      ]
    },
    {
      id: 'primaryKeyword',
      label: 'Primary Keyword/Keyphrase',
      type: 'text',
      placeholder: 'e.g., project management software for small teams',
      helperText: 'Main keyword to target (2-4 words ideal)',
      required: true,
      maxLength: 100
    },
    {
      id: 'secondaryKeywords',
      label: 'Secondary Keywords',
      type: 'textarea',
      placeholder: 'e.g., \n- task management app\n- team collaboration tool\n- small business project tracking',
      helperText: 'Related search terms to naturally incorporate (3-5 keywords)',
      required: true,
      maxLength: 300
    },
    {
      id: 'searchIntent',
      label: 'User Search Intent',
      type: 'select',
      helperText: 'Why are users searching for this?',
      required: true,
      options: [
        'Looking for Solution',
        'Comparing Options',
        'Ready to Buy',
        'Learning/Research'
      ]
    },
    {
      id: 'targetAudience',
      label: 'Target Audience',
      type: 'textarea',
      placeholder: 'e.g., Small business owners and team leads who need simple project tracking...',
      helperText: 'Who is this page for?',
      required: true,
      maxLength: 300
    },
    {
      id: 'productService',
      label: 'Product/Service/Business',
      type: 'textarea',
      placeholder: 'e.g., Cloud-based project management tool with Kanban boards, time tracking, and team chat...',
      helperText: 'What are you promoting?',
      required: true,
      maxLength: 250
    },
    {
      id: 'uniqueValue',
      label: 'Unique Value Proposition',
      type: 'textarea',
      placeholder: 'e.g., The only project tool built specifically for teams under 20 people...',
      helperText: 'What makes you different?',
      required: true,
      maxLength: 300
    },
    {
      id: 'topBenefits',
      label: 'Top 3 Benefits',
      type: 'textarea',
      placeholder: 'e.g., \n- Get started in 5 minutes, no training needed\n- See all projects in one dashboard\n- Integrates with tools you already use',
      helperText: 'Main selling points (one per line)',
      required: true,
      maxLength: 400
    },
    {
      id: 'painPoint',
      label: 'Primary Pain Point/Problem',
      type: 'textarea',
      placeholder: 'e.g., Teams waste 5+ hours per week in status meetings and scattered communication...',
      helperText: 'What problem do you solve?',
      required: true,
      maxLength: 300
    },
    {
      id: 'callToAction',
      label: 'Call-to-Action',
      type: 'select',
      helperText: 'Primary action for visitors',
      required: true,
      options: [
        'Request Quote',
        'Schedule Demo',
        'Start Free Trial',
        'Contact Us',
        'Buy Now',
        'Learn More',
        'Other (specify)'
      ]
    },
    {
      id: 'tone',
      label: 'Tone',
      type: 'select',
      helperText: 'What tone should the copy have?',
      required: true,
      options: [
        'Professional',
        'Conversational',
        'Technical',
        'Friendly',
        'Authoritative',
        'Other (specify)'
      ]
    },
    {
      id: 'metaDescription',
      label: 'Meta Description',
      type: 'textarea',
      placeholder: 'e.g., Simple project management for small teams. Get organized in minutes with our intuitive Kanban boards and...',
      helperText: 'SEO snippet shown in search results (max 160 chars, optional)',
      required: false,
      maxLength: 160
    }
  ],
  systemPrompt: `You are an SEO copywriter who creates compelling, search-optimized web content. Write website copy based on these details:

Page Type: {pageType}
Page Goal: {pageGoal}
Primary Keyword: {primaryKeyword}
Secondary Keywords: {secondaryKeywords}
User Search Intent: {searchIntent}
Target Audience: {targetAudience}
Product/Service: {productService}
Unique Value Proposition: {uniqueValue}
Top 3 Benefits: {topBenefits}
Primary Pain Point: {painPoint}
Call-to-Action: {callToAction}
Tone: {tone}
Meta Description: {metaDescription}

{brandVoiceInstructions}
{personaInstructions}

Create SEO-optimized page copy that includes:

1. META TITLE: 50-60 characters, includes primary keyword, compelling
2. META DESCRIPTION: 150-160 characters, includes keyword, has CTA (if not provided)
3. H1 HEADLINE: Primary keyword naturally included, benefit-focused
4. HERO SECTION: 
   - Subheadline expanding on H1
   - 2-3 sentences addressing pain point and introducing solution
   - CTA button text

5. BENEFITS SECTION:
   - Section headline (H2)
   - 3 benefits with H3 headlines and 2-3 sentence explanations
   - Naturally incorporate secondary keywords

6. HOW IT WORKS / FEATURES SECTION:
   - Section headline (H2)
   - 3-4 steps or features
   - Clear, scannable format

7. SOCIAL PROOF SECTION:
   - Section headline (H2)
   - Placeholder for testimonials/logos
   - Trust-building copy

8. CTA SECTION:
   - Compelling headline (H2)
   - 2-3 sentences creating urgency
   - CTA button text with supporting microcopy

SEO Guidelines:
- Include primary keyword in H1, first paragraph, and naturally 2-3 more times
- Use secondary keywords in H2s and body copy where natural
- Write for humans first, search engines second
- Keep paragraphs short (2-3 sentences max)
- Use bullet points for scanability
- Match content to user search intent

Target word count: 600-900 words total page copy.`
};

/**
 * Multi-Section Brochure Template (Advanced)
 * This is a special template that generates content section by section
 * with context awareness and progress persistence.
 * 
 * Note: This template uses a custom component (BrochureMultiSectionTemplate)
 * rather than the standard TemplateFormSlideOut. The template definition
 * here is for display in the TemplatesModal.
 */
export const BROCHURE_MULTI_SECTION_TEMPLATE: Template = {
  id: 'brochure-multi-section',
  name: 'Brochure Copy (Multi-Section)',
  category: 'collateral',
  description: 'Generate complete brochure section by section with context. Progress saves across sessions.',
  complexity: 'Advanced',
  estimatedTime: '30-45 min',
  icon: 'BookOpen',
  fields: [], // Fields are defined per-section in the config
  systemPrompt: '', // System prompt is built dynamically per section
};

/**
 * All available templates
 * Add new templates to this array to make them available
 */
export const ALL_TEMPLATES: Template[] = [
  SALES_EMAIL_TEMPLATE,
  LANDING_PAGE_HERO_TEMPLATE,
  EMAIL_SEQUENCE_KICKOFF_TEMPLATE,
  SOCIAL_MEDIA_AD_COPY_TEMPLATE,
  SOCIAL_MEDIA_POST_TEMPLATE,
  PRINT_MEDIA_TEMPLATE,
  WEBSITE_COPY_SEO_TEMPLATE,
  BROCHURE_MULTI_SECTION_TEMPLATE,
];

/**
 * Get a template by its ID
 * @param id - Template ID to find
 * @returns Template if found, undefined otherwise
 */
export function getTemplateById(id: string): Template | undefined {
  return ALL_TEMPLATES.find(t => t.id === id);
}

/**
 * Get all templates in a specific category
 * @param category - Category to filter by
 * @returns Array of templates in that category
 */
export function getTemplatesByCategory(category: TemplateCategory): Template[] {
  return ALL_TEMPLATES.filter(t => t.category === category);
}

/**
 * Get all unique categories from available templates
 * @returns Array of unique category names
 */
export function getAllCategories(): TemplateCategory[] {
  const categories = new Set(ALL_TEMPLATES.map(t => t.category));
  return Array.from(categories);
}


=== FILE: lib/editor-utils.ts ===

/**
 * @file lib/editor-utils.ts
 * @description Utility functions for TipTap editor operations
 * 
 * Provides abstraction layer over TipTap API for common operations:
 * - Getting selected text and range
 * - Inserting text at selection
 * - Replacing selection with new content
 */

import type { Editor } from '@tiptap/react';
import { DOMSerializer } from '@tiptap/pm/model';
import { logger } from '@/lib/utils/logger';

/**
 * Selection data returned by getEditorSelection
 */
export interface EditorSelection {
  text: string;
  html: string;
  range: {
    from: number;
    to: number;
  };
}

/**
 * Gets the current text selection from the editor
 * 
 * IMPORTANT: This function correctly extracts HTML from the selection by:
 * 1. Getting the document slice for the selection
 * 2. Using ProseMirror's DOMSerializer to convert to HTML
 * 
 * @param editor - TipTap editor instance
 * @returns Selection data or null if no selection or editor unavailable
 * 
 * @example
 * ```ts
 * const selection = getEditorSelection(editor);
 * if (selection) {
 *   console.log('Selected:', selection.text);
 *   console.log('Selected HTML:', selection.html);
 *   console.log('Range:', selection.range);
 * }
 * ```
 */
export function getEditorSelection(editor: Editor | null): EditorSelection | null {
  if (!editor) {
    logger.warn('‚ö†Ô∏è getEditorSelection: No editor instance');
    return null;
  }

  try {
    const { from, to } = editor.state.selection;
    
    // No selection (cursor is just positioned, from === to)
    if (from === to) {
      logger.log('üìç No text selected (cursor only)');
      return null;
    }

    // Get the selected text (plain text)
    const text = editor.state.doc.textBetween(from, to, ' ');
    
    if (!text || text.trim().length === 0) {
      logger.log('‚ö†Ô∏è Selection is empty');
      return null;
    }

    // Get the selected HTML content properly using ProseMirror's DOMSerializer
    let html = '';
    try {
      // Get the slice of the document that's selected
      const slice = editor.state.doc.slice(from, to);
      
      // Use ProseMirror's DOMSerializer to convert to HTML
      const serializer = DOMSerializer.fromSchema(editor.schema);
      const fragment = serializer.serializeFragment(slice.content);
      
      // Convert the DOM fragment to HTML string
      const div = document.createElement('div');
      div.appendChild(fragment);
      html = div.innerHTML;
      
      logger.log('üìã Selection HTML extracted:', {
        textLength: text.length,
        htmlLength: html.length,
        hasFormatting: html.includes('<ul>') || html.includes('<ol>') || html.includes('<h') || html.includes('<strong>'),
      });
    } catch (htmlError) {
      // Fallback: wrap plain text in paragraph tags
      logger.warn('‚ö†Ô∏è Could not extract HTML, falling back to plain text:', htmlError);
      html = `<p>${text.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>')}</p>`;
    }

    return {
      text: text.trim(),
      html,
      range: { from, to },
    };
  } catch (error) {
    logger.error('‚ùå Error getting editor selection:', error);
    return null;
  }
}

/**
 * Inserts or replaces text at the current selection in the editor
 * 
 * If there's a selection, it will be replaced with the new text.
 * If there's no selection (just a cursor), the text will be inserted at the cursor position.
 * 
 * @param editor - TipTap editor instance
 * @param text - Text content to insert (can be plain text or HTML)
 * @param options - Optional configuration
 * @param options.isHTML - Whether the text is HTML (default: false)
 * @param options.selectInserted - Whether to select the inserted text after insertion (default: false)
 * @returns true if successful, false otherwise
 * 
 * @example
 * ```ts
 * // Replace selection with plain text
 * insertTextAtSelection(editor, 'New text here');
 * 
 * // Replace selection with HTML
 * insertTextAtSelection(editor, '<p>HTML content</p>', { isHTML: true });
 * 
 * // Insert and select the new text
 * insertTextAtSelection(editor, 'New text', { selectInserted: true });
 * ```
 */
export function insertTextAtSelection(
  editor: Editor | null,
  text: string,
  options: {
    isHTML?: boolean;
    selectInserted?: boolean;
  } = {}
): boolean {
  if (!editor) {
    logger.error('‚ùå insertTextAtSelection: No editor instance');
    return false;
  }

  if (!text) {
    logger.warn('‚ö†Ô∏è insertTextAtSelection: No text provided');
    return false;
  }

  const { isHTML = false, selectInserted = false } = options;

  try {
    const { from, to } = editor.state.selection;
    const hasSelection = from !== to;
    
    logger.log('üìù Inserting text at selection:', {
      from,
      to,
      hasSelection,
      textLength: text.length,
      isHTML,
      selectInserted,
    });

    // Use TipTap commands to replace selection with new content
    // Using deleteSelection() ensures proper transaction handling and update events
    if (hasSelection) {
      editor
        .chain()
        .focus()
        .deleteSelection() // Delete current selection (preferred over deleteRange)
        .insertContent(text) // Insert new content
        .run();
    } else {
      // No selection - just insert at cursor
      editor
        .chain()
        .focus()
        .insertContent(text)
        .run();
    }

    // Optionally select the inserted text
    if (selectInserted && hasSelection) {
      const newTo = from + text.length;
      editor.commands.setTextSelection({ from, to: newTo });
    }

    logger.log('‚úÖ Text inserted successfully');
    return true;
  } catch (error) {
    logger.error('‚ùå Error inserting text at selection:', error);
    return false;
  }
}

/**
 * Replaces the entire editor content
 * 
 * @param editor - TipTap editor instance
 * @param content - New content (HTML string)
 * @returns true if successful, false otherwise
 * 
 * @example
 * ```ts
 * replaceEditorContent(editor, '<p>New document content</p>');
 * ```
 */
export function replaceEditorContent(
  editor: Editor | null,
  content: string
): boolean {
  if (!editor) {
    logger.error('‚ùå replaceEditorContent: No editor instance');
    return false;
  }

  try {
    editor.commands.setContent(content);
    logger.log('‚úÖ Editor content replaced');
    return true;
  } catch (error) {
    logger.error('‚ùå Error replacing editor content:', error);
    return false;
  }
}

/**
 * Gets the full text content of the editor (plain text, no HTML)
 * 
 * @param editor - TipTap editor instance
 * @returns Plain text content or empty string if unavailable
 */
export function getEditorText(editor: Editor | null): string {
  if (!editor) {
    return '';
  }
  
  return editor.getText();
}

/**
 * Gets the full HTML content of the editor
 * 
 * @param editor - TipTap editor instance
 * @returns HTML content or empty string if unavailable
 */
export function getEditorHTML(editor: Editor | null): string {
  if (!editor) {
    return '';
  }
  
  return editor.getHTML();
}

/**
 * Checks if the editor has any selected text
 * 
 * @param editor - TipTap editor instance
 * @returns true if text is selected, false otherwise
 */
export function hasSelection(editor: Editor | null): boolean {
  if (!editor) {
    return false;
  }

  const { from, to } = editor.state.selection;
  return from !== to;
}


=== FILE: lib/hooks/useApiUsage.ts ===

/**
 * @file lib/hooks/useApiUsage.ts
 * @description React hook to fetch and track user's API usage from Supabase
 * 
 * Features:
 * - Fetches total tokens and cost from api_usage_logs
 * - Tracks progress toward $5.00 beta limit
 * - Caches results for 30 seconds to minimize DB calls
 * - Refetches on window focus for fresh data
 * - Provides loading and error states
 * 
 * @requires /api/usage endpoint to fetch server-side data
 */

'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { useUser } from '@clerk/nextjs';

// ============================================================================
// Constants
// ============================================================================

/** Beta usage limit in USD */
const BETA_LIMIT_USD = 5.00;

/** Cache duration in milliseconds (30 seconds) */
const CACHE_DURATION_MS = 30_000;

// ============================================================================
// Types
// ============================================================================

/**
 * API response structure from /api/usage endpoint
 */
interface UsageApiResponse {
  totalTokens: number;
  totalCost: number;
  totalApiCalls: number;
  lastApiCall: string | null;
}

/**
 * Error response structure
 */
interface UsageApiError {
  error: string;
  details?: string;
}

/**
 * Return type for useApiUsage hook
 */
export interface ApiUsageData {
  /** Total cost in USD spent by the user */
  totalCost: number;
  
  /** Total number of tokens used (input + output) */
  totalTokens: number;
  
  /** Whether data is currently being fetched */
  isLoading: boolean;
  
  /** Whether user has reached or exceeded the $5.00 beta limit */
  isOverLimit: boolean;
  
  /** Remaining budget in USD (5.00 - totalCost) */
  remainingBudget: number;
  
  /** Percentage of budget used (0-100+) */
  percentUsed: number;
  
  /** Total number of API calls made */
  totalApiCalls: number;
  
  /** Timestamp of last API call, or null if none */
  lastApiCall: Date | null;
  
  /** Error message if fetch failed, null otherwise */
  error: string | null;
  
  /** Function to manually trigger a refetch */
  refetch: () => Promise<void>;
}

// ============================================================================
// Hook Implementation
// ============================================================================

/**
 * Hook to fetch and track user's API usage
 * 
 * Fetches usage data from the /api/usage endpoint, caches results for 30 seconds,
 * and automatically refetches when the user returns to the tab.
 * 
 * @returns {ApiUsageData} Object containing usage stats and control functions
 * 
 * @example
 * ```tsx
 * function UsageDisplay() {
 *   const { 
 *     totalCost, 
 *     remainingBudget, 
 *     isOverLimit, 
 *     percentUsed,
 *     isLoading,
 *     refetch 
 *   } = useApiUsage();
 * 
 *   if (isLoading) return <Spinner />;
 * 
 *   return (
 *     <div>
 *       <p>Spent: ${totalCost.toFixed(2)} / $5.00</p>
 *       <p>Remaining: ${remainingBudget.toFixed(2)}</p>
 *       <progress value={percentUsed} max={100} />
 *       {isOverLimit && <p>You've reached your usage limit!</p>}
 *       <button onClick={refetch}>Refresh</button>
 *     </div>
 *   );
 * }
 * ```
 */
export function useApiUsage(): ApiUsageData {
  // Get current user from Clerk
  const { user, isLoaded: isUserLoaded } = useUser();
  
  // State for usage data
  const [totalCost, setTotalCost] = useState<number>(0);
  const [totalTokens, setTotalTokens] = useState<number>(0);
  const [totalApiCalls, setTotalApiCalls] = useState<number>(0);
  const [lastApiCall, setLastApiCall] = useState<Date | null>(null);
  
  // State for loading and error handling
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  
  // Ref to track last fetch timestamp for caching
  const lastFetchTime = useRef<number>(0);
  
  // Ref to prevent concurrent fetches
  const isFetching = useRef<boolean>(false);

  /**
   * Fetch usage data from the API
   * Respects cache duration unless force=true
   */
  const fetchUsage = useCallback(async (force: boolean = false): Promise<void> => {
    // Skip if no user is logged in
    if (!user?.id) {
      setIsLoading(false);
      setTotalCost(0);
      setTotalTokens(0);
      setTotalApiCalls(0);
      setLastApiCall(null);
      return;
    }

    // Check cache validity (skip fetch if data is fresh)
    const now = Date.now();
    if (!force && lastFetchTime.current > 0 && now - lastFetchTime.current < CACHE_DURATION_MS) {
      return;
    }

    // Prevent concurrent fetches
    if (isFetching.current) {
      return;
    }

    isFetching.current = true;
    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/usage', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        const errorData: UsageApiError = await response.json();
        throw new Error(errorData.details || errorData.error || 'Failed to fetch usage data');
      }

      const data: UsageApiResponse = await response.json();

      // Update state with fetched data
      setTotalCost(data.totalCost);
      setTotalTokens(data.totalTokens);
      setTotalApiCalls(data.totalApiCalls);
      setLastApiCall(data.lastApiCall ? new Date(data.lastApiCall) : null);
      
      // Update cache timestamp
      lastFetchTime.current = Date.now();
      
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Unknown error fetching usage';
      setError(errorMessage);
      console.error('‚ùå useApiUsage fetch error:', errorMessage);
    } finally {
      setIsLoading(false);
      isFetching.current = false;
    }
  }, [user?.id]);

  /**
   * Manual refetch function (exposed to consumers)
   * Always forces a fresh fetch, ignoring cache
   */
  const refetch = useCallback(async (): Promise<void> => {
    await fetchUsage(true);
  }, [fetchUsage]);

  /**
   * Initial fetch when user is loaded
   */
  useEffect(() => {
    if (isUserLoaded) {
      fetchUsage();
    }
  }, [isUserLoaded, fetchUsage]);

  /**
   * Refetch on window focus (tab visibility change)
   * Only refetches if cache has expired
   */
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const handleVisibilityChange = (): void => {
      if (document.visibilityState === 'visible') {
        // Only fetch if cache has expired
        fetchUsage(false);
      }
    };

    const handleFocus = (): void => {
      // Only fetch if cache has expired
      fetchUsage(false);
    };

    // Listen for both visibility change and window focus
    document.addEventListener('visibilitychange', handleVisibilityChange);
    window.addEventListener('focus', handleFocus);

    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      window.removeEventListener('focus', handleFocus);
    };
  }, [fetchUsage]);

  // ============================================================================
  // Computed Values
  // ============================================================================

  /** Whether user has exceeded the beta limit */
  const isOverLimit = totalCost >= BETA_LIMIT_USD;

  /** Remaining budget (can be negative if over limit) */
  const remainingBudget = Math.max(0, BETA_LIMIT_USD - totalCost);

  /** Percentage of budget used (can exceed 100%) */
  const percentUsed = (totalCost / BETA_LIMIT_USD) * 100;

  // ============================================================================
  // Return Value
  // ============================================================================

  return {
    totalCost,
    totalTokens,
    isLoading,
    isOverLimit,
    remainingBudget,
    percentUsed,
    totalApiCalls,
    lastApiCall,
    error,
    refetch,
  };
}

// ============================================================================
// Default Export
// ============================================================================

export default useApiUsage;


=== FILE: lib/hooks/useProductTour.ts ===

/**
 * @file lib/hooks/useProductTour.ts
 * @description Hook to manage product tour state with localStorage persistence
 * 
 * Features:
 * - Tracks whether user has completed the tour
 * - Provides functions to restart the tour
 * - Persists completion state in localStorage
 * - Auto-starts tour on first visit with delay
 */

'use client';

import { useState, useEffect, useCallback } from 'react';
import { logger } from '@/lib/utils/logger';

/** localStorage key for tour completion flag */
const TOUR_COMPLETED_KEY = 'copyworx_tour_completed';

/** localStorage key for tour version (allows re-showing after updates) */
const TOUR_VERSION_KEY = 'copyworx_tour_version';

/** Current tour version - increment to show tour again to all users */
const CURRENT_TOUR_VERSION = '1.0';

/** Delay before starting tour (ms) - gives UI time to fully render */
const TOUR_START_DELAY = 1500;

/**
 * Hook to manage product tour state
 * 
 * @returns Object with tour state and control functions
 * 
 * @example
 * ```tsx
 * const { runTour, completeTour, restartTour } = useProductTour();
 * 
 * return (
 *   <>
 *     <ProductTour run={runTour} onComplete={completeTour} />
 *     <button onClick={restartTour}>Take Tour Again</button>
 *   </>
 * );
 * ```
 */
export function useProductTour() {
  /** Whether the tour is currently running */
  const [runTour, setRunTour] = useState(false);
  
  /** Whether we've checked localStorage (prevents flash) */
  const [isInitialized, setIsInitialized] = useState(false);

  /**
   * Check localStorage on mount to determine if tour should auto-start
   * Only runs on client side
   */
  useEffect(() => {
    // Only run in browser
    if (typeof window === 'undefined') return;

    // Check if tour has been completed for current version
    const tourCompleted = localStorage.getItem(TOUR_COMPLETED_KEY);
    const tourVersion = localStorage.getItem(TOUR_VERSION_KEY);
    
    // Show tour if:
    // 1. Never completed, OR
    // 2. Completed for older version (tour was updated)
    const shouldShowTour = !tourCompleted || tourVersion !== CURRENT_TOUR_VERSION;
    
    if (shouldShowTour) {
      // Delay tour start to ensure UI is fully rendered
      const timer = setTimeout(() => {
        setRunTour(true);
      }, TOUR_START_DELAY);
      
      return () => clearTimeout(timer);
    }
    
    setIsInitialized(true);
  }, []);

  /**
   * Mark tour as completed
   * Saves to localStorage and stops the tour
   */
  const completeTour = useCallback(() => {
    if (typeof window === 'undefined') return;
    
    localStorage.setItem(TOUR_COMPLETED_KEY, 'true');
    localStorage.setItem(TOUR_VERSION_KEY, CURRENT_TOUR_VERSION);
    setRunTour(false);
    setIsInitialized(true);
    
    logger.log('‚úÖ Product tour completed');
  }, []);

  /**
   * Restart the tour
   * Clears completion state and starts the tour
   */
  const restartTour = useCallback(() => {
    if (typeof window === 'undefined') return;
    
    // Clear completion flag to allow tour to run
    localStorage.removeItem(TOUR_COMPLETED_KEY);
    
    // Start tour with small delay for UI updates
    setTimeout(() => {
      setRunTour(true);
    }, 100);
    
    logger.log('üîÑ Product tour restarted');
  }, []);

  /**
   * Skip the tour without completing it
   * Marks as completed but doesn't prevent future restart
   */
  const skipTour = useCallback(() => {
    if (typeof window === 'undefined') return;
    
    localStorage.setItem(TOUR_COMPLETED_KEY, 'true');
    localStorage.setItem(TOUR_VERSION_KEY, CURRENT_TOUR_VERSION);
    setRunTour(false);
    
    logger.log('‚è≠Ô∏è Product tour skipped');
  }, []);

  /**
   * Check if tour has been completed
   * Useful for showing/hiding "Take Tour" buttons
   */
  const isTourCompleted = useCallback((): boolean => {
    if (typeof window === 'undefined') return false;
    return localStorage.getItem(TOUR_COMPLETED_KEY) === 'true';
  }, []);

  /**
   * Reset tour for testing/development
   * Clears all tour-related localStorage
   */
  const resetTourForTesting = useCallback(() => {
    if (typeof window === 'undefined') return;
    
    localStorage.removeItem(TOUR_COMPLETED_KEY);
    localStorage.removeItem(TOUR_VERSION_KEY);
    setRunTour(false);
    
    logger.log('üß™ Tour reset for testing - refresh page to see tour');
  }, []);

  return {
    /** Whether the tour is currently running */
    runTour,
    
    /** Whether the hook has initialized (checked localStorage) */
    isInitialized,
    
    /** Mark tour as completed */
    completeTour,
    
    /** Restart the tour from beginning */
    restartTour,
    
    /** Skip the tour */
    skipTour,
    
    /** Check if tour has been completed */
    isTourCompleted,
    
    /** Reset tour for testing (dev only) */
    resetTourForTesting,
  };
}


=== FILE: lib/prompts/tone-shifter.ts ===

/**
 * @file lib/prompts/tone-shifter.ts
 * @description System prompt and user prompt builder for the Tone Shifter feature
 * 
 * This module contains all Claude prompts for the Tone Shifter,
 * enabling the workspace store to call /api/claude directly.
 */

/**
 * Supported tone types for copy rewriting
 */
export type ToneType = 'professional' | 'casual' | 'urgent' | 'friendly' | 'techy' | 'playful';

/**
 * Valid tone values for validation
 */
export const VALID_TONES: ToneType[] = ['professional', 'casual', 'urgent', 'friendly', 'techy', 'playful'];

/**
 * Check if a string is a valid tone type
 */
export function isValidTone(tone: string): tone is ToneType {
  return VALID_TONES.includes(tone as ToneType);
}

/**
 * System prompt for the Tone Shifter
 * Establishes Claude's role as an expert copywriter
 */
export const TONE_SHIFTER_SYSTEM_PROMPT = `You are an expert copywriter with 40 years of experience. Your job is to rewrite copy to match a specific tone while preserving the core message, structure, and formatting.

CRITICAL OUTPUT FORMAT:
You MUST output valid HTML that preserves the original structure while changing the tone.
Use ONLY these tags:
- <h2> or <h3> for headings and subject lines
- <p> for paragraphs
- <ul> and <li> for bullet lists
- <strong> for bold emphasis
- <em> for italic emphasis
- <br> for line breaks within paragraphs (use sparingly)

HTML RULES:
1. Preserve the original document structure (headings stay headings, bullets stay bullets)
2. Change ONLY the tone/voice/word choice, NOT the structure
3. If input has bullets, output must have bullets
4. If input has headings, output must have headings
5. Output ONLY HTML, no markdown, no preamble
6. Do NOT add blank lines between tags - write consecutively: <p>Text</p><p>Next</p>
7. Keep emojis if appropriate for the tone (especially Playful and Casual)
8. Preserve bold/italic on key phrases where appropriate

Example - changing Professional to Playful while preserving structure:
INPUT (plain or HTML):
Subject: New Product Launch
We are excited to announce our new product.
‚Ä¢ Advanced features
‚Ä¢ Competitive pricing

OUTPUT (HTML):
<h3>Subject: üéâ Get Ready to Fall in Love with Our New Product!</h3>
<p>Guess what? We just dropped something amazing that's about to make your day!</p>
<ul>
<li>Features so cool they'll make you do a happy dance</li>
<li>Prices that won't make your wallet cry</li>
</ul>

When rewriting:
- Maintain the original meaning and key points
- Adjust word choice, sentence structure, and phrasing to match the target tone
- Keep the length roughly similar (¬±20% is acceptable)
- Improve clarity and readability
- Remove redundancies and awkward phrasing
- Do NOT add new information or claims not in the original

Return ONLY the HTML content, no explanations or preambles.`;

/**
 * Tone descriptions for the user prompt
 */
const TONE_DESCRIPTIONS: Record<ToneType, string> = {
  professional: 'Professional tone: formal, polished, business-appropriate, authoritative',
  casual: 'Casual tone: conversational, friendly, relaxed, approachable',
  urgent: 'Urgent tone: time-sensitive, compelling, action-oriented, creates FOMO',
  friendly: 'Friendly tone: warm, personable, welcoming, builds rapport',
  techy: `Technical, precise tone. Use:
- Technical terminology where appropriate
- Specific metrics and data points
- Clear, accurate language
- Demonstrate expertise and precision
- Focus on capabilities and specifications
- Use industry-standard terms
- Maintain clarity while being technical

Avoid: Jargon for jargon's sake, overly complex explanations, condescension`,
  playful: `Playful, fun tone. Use:
- Energetic, upbeat language
- Playful expressions and word choices
- Light humor where appropriate
- Conversational and engaging style
- Creative analogies or metaphors
- Enthusiasm without being annoying
- Keep it professional enough for the context

Avoid: Forced humor, being overly silly, losing the core message`,
};

/**
 * Build the user prompt for tone shifting
 * 
 * @param text - The text to rewrite
 * @param tone - The target tone
 * @returns The formatted user prompt
 */
export function buildToneShifterUserPrompt(text: string, tone: ToneType): string {
  return `Rewrite the following copy in a ${tone} tone while preserving its structure.

TARGET TONE: ${TONE_DESCRIPTIONS[tone]}

ORIGINAL COPY:
${text}

REWRITTEN COPY (HTML only):`;
}


=== FILE: lib/storage/document-storage.ts ===

/**
 * @file lib/storage/document-storage.ts
 * @description Document storage layer with Supabase API + localStorage fallback
 * 
 * Provides CRUD operations for documents within projects.
 * Uses Supabase API calls for cloud storage with localStorage fallback.
 * Supports version control with linked versions via parentVersionId.
 */

'use client';

import type { ProjectDocument } from '@/lib/types/project';
import { logger } from '@/lib/utils/logger';

// ============================================================================
// Configuration
// ============================================================================

const API_BASE = '/api/db/documents';

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Generate a unique ID for documents
 */
function generateId(): string {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
}

/**
 * Calculate word count from content string
 */
function calculateWordCount(content: string): number {
  if (!content) return 0;
  const textOnly = content.replace(/<[^>]*>/g, ' ');
  const words = textOnly.split(/\s+/).filter(word => word.trim().length > 0);
  return words.length;
}

/**
 * Calculate character count from content string
 */
function calculateCharCount(content: string): number {
  if (!content) return 0;
  const textOnly = content.replace(/<[^>]*>/g, '');
  return textOnly.length;
}

/**
 * Validate and sanitize base title
 */
function validateBaseTitle(baseTitle: string): string {
  if (!baseTitle || baseTitle.trim().length === 0) {
    throw new Error('Document title cannot be empty');
  }
  
  const trimmed = baseTitle.trim();
  const sanitized = trimmed.replace(/[<>]/g, '');
  
  if (sanitized.length > 200) {
    throw new Error('Document title cannot exceed 200 characters');
  }
  
  return sanitized;
}

/**
 * Convert API response (snake_case) to frontend format (camelCase)
 */
function mapApiToDocument(apiDoc: Record<string, unknown>): ProjectDocument {
  return {
    id: apiDoc.id as string,
    projectId: apiDoc.project_id as string,
    baseTitle: apiDoc.base_title as string,
    title: apiDoc.title as string,
    version: apiDoc.version as number,
    parentVersionId: apiDoc.parent_version_id as string | undefined,
    folderId: apiDoc.folder_id as string | undefined,
    content: apiDoc.content as string,
    createdAt: apiDoc.created_at as string,
    modifiedAt: apiDoc.modified_at as string,
    metadata: apiDoc.metadata as ProjectDocument['metadata'],
    templateProgress: apiDoc.template_progress as ProjectDocument['templateProgress'],
  };
}

/**
 * Convert frontend document to API format (snake_case)
 */
function mapDocumentToApi(doc: Partial<ProjectDocument>): Record<string, unknown> {
  const apiDoc: Record<string, unknown> = {};
  
  if (doc.projectId !== undefined) apiDoc.project_id = doc.projectId;
  if (doc.baseTitle !== undefined) apiDoc.base_title = doc.baseTitle;
  if (doc.title !== undefined) apiDoc.title = doc.title;
  if (doc.version !== undefined) apiDoc.version = doc.version;
  if (doc.parentVersionId !== undefined) apiDoc.parent_version_id = doc.parentVersionId;
  if (doc.folderId !== undefined) apiDoc.folder_id = doc.folderId;
  if (doc.content !== undefined) apiDoc.content = doc.content;
  if (doc.metadata !== undefined) apiDoc.metadata = doc.metadata;
  if (doc.templateProgress !== undefined) apiDoc.template_progress = doc.templateProgress;
  
  return apiDoc;
}

// ============================================================================
// localStorage Fallback Functions
// ============================================================================

const STORAGE_KEY = 'copyworx_documents';

function getLocalDocuments(projectId: string): ProjectDocument[] {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    if (!data) return [];
    const allDocs = JSON.parse(data) as ProjectDocument[];
    return allDocs.filter(doc => doc.projectId === projectId);
  } catch {
    return [];
  }
}

function saveLocalDocument(doc: ProjectDocument): void {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    const allDocs = data ? JSON.parse(data) as ProjectDocument[] : [];
    const existingIndex = allDocs.findIndex(d => d.id === doc.id);
    if (existingIndex >= 0) {
      allDocs[existingIndex] = doc;
    } else {
      allDocs.push(doc);
    }
    localStorage.setItem(STORAGE_KEY, JSON.stringify(allDocs));
  } catch (error) {
    logger.error('‚ùå Failed to save to localStorage:', error);
  }
}

function deleteLocalDocument(docId: string): void {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    if (!data) return;
    const allDocs = JSON.parse(data) as ProjectDocument[];
    const filtered = allDocs.filter(d => d.id !== docId);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(filtered));
  } catch (error) {
    logger.error('‚ùå Failed to delete from localStorage:', error);
  }
}

// ============================================================================
// API Call Wrapper
// ============================================================================

async function apiCall<T>(
  url: string, 
  options?: RequestInit
): Promise<T> {
  const response = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || `API error: ${response.status}`);
  }
  
  return response.json();
}

// ============================================================================
// CRUD Operations (API-first with localStorage fallback)
// ============================================================================

/**
 * Create a new document with version 1
 */
export async function createDocument(
  projectId: string,
  baseTitle: string,
  content: string = ''
): Promise<ProjectDocument> {
  if (typeof window === 'undefined') {
    throw new Error('Cannot create document in non-browser environment');
  }
  
  const sanitizedTitle = validateBaseTitle(baseTitle);
  const now = new Date().toISOString();
  
  // Prepare document data
  const docData = {
    project_id: projectId,
    base_title: sanitizedTitle,
    title: sanitizedTitle,
    version: 1,
    content,
    metadata: {
      wordCount: calculateWordCount(content),
      charCount: calculateCharCount(content),
      tags: [],
    },
  };
  
  try {
    // Try API first
    const apiResponse = await apiCall<Record<string, unknown>>(API_BASE, {
      method: 'POST',
      body: JSON.stringify(docData),
    });
    
    const newDoc = mapApiToDocument(apiResponse);
    logger.log('‚òÅÔ∏è Document created in cloud:', newDoc.id);
    
    // Also save to localStorage for offline access
    saveLocalDocument(newDoc);
    
    return newDoc;
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    // Fallback: create locally
    const newDoc: ProjectDocument = {
      id: generateId(),
      projectId,
      baseTitle: sanitizedTitle,
      title: sanitizedTitle,
      version: 1,
      content,
      createdAt: now,
      modifiedAt: now,
      metadata: {
        wordCount: calculateWordCount(content),
        charCount: calculateCharCount(content),
        tags: [],
      },
    };
    
    saveLocalDocument(newDoc);
    logger.log('üíæ Document created locally:', newDoc.id);
    
    return newDoc;
  }
}

/**
 * Create a new version of an existing document
 */
export async function createDocumentVersion(
  projectId: string,
  sourceDocId: string,
  newContent?: string
): Promise<ProjectDocument> {
  if (typeof window === 'undefined') {
    throw new Error('Cannot create document version in non-browser environment');
  }
  
  // Get source document
  const sourceDoc = await getDocument(projectId, sourceDocId);
  if (!sourceDoc) {
    throw new Error(`Source document not found: ${sourceDocId}`);
  }
  
  // Find highest version for this baseTitle
  const versions = await getDocumentVersions(projectId, sourceDoc.baseTitle);
  const highestVersion = Math.max(...versions.map(doc => doc.version), 0);
  const newVersion = highestVersion + 1;
  
  const content = newContent !== undefined ? newContent : sourceDoc.content;
  const now = new Date().toISOString();
  
  const docData = {
    project_id: projectId,
    base_title: sourceDoc.baseTitle,
    title: `${sourceDoc.baseTitle} v${newVersion}`,
    version: newVersion,
    parent_version_id: sourceDoc.id,
    content,
    metadata: {
      wordCount: calculateWordCount(content),
      charCount: calculateCharCount(content),
      templateId: sourceDoc.metadata?.templateId,
      tags: sourceDoc.metadata?.tags ? [...sourceDoc.metadata.tags] : [],
    },
  };
  
  try {
    const apiResponse = await apiCall<Record<string, unknown>>(API_BASE, {
      method: 'POST',
      body: JSON.stringify(docData),
    });
    
    const newDoc = mapApiToDocument(apiResponse);
    logger.log('‚òÅÔ∏è Document version created in cloud:', newDoc.id);
    saveLocalDocument(newDoc);
    
    return newDoc;
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    const newDoc: ProjectDocument = {
      id: generateId(),
      projectId,
      baseTitle: sourceDoc.baseTitle,
      title: `${sourceDoc.baseTitle} v${newVersion}`,
      version: newVersion,
      parentVersionId: sourceDoc.id,
      content,
      createdAt: now,
      modifiedAt: now,
      metadata: {
        wordCount: calculateWordCount(content),
        charCount: calculateCharCount(content),
        templateId: sourceDoc.metadata?.templateId,
        tags: sourceDoc.metadata?.tags ? [...sourceDoc.metadata.tags] : [],
      },
    };
    
    saveLocalDocument(newDoc);
    logger.log('üíæ Document version created locally:', newDoc.id);
    
    return newDoc;
  }
}

/**
 * Get all documents for a project
 */
export async function getAllDocuments(projectId: string): Promise<ProjectDocument[]> {
  if (typeof window === 'undefined') return [];
  
  try {
    const apiResponse = await apiCall<Record<string, unknown>[]>(
      `${API_BASE}?project_id=${encodeURIComponent(projectId)}`
    );
    
    const docs = apiResponse.map(mapApiToDocument);
    logger.log(`‚òÅÔ∏è Fetched ${docs.length} documents from cloud`);
    
    // Update localStorage with latest data
    docs.forEach(doc => saveLocalDocument(doc));
    
    return docs;
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    const localDocs = getLocalDocuments(projectId);
    logger.log(`üíæ Loaded ${localDocs.length} documents from localStorage`);
    
    return localDocs.sort((a, b) => 
      new Date(b.modifiedAt).getTime() - new Date(a.modifiedAt).getTime()
    );
  }
}

/**
 * Get a single document by ID
 */
export async function getDocument(
  projectId: string,
  docId: string
): Promise<ProjectDocument | null> {
  if (typeof window === 'undefined') return null;
  
  try {
    const apiResponse = await apiCall<Record<string, unknown>>(
      `${API_BASE}?id=${encodeURIComponent(docId)}`
    );
    
    const doc = mapApiToDocument(apiResponse);
    logger.log('‚òÅÔ∏è Document fetched from cloud:', doc.id);
    saveLocalDocument(doc);
    
    return doc;
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    const localDocs = getLocalDocuments(projectId);
    const doc = localDocs.find(d => d.id === docId) || null;
    
    if (doc) {
      logger.log('üíæ Document loaded from localStorage:', doc.id);
    } else {
      logger.warn(`‚ö†Ô∏è Document not found: ${docId}`);
    }
    
    return doc;
  }
}

/**
 * Get all versions of a document by baseTitle
 */
export async function getDocumentVersions(
  projectId: string,
  baseTitle: string
): Promise<ProjectDocument[]> {
  if (typeof window === 'undefined') return [];
  
  try {
    const apiResponse = await apiCall<Record<string, unknown>[]>(
      `${API_BASE}?project_id=${encodeURIComponent(projectId)}&base_title=${encodeURIComponent(baseTitle)}`
    );
    
    const docs = apiResponse.map(mapApiToDocument);
    logger.log(`‚òÅÔ∏è Fetched ${docs.length} versions for "${baseTitle}"`);
    
    return docs.sort((a, b) => a.version - b.version);
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    const localDocs = getLocalDocuments(projectId);
    const versions = localDocs.filter(doc => doc.baseTitle === baseTitle);
    
    logger.log(`üíæ Found ${versions.length} versions locally for "${baseTitle}"`);
    
    return versions.sort((a, b) => a.version - b.version);
  }
}

/**
 * Update a document
 */
export async function updateDocument(
  projectId: string,
  docId: string,
  updates: Partial<ProjectDocument>
): Promise<void> {
  if (typeof window === 'undefined') {
    throw new Error('Cannot update document in non-browser environment');
  }
  
  // Calculate metadata if content changed
  if (updates.content !== undefined) {
    updates.metadata = {
      ...updates.metadata,
      wordCount: calculateWordCount(updates.content),
      charCount: calculateCharCount(updates.content),
    };
  }
  
  // Validate baseTitle if being updated
  if (updates.baseTitle !== undefined) {
    updates.baseTitle = validateBaseTitle(updates.baseTitle);
  }
  
  // FIX: Get existing document BEFORE API call to avoid race condition
  // If we fetch AFTER the API call, we might get stale cached data
  const localDocs = getLocalDocuments(projectId);
  const docIndex = localDocs.findIndex(d => d.id === docId);
  
  if (docIndex === -1) {
    throw new Error(`Document not found: ${docId}`);
  }
  
  const existingDoc = localDocs[docIndex];
  
  try {
    await apiCall(API_BASE, {
      method: 'PUT',
      body: JSON.stringify({
        id: docId,
        ...mapDocumentToApi(updates),
      }),
    });
    
    logger.log('‚òÅÔ∏è Document updated in cloud:', docId);
    
    // FIX: Update localStorage with known updates, not by re-fetching
    // This prevents race conditions where the API returns stale data
    const updatedDoc = { 
      ...existingDoc, 
      ...updates, 
      modifiedAt: new Date().toISOString() 
    };
    saveLocalDocument(updatedDoc);
    logger.log('üíæ Document also updated in localStorage:', docId);
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    // Fallback: update locally only
    const updatedDoc = {
      ...existingDoc,
      ...updates,
      modifiedAt: new Date().toISOString(),
    };
    
    saveLocalDocument(updatedDoc);
    logger.log('üíæ Document updated locally (offline mode):', docId);
  }
}

/**
 * Delete a document
 */
export async function deleteDocument(
  projectId: string,
  docId: string
): Promise<void> {
  if (typeof window === 'undefined') {
    throw new Error('Cannot delete document in non-browser environment');
  }
  
  try {
    await apiCall(`${API_BASE}?id=${encodeURIComponent(docId)}`, {
      method: 'DELETE',
    });
    
    logger.log('‚òÅÔ∏è Document deleted from cloud:', docId);
    deleteLocalDocument(docId);
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    deleteLocalDocument(docId);
    logger.log('üíæ Document deleted locally:', docId);
  }
}

/**
 * Rename a document to a new document family
 */
export async function renameDocument(
  projectId: string,
  docId: string,
  newBaseTitle: string
): Promise<ProjectDocument> {
  if (typeof window === 'undefined') {
    throw new Error('Cannot rename document in non-browser environment');
  }
  
  const sanitizedTitle = validateBaseTitle(newBaseTitle);
  
  try {
    const apiResponse = await apiCall<Record<string, unknown>>(API_BASE, {
      method: 'PUT',
      body: JSON.stringify({
        id: docId,
        base_title: sanitizedTitle,
        title: sanitizedTitle,
      }),
    });
    
    const renamedDoc = mapApiToDocument(apiResponse);
    logger.log('‚òÅÔ∏è Document renamed in cloud:', renamedDoc.id);
    saveLocalDocument(renamedDoc);
    
    return renamedDoc;
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    const localDocs = getLocalDocuments(projectId);
    const docIndex = localDocs.findIndex(d => d.id === docId);
    
    if (docIndex === -1) {
      throw new Error(`Document not found: ${docId}`);
    }
    
    const existingDoc = localDocs[docIndex];
    const renamedDoc: ProjectDocument = {
      ...existingDoc,
      baseTitle: sanitizedTitle,
      title: sanitizedTitle,
      version: 1,
      parentVersionId: undefined,
      modifiedAt: new Date().toISOString(),
    };
    
    saveLocalDocument(renamedDoc);
    logger.log('üíæ Document renamed locally:', renamedDoc.id);
    
    return renamedDoc;
  }
}

// ============================================================================
// Utility Functions
// ============================================================================

/**
 * Get the latest version of a document by baseTitle
 */
export async function getLatestVersion(
  projectId: string,
  baseTitle: string
): Promise<ProjectDocument | null> {
  const versions = await getDocumentVersions(projectId, baseTitle);
  
  if (versions.length === 0) {
    return null;
  }
  
  return versions[versions.length - 1];
}

/**
 * Check if a document has multiple versions
 */
export async function hasMultipleVersions(
  projectId: string,
  baseTitle: string
): Promise<boolean> {
  const versions = await getDocumentVersions(projectId, baseTitle);
  return versions.length > 1;
}

/**
 * Get unique base titles (document groups) for a project
 */
export async function getUniqueBaseTitles(projectId: string): Promise<string[]> {
  const documents = await getAllDocuments(projectId);
  const baseTitles = new Set(documents.map(doc => doc.baseTitle));
  return Array.from(baseTitles);
}


=== FILE: lib/storage/folder-storage.ts ===

/**
 * @file lib/storage/folder-storage.ts
 * @description Folder storage layer for document organization
 * 
 * Provides CRUD operations for folders within projects.
 * Folders support hierarchical nesting via parentFolderId.
 * 
 * Folder Hierarchy:
 * - Top-level folders: parentFolderId is undefined/null (sits at project root)
 * - Nested folders: parentFolderId points to another folder (subfolder)
 */

'use client';

import type { Folder, ProjectDocument } from '@/lib/types/project';
import { getProject, getAllProjects } from './project-storage';
import {
  ensureStorageAvailable,
  validateNotEmpty,
  logError,
  logWarning,
} from '@/lib/utils/error-handling';

// Storage key for projects (used for direct localStorage updates)
const STORAGE_KEY = 'copyworx_projects';

// ============================================================================
// Constants
// ============================================================================

/** Maximum folder name length */
const MAX_FOLDER_NAME_LENGTH = 100;

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Generate a unique ID for folders
 * Uses crypto.randomUUID() if available, falls back to timestamp-based ID
 */
function generateId(): string {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  // Fallback for environments without crypto.randomUUID
  return `folder-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
}

/**
 * Validate folder name
 * @throws Error if name is invalid
 */
function validateFolderName(name: string): void {
  validateNotEmpty(name, 'Folder name');
  
  const trimmed = name.trim();
  
  if (trimmed.length > MAX_FOLDER_NAME_LENGTH) {
    throw new Error(`Folder name cannot exceed ${MAX_FOLDER_NAME_LENGTH} characters.`);
  }
}

/**
 * Sanitize folder name (trim and remove unsafe characters)
 */
function sanitizeFolderName(name: string): string {
  return name.trim().replace(/[<>]/g, '');
}

/**
 * Check if moving a folder would create a circular reference
 * A circular reference occurs when:
 * - newParentId is the same as folderId (moving into itself)
 * - newParentId is a descendant of folderId (moving into a child/grandchild)
 * 
 * @param folders - All folders in the project
 * @param folderId - ID of the folder being moved
 * @param newParentId - ID of the new parent folder
 * @returns true if circular reference would be created
 */
function isCircularReference(
  folders: Folder[],
  folderId: string,
  newParentId: string
): boolean {
  // Can't move folder into itself
  if (folderId === newParentId) {
    return true;
  }
  
  // Walk up the parent chain from newParentId
  // If we find folderId, it's a circular reference
  let currentId: string | undefined = newParentId;
  const visited = new Set<string>();
  
  while (currentId) {
    // Prevent infinite loop from corrupted data
    if (visited.has(currentId)) {
      logWarning('Detected existing circular reference in folder structure', { currentId });
      return true;
    }
    visited.add(currentId);
    
    // If we reached the folder being moved, it's circular
    if (currentId === folderId) {
      return true;
    }
    
    // Find parent of current folder
    const currentFolder = folders.find(f => f.id === currentId);
    currentId = currentFolder?.parentFolderId;
  }
  
  return false;
}

/**
 * Sort folders alphabetically by name
 */
function sortFoldersByName(folders: Folder[]): Folder[] {
  return [...folders].sort((a, b) => 
    a.name.toLowerCase().localeCompare(b.name.toLowerCase())
  );
}

// ============================================================================
// CRUD Operations
// ============================================================================

/**
 * Create a new folder in a project
 * 
 * @param projectId - Project to add folder to
 * @param name - Folder name
 * @param parentFolderId - Optional parent folder ID for nesting
 * @returns The newly created folder
 * @throws Error if project not found, validation fails, or parent folder not found
 */
export function createFolder(
  projectId: string,
  name: string,
  parentFolderId?: string
): Folder {
  if (typeof window === 'undefined') {
    throw new Error('Cannot create folder in non-browser environment');
  }
  
  // Ensure storage is available
  ensureStorageAvailable();
  
  // Validate folder name
  validateFolderName(name);
  const sanitizedName = sanitizeFolderName(name);
  
  // Get project
  const project = getProject(projectId);
  if (!project) {
    throw new Error(`Project not found: ${projectId}`);
  }
  
  // Ensure folders array exists (handle legacy projects without folders)
  const folders = project.folders || [];
  
  // If parentFolderId provided, verify it exists
  if (parentFolderId) {
    const parentFolder = folders.find(f => f.id === parentFolderId);
    if (!parentFolder) {
      throw new Error(`Parent folder not found: ${parentFolderId}`);
    }
  }
  
  // Create new folder
  const now = new Date().toISOString();
  const newFolder: Folder = {
    id: generateId(),
    name: sanitizedName,
    projectId,
    parentFolderId: parentFolderId || undefined,
    createdAt: now,
    updatedAt: now,
  };
  
  // Add to project's folders array
  const updatedFolders = [...folders, newFolder];
  
  // Save to localStorage directly (don't call updateProject - it tries to sync to Supabase)
  const projects = getAllProjects();
  const updatedProjects = projects.map(p =>
    p.id === projectId ? { ...p, folders: updatedFolders } : p
  );
  localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProjects));
  
  return newFolder;
}

/**
 * Get all folders for a project
 * 
 * @param projectId - Project ID
 * @returns Array of folders sorted by name, or empty array if none
 */
export function getAllFolders(projectId: string): Folder[] {
  if (typeof window === 'undefined') return [];
  
  const project = getProject(projectId);
  if (!project) {
    logWarning(`Project not found when getting folders: ${projectId}`);
    return [];
  }
  
  // Handle legacy projects without folders array
  const folders = project.folders || [];
  
  return sortFoldersByName(folders);
}

/**
 * Get a single folder by ID
 * 
 * @param projectId - Project ID
 * @param folderId - Folder ID
 * @returns Folder or null if not found
 */
export function getFolder(projectId: string, folderId: string): Folder | null {
  if (typeof window === 'undefined') return null;
  
  const folders = getAllFolders(projectId);
  const folder = folders.find(f => f.id === folderId);
  
  if (!folder) {
    logWarning(`Folder not found: ${folderId} in project ${projectId}`);
    return null;
  }
  
  return folder;
}

/**
 * Get immediate children of a folder (or root-level folders)
 * 
 * @param projectId - Project ID
 * @param parentFolderId - Parent folder ID, or null for root-level folders
 * @returns Array of child folders sorted by name
 */
export function getFolderChildren(
  projectId: string,
  parentFolderId: string | null
): Folder[] {
  if (typeof window === 'undefined') return [];
  
  const folders = getAllFolders(projectId);
  
  // Filter by parentFolderId
  // null/undefined parentFolderId means root level
  const children = folders.filter(f => {
    if (parentFolderId === null) {
      // Root level: no parent or explicitly null/undefined
      return !f.parentFolderId;
    }
    return f.parentFolderId === parentFolderId;
  });
  
  return sortFoldersByName(children);
}

/**
 * Update a folder's properties
 * 
 * @param projectId - Project ID
 * @param folderId - Folder ID to update
 * @param updates - Partial folder updates (name only - id, projectId, createdAt protected)
 * @throws Error if folder not found or validation fails
 */
export function updateFolder(
  projectId: string,
  folderId: string,
  updates: Partial<Pick<Folder, 'name'>>
): void {
  if (typeof window === 'undefined') {
    throw new Error('Cannot update folder in non-browser environment');
  }
  
  // Ensure storage is available
  ensureStorageAvailable();
  
  // Get project
  const project = getProject(projectId);
  if (!project) {
    throw new Error(`Project not found: ${projectId}`);
  }
  
  // Find folder
  const folders = project.folders || [];
  const folderIndex = folders.findIndex(f => f.id === folderId);
  
  if (folderIndex === -1) {
    throw new Error(`Folder not found: ${folderId}`);
  }
  
  // Validate name if being updated
  if (updates.name !== undefined) {
    validateFolderName(updates.name);
  }
  
  // Update folder (protect id, projectId, createdAt)
  const existingFolder = folders[folderIndex];
  const updatedFolder: Folder = {
    ...existingFolder,
    name: updates.name !== undefined ? sanitizeFolderName(updates.name) : existingFolder.name,
    // Protected fields - always keep original values
    id: existingFolder.id,
    projectId: existingFolder.projectId,
    createdAt: existingFolder.createdAt,
    // Update timestamp
    updatedAt: new Date().toISOString(),
  };
  
  // Replace in array
  const updatedFolders = [...folders];
  updatedFolders[folderIndex] = updatedFolder;
  
  // Save to localStorage directly (don't call updateProject - it tries to sync to Supabase)
  const projects = getAllProjects();
  const updatedProjects = projects.map(p =>
    p.id === projectId ? { ...p, folders: updatedFolders } : p
  );
  localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProjects));
  
}

/**
 * Delete a folder
 * 
 * @param projectId - Project ID
 * @param folderId - Folder ID to delete
 * @throws Error if folder not found, has subfolders, or has documents
 */
export function deleteFolder(projectId: string, folderId: string): void {
  if (typeof window === 'undefined') {
    throw new Error('Cannot delete folder in non-browser environment');
  }
  
  // Ensure storage is available
  ensureStorageAvailable();
  
  // Get project
  const project = getProject(projectId);
  if (!project) {
    throw new Error(`Project not found: ${projectId}`);
  }
  
  // Find folder
  const folders = project.folders || [];
  const folderIndex = folders.findIndex(f => f.id === folderId);
  
  if (folderIndex === -1) {
    throw new Error(`Folder not found: ${folderId}`);
  }
  
  const folderToDelete = folders[folderIndex];
  
  // Check for subfolders (prevent orphans)
  const hasSubfolders = folders.some(f => f.parentFolderId === folderId);
  if (hasSubfolders) {
    throw new Error(
      `Cannot delete folder "${folderToDelete.name}" because it contains subfolders. ` +
      `Please delete or move subfolders first.`
    );
  }
  
  // Check for documents in folder (prevent data loss)
  const documents = project.documents || [];
  const hasDocuments = documents.some((d: ProjectDocument) => d.folderId === folderId);
  if (hasDocuments) {
    throw new Error(
      `Cannot delete folder "${folderToDelete.name}" because it contains documents. ` +
      `Please delete or move documents first.`
    );
  }
  
  // Remove folder from array
  const updatedFolders = folders.filter(f => f.id !== folderId);
  
  // Save to localStorage directly (don't call updateProject - it tries to sync to Supabase)
  const projects = getAllProjects();
  const updatedProjects = projects.map(p =>
    p.id === projectId ? { ...p, folders: updatedFolders } : p
  );
  localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProjects));
  
}

/**
 * Move a folder to a new parent
 * 
 * @param projectId - Project ID
 * @param folderId - Folder ID to move
 * @param newParentFolderId - New parent folder ID, or null for root level
 * @throws Error if folder not found, parent not found, or circular reference
 */
export function moveFolder(
  projectId: string,
  folderId: string,
  newParentFolderId: string | null
): void {
  if (typeof window === 'undefined') {
    throw new Error('Cannot move folder in non-browser environment');
  }
  
  // Ensure storage is available
  ensureStorageAvailable();
  
  // Get project
  const project = getProject(projectId);
  if (!project) {
    throw new Error(`Project not found: ${projectId}`);
  }
  
  // Find folder
  const folders = project.folders || [];
  const folderIndex = folders.findIndex(f => f.id === folderId);
  
  if (folderIndex === -1) {
    throw new Error(`Folder not found: ${folderId}`);
  }
  
  const folderToMove = folders[folderIndex];
  
  // Validate new parent exists (if provided)
  if (newParentFolderId !== null) {
    const newParent = folders.find(f => f.id === newParentFolderId);
    if (!newParent) {
      throw new Error(`New parent folder not found: ${newParentFolderId}`);
    }
    
    // Check for circular reference
    if (isCircularReference(folders, folderId, newParentFolderId)) {
      throw new Error(
        `Cannot move folder "${folderToMove.name}" into itself or one of its subfolders.`
      );
    }
  }
  
  // Update folder's parentFolderId
  const updatedFolder: Folder = {
    ...folderToMove,
    parentFolderId: newParentFolderId || undefined,
    updatedAt: new Date().toISOString(),
  };
  
  // Replace in array
  const updatedFolders = [...folders];
  updatedFolders[folderIndex] = updatedFolder;
  
  // Save to localStorage directly (don't call updateProject - it tries to sync to Supabase)
  const projects = getAllProjects();
  const updatedProjects = projects.map(p =>
    p.id === projectId ? { ...p, folders: updatedFolders } : p
  );
  localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProjects));
}

/**
 * Get the path from root to a folder (breadcrumb)
 * 
 * @param projectId - Project ID
 * @param folderId - Folder ID
 * @returns Array of folder names from root to the specified folder
 * 
 * @example
 * // For folder structure: Email Campaigns > Q1 Launch
 * getFolderPath(projectId, 'q1-launch-id')
 * // Returns: ["Email Campaigns", "Q1 Launch"]
 */
export function getFolderPath(projectId: string, folderId: string): string[] {
  if (typeof window === 'undefined') return [];
  
  const project = getProject(projectId);
  if (!project) {
    logWarning(`Project not found when getting folder path: ${projectId}`);
    return [];
  }
  
  const folders = project.folders || [];
  const path: string[] = [];
  const visited = new Set<string>();
  
  // Walk up the parent chain
  let currentId: string | undefined = folderId;
  
  while (currentId) {
    // Prevent infinite loop from corrupted data
    if (visited.has(currentId)) {
      logWarning('Detected circular reference in folder path', { currentId });
      break;
    }
    visited.add(currentId);
    
    const currentFolder = folders.find(f => f.id === currentId);
    if (!currentFolder) {
      // Folder not found in chain - stop walking
      break;
    }
    
    // Add to beginning of path (we're walking backward)
    path.unshift(currentFolder.name);
    
    // Move to parent
    currentId = currentFolder.parentFolderId;
  }
  
  return path;
}

// ============================================================================
// Utility Exports
// ============================================================================

/**
 * Check if a folder exists
 */
export function folderExists(projectId: string, folderId: string): boolean {
  return getFolder(projectId, folderId) !== null;
}

/**
 * Get folder count for a project
 */
export function getFolderCount(projectId: string): number {
  if (typeof window === 'undefined') return 0;
  
  const project = getProject(projectId);
  return project?.folders?.length || 0;
}

/**
 * Get all descendant folder IDs for a folder (children, grandchildren, etc.)
 * Useful for operations that need to affect a folder and all its descendants
 */
export function getAllDescendantIds(projectId: string, folderId: string): string[] {
  if (typeof window === 'undefined') return [];
  
  const project = getProject(projectId);
  if (!project) return [];
  
  const folders = project.folders || [];
  const descendants: string[] = [];
  
  // Use BFS to find all descendants
  const queue: string[] = [folderId];
  const visited = new Set<string>();
  
  while (queue.length > 0) {
    const currentId = queue.shift()!;
    
    if (visited.has(currentId)) continue;
    visited.add(currentId);
    
    // Find all children of current folder
    const children = folders.filter(f => f.parentFolderId === currentId);
    
    for (const child of children) {
      descendants.push(child.id);
      queue.push(child.id);
    }
  }
  
  return descendants;
}


=== FILE: lib/storage/persona-storage.ts ===

/**
 * @file lib/storage/persona-storage.ts
 * @description Persona storage layer with Supabase API + localStorage fallback
 * 
 * Provides CRUD operations for personas within projects.
 * Uses Supabase API calls for cloud storage with localStorage fallback.
 */

'use client';

import type { Persona } from '@/lib/types/project';
import { logger } from '@/lib/utils/logger';

// ============================================================================
// Configuration
// ============================================================================

const API_BASE = '/api/db/personas';

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Generate a unique ID for personas
 */
function generateId(): string {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `persona-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
}

/**
 * Convert API response (snake_case) to frontend format (camelCase)
 */
function mapApiToPersona(apiPersona: Record<string, unknown>): Persona {
  return {
    id: apiPersona.id as string,
    name: apiPersona.name as string,
    photoUrl: apiPersona.photo_url as string | undefined,
    demographics: apiPersona.demographics as string,
    psychographics: apiPersona.psychographics as string,
    painPoints: apiPersona.pain_points as string,
    languagePatterns: apiPersona.language_patterns as string,
    goals: apiPersona.goals as string,
    createdAt: apiPersona.created_at as string,
    updatedAt: apiPersona.updated_at as string,
  };
}

/**
 * Convert frontend persona to API format (snake_case)
 */
function mapPersonaToApi(persona: Partial<Persona>): Record<string, unknown> {
  const apiPersona: Record<string, unknown> = {};
  
  if (persona.name !== undefined) apiPersona.name = persona.name;
  if (persona.photoUrl !== undefined) apiPersona.photo_url = persona.photoUrl;
  if (persona.demographics !== undefined) apiPersona.demographics = persona.demographics;
  if (persona.psychographics !== undefined) apiPersona.psychographics = persona.psychographics;
  if (persona.painPoints !== undefined) apiPersona.pain_points = persona.painPoints;
  if (persona.languagePatterns !== undefined) apiPersona.language_patterns = persona.languagePatterns;
  if (persona.goals !== undefined) apiPersona.goals = persona.goals;
  
  return apiPersona;
}

/**
 * Validate persona name
 */
function validatePersonaName(name: string): string {
  if (!name || name.trim().length === 0) {
    throw new Error('Persona name is required');
  }
  
  const trimmed = name.trim();
  
  if (trimmed.length > 100) {
    throw new Error('Persona name cannot exceed 100 characters');
  }
  
  return trimmed;
}

/**
 * Validate photo URL size for base64 data URLs
 */
function validatePhotoUrl(photoUrl?: string): void {
  if (!photoUrl) return;
  
  if (photoUrl.startsWith('data:image/')) {
    const base64Data = photoUrl.split(',')[1];
    const sizeInBytes = Math.ceil((base64Data.length * 3) / 4);
    
    if (sizeInBytes > 2 * 1024 * 1024) { // 2MB limit
      throw new Error('Photo size too large. Please use an image smaller than 2MB.');
    }
  }
}

// ============================================================================
// localStorage Fallback Functions
// ============================================================================

const STORAGE_KEY = 'copyworx_personas';

function getLocalPersonas(projectId: string): Persona[] {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    if (!data) return [];
    const allPersonas = JSON.parse(data) as (Persona & { projectId: string })[];
    return allPersonas.filter(p => p.projectId === projectId);
  } catch {
    return [];
  }
}

function saveLocalPersona(projectId: string, persona: Persona): void {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    const allPersonas = data ? JSON.parse(data) as (Persona & { projectId: string })[] : [];
    const existingIndex = allPersonas.findIndex(p => p.id === persona.id);
    const personaWithProject = { ...persona, projectId };
    
    if (existingIndex >= 0) {
      allPersonas[existingIndex] = personaWithProject;
    } else {
      allPersonas.push(personaWithProject);
    }
    localStorage.setItem(STORAGE_KEY, JSON.stringify(allPersonas));
  } catch (error) {
    logger.error('‚ùå Failed to save persona to localStorage:', error);
  }
}

function deleteLocalPersona(personaId: string): void {
  try {
    const data = localStorage.getItem(STORAGE_KEY);
    if (!data) return;
    const allPersonas = JSON.parse(data) as (Persona & { projectId: string })[];
    const filtered = allPersonas.filter(p => p.id !== personaId);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(filtered));
  } catch (error) {
    logger.error('‚ùå Failed to delete persona from localStorage:', error);
  }
}

// ============================================================================
// API Call Wrapper
// ============================================================================

async function apiCall<T>(
  url: string, 
  options?: RequestInit
): Promise<T> {
  const response = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
  });
  
  if (!response.ok) {
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || `API error: ${response.status}`);
  }
  
  return response.json();
}

// ============================================================================
// CRUD Operations (API-first with localStorage fallback)
// ============================================================================

/**
 * Create a new persona in the specified project
 */
export async function createPersona(
  projectId: string,
  personaData: Omit<Persona, 'id' | 'createdAt' | 'updatedAt'>
): Promise<Persona> {
  if (typeof window === 'undefined') {
    throw new Error('Cannot create persona in non-browser environment');
  }
  
  // Validate
  const validatedName = validatePersonaName(personaData.name);
  validatePhotoUrl(personaData.photoUrl);
  
  const now = new Date().toISOString();
  
  const apiData = {
    project_id: projectId,
    name: validatedName,
    photo_url: personaData.photoUrl,
    demographics: personaData.demographics?.trim() || '',
    psychographics: personaData.psychographics?.trim() || '',
    pain_points: personaData.painPoints?.trim() || '',
    language_patterns: personaData.languagePatterns?.trim() || '',
    goals: personaData.goals?.trim() || '',
  };
  
  try {
    const apiResponse = await apiCall<Record<string, unknown>>(API_BASE, {
      method: 'POST',
      body: JSON.stringify(apiData),
    });
    
    const newPersona = mapApiToPersona(apiResponse);
    logger.log('‚òÅÔ∏è Persona created in cloud:', newPersona.id);
    
    // Also save to localStorage for offline access
    saveLocalPersona(projectId, newPersona);
    
    return newPersona;
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    // Fallback: create locally
    const newPersona: Persona = {
      id: generateId(),
      name: validatedName,
      photoUrl: personaData.photoUrl,
      demographics: personaData.demographics?.trim() || '',
      psychographics: personaData.psychographics?.trim() || '',
      painPoints: personaData.painPoints?.trim() || '',
      languagePatterns: personaData.languagePatterns?.trim() || '',
      goals: personaData.goals?.trim() || '',
      createdAt: now,
      updatedAt: now,
    };
    
    saveLocalPersona(projectId, newPersona);
    logger.log('üíæ Persona created locally:', newPersona.id);
    
    return newPersona;
  }
}

/**
 * Get all personas for a project
 */
export async function getProjectPersonas(projectId: string): Promise<Persona[]> {
  if (typeof window === 'undefined') return [];
  
  try {
    const apiResponse = await apiCall<Record<string, unknown>[]>(
      `${API_BASE}?project_id=${encodeURIComponent(projectId)}`
    );
    
    const personas = apiResponse.map(mapApiToPersona);
    logger.log(`‚òÅÔ∏è Fetched ${personas.length} personas from cloud`);
    
    // Update localStorage with latest data
    personas.forEach(persona => saveLocalPersona(projectId, persona));
    
    return personas;
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    const localPersonas = getLocalPersonas(projectId);
    logger.log(`üíæ Loaded ${localPersonas.length} personas from localStorage`);
    
    return localPersonas;
  }
}

/**
 * Get a single persona by ID
 */
export async function getPersona(
  projectId: string,
  personaId: string
): Promise<Persona | null> {
  if (typeof window === 'undefined') return null;
  
  try {
    const apiResponse = await apiCall<Record<string, unknown>>(
      `${API_BASE}?id=${encodeURIComponent(personaId)}`
    );
    
    const persona = mapApiToPersona(apiResponse);
    logger.log('‚òÅÔ∏è Persona fetched from cloud:', persona.id);
    saveLocalPersona(projectId, persona);
    
    return persona;
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    const localPersonas = getLocalPersonas(projectId);
    const persona = localPersonas.find(p => p.id === personaId) || null;
    
    if (persona) {
      logger.log('üíæ Persona loaded from localStorage:', persona.id);
    } else {
      logger.warn(`‚ö†Ô∏è Persona not found: ${personaId}`);
    }
    
    return persona;
  }
}

/**
 * Update an existing persona
 */
export async function updatePersona(
  projectId: string,
  personaId: string,
  updates: Partial<Omit<Persona, 'id' | 'createdAt'>>
): Promise<void> {
  if (typeof window === 'undefined') {
    throw new Error('Cannot update persona in non-browser environment');
  }
  
  // Validate if name is being updated
  if (updates.name !== undefined) {
    updates.name = validatePersonaName(updates.name);
  }
  
  // Validate photo if being updated
  validatePhotoUrl(updates.photoUrl);
  
  try {
    await apiCall(API_BASE, {
      method: 'PUT',
      body: JSON.stringify({
        id: personaId,
        ...mapPersonaToApi(updates),
      }),
    });
    
    logger.log('‚òÅÔ∏è Persona updated in cloud:', personaId);
    
    // Update localStorage
    const existingPersona = await getPersona(projectId, personaId);
    if (existingPersona) {
      const updatedPersona = { ...existingPersona, ...updates, updatedAt: new Date().toISOString() };
      saveLocalPersona(projectId, updatedPersona);
    }
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    // Fallback: update locally
    const localPersonas = getLocalPersonas(projectId);
    const personaIndex = localPersonas.findIndex(p => p.id === personaId);
    
    if (personaIndex === -1) {
      throw new Error(`Persona not found: ${personaId}`);
    }
    
    const updatedPersona = {
      ...localPersonas[personaIndex],
      ...updates,
      updatedAt: new Date().toISOString(),
    };
    
    saveLocalPersona(projectId, updatedPersona);
    logger.log('üíæ Persona updated locally:', personaId);
  }
}

/**
 * Delete a persona
 */
export async function deletePersona(
  projectId: string,
  personaId: string
): Promise<void> {
  if (typeof window === 'undefined') {
    throw new Error('Cannot delete persona in non-browser environment');
  }
  
  try {
    await apiCall(`${API_BASE}?id=${encodeURIComponent(personaId)}`, {
      method: 'DELETE',
    });
    
    logger.log('‚òÅÔ∏è Persona deleted from cloud:', personaId);
    deleteLocalPersona(personaId);
  } catch (error) {
    logger.warn('‚ö†Ô∏è API failed, falling back to localStorage:', error);
    
    deleteLocalPersona(personaId);
    logger.log('üíæ Persona deleted locally:', personaId);
  }
}

/**
 * Validate image file before upload
 * This function should be called from components before creating persona with photo
 */
export function validatePersonaPhoto(file: File): void {
  // Check file type
  const validTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  if (!validTypes.includes(file.type)) {
    throw new Error('Invalid image type. Please use JPEG, PNG, GIF, or WebP.');
  }
  
  // Check file size (2MB limit)
  if (file.size > 2 * 1024 * 1024) {
    throw new Error('Photo size too large. Please use an image smaller than 2MB.');
  }
}


=== FILE: lib/storage/project-storage.ts ===

/**
 * @file lib/storage/project-storage.ts
 * @description Project storage layer using localStorage
 * 
 * Provides CRUD operations for projects with automatic persistence.
 * Handles serialization, error handling, and default project creation.
 */

'use client';

import type { Project } from '@/lib/types/project';
import type { BrandVoice } from '@/lib/types/brand';
import { 
  ensureStorageAvailable, 
  checkStorageQuota, 
  validateProjectName,
  logError,
  logWarning
} from '@/lib/utils/error-handling';
import { logger } from '@/lib/utils/logger';

/** localStorage key for projects array */
const PROJECTS_KEY = 'copyworx_projects';

/** localStorage key for active project ID */
const ACTIVE_PROJECT_KEY = 'copyworx_active_project_id';

/** Default project name for first-time users */
const DEFAULT_PROJECT_NAME = 'My First Project';

/**
 * Generate a unique ID for projects
 * Uses crypto.randomUUID() if available, falls back to timestamp-based ID
 */
function generateId(): string {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  // Fallback for environments without crypto.randomUUID
  return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
}

/**
 * Safely parse JSON from localStorage with array validation
 * CRITICAL: Validates that parsed data is actually an array
 */
function safeParseJSON<T>(json: string | null, fallback: T): T {
  if (!json) return fallback;
  
  try {
    const parsed = JSON.parse(json);
    
    // CRITICAL FIX: Validate that parsed data is an array if fallback is an array
    if (Array.isArray(fallback) && !Array.isArray(parsed)) {
      logger.warn('‚ö†Ô∏è localStorage data is not an array, resetting to empty array');
      return fallback;
    }
    
    return parsed as T;
  } catch (error) {
    logger.error('‚ùå Failed to parse JSON from localStorage:', error);
    return fallback;
  }
}

/**
 * Safely write to localStorage
 * @throws Error if storage quota exceeded
 */
function safeSetItem(key: string, value: string): boolean {
  try {
    // Check storage quota before writing
    const usage = checkStorageQuota();
    if (usage > 90) {
      logWarning(`Storage is ${usage.toFixed(1)}% full. Consider clearing old data.`);
    }
    
    localStorage.setItem(key, value);
    return true;
  } catch (error) {
    // Handle quota exceeded error specifically
    if (error instanceof DOMException && error.code === 22) {
      logError(error, 'localStorage quota exceeded');
      throw new Error(
        'Storage quota exceeded. Please clear some data to continue. ' +
        'You can delete old projects or brand voice data to free up space.'
      );
    }
    
    logError(error, `Failed to write to localStorage (${key})`);
    throw new Error('Failed to save data. Please try again.');
  }
}

/**
 * Get all projects from localStorage
 * CRITICAL: Always returns an array, even if localStorage is corrupted
 * CRITICAL: Ensures each project has proper array fields to prevent ".find is not a function" errors
 */
export function getAllProjects(): Project[] {
  if (typeof window === 'undefined') return [];
  
  try {
    const stored = localStorage.getItem(PROJECTS_KEY);
    const projects = safeParseJSON<Project[]>(stored, []);
    
    // EXTRA SAFETY: Double-check it's an array
    if (!Array.isArray(projects)) {
      logger.error('‚ùå Projects data corrupted, resetting to empty array');
      localStorage.setItem(PROJECTS_KEY, JSON.stringify([]));
      return [];
    }
    
    // CRITICAL FIX: Ensure each project has required array fields
    // This prevents ".find is not a function" errors from legacy/corrupted data
    const sanitizedProjects = projects.map((project) => ({
      ...project,
      personas: Array.isArray(project.personas) ? project.personas : [],
      folders: Array.isArray(project.folders) ? project.folders : [],
      documents: Array.isArray(project.documents) ? project.documents : [],
      snippets: Array.isArray(project.snippets) ? project.snippets : [],
    }));
    
    return sanitizedProjects;
  } catch (error) {
    logger.error('‚ùå Failed to get projects:', error);
    // Reset corrupted data
    try {
      localStorage.setItem(PROJECTS_KEY, JSON.stringify([]));
    } catch (e) {
      // Ignore if we can't even write
    }
    return [];
  }
}

/**
 * Save projects array to localStorage
 */
function saveProjects(projects: Project[]): boolean {
  if (typeof window === 'undefined') return false;
  
  try {
    const json = JSON.stringify(projects);
    return safeSetItem(PROJECTS_KEY, json);
  } catch (error) {
    logger.error('‚ùå Failed to save projects:', error);
    return false;
  }
}

/**
 * Create a new project
 * @throws Error if validation fails or storage unavailable
 */
export function createProject(name: string): Project {
  if (typeof window === 'undefined') {
    throw new Error('Cannot create project in non-browser environment');
  }
  
  // Ensure storage is available
  ensureStorageAvailable();
  
  // Validate project name
  validateProjectName(name);
  const trimmedName = name.trim();
  
  // Sanitize project name (prevent XSS)
  const sanitizedName = trimmedName.replace(/[<>]/g, '');
  
  // Create new project
  const newProject: Project = {
    id: generateId(),
    name: sanitizedName,
    brandVoice: null,
    personas: [],
    folders: [],
    documents: [],
    snippets: [],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };
  
  // Get existing projects
  const projects = getAllProjects();
  
  // Add new project
  projects.push(newProject);
  
  // Save to localStorage (may throw error if quota exceeded)
  saveProjects(projects);
  
  return newProject;
}

/**
 * Get project by ID
 */
export function getProject(id: string): Project | null {
  if (typeof window === 'undefined') return null;
  
  const projects = getAllProjects();
  const project = projects.find((p) => p.id === id);
  
  if (!project) {
    logger.warn(`‚ö†Ô∏è Project not found: ${id}`);
    return null;
  }
  
  return project;
}

/**
 * Update project
 * @throws Error if project not found or validation fails
 */
export function updateProject(id: string, updates: Partial<Project>): void {
  if (typeof window === 'undefined') {
    throw new Error('Cannot update project in non-browser environment');
  }
  
  // Ensure storage is available
  ensureStorageAvailable();
  
  const projects = getAllProjects();
  const index = projects.findIndex((p) => p.id === id);
  
  if (index === -1) {
    throw new Error(`Project not found: ${id}`);
  }
  
  // Validate name if it's being updated
  if (updates.name !== undefined) {
    validateProjectName(updates.name);
  }
  
  // Update project
  projects[index] = {
    ...projects[index],
    ...updates,
    id: projects[index].id, // Prevent ID change
    updatedAt: new Date().toISOString(),
  };
  
  // Save to localStorage (may throw error if quota exceeded)
  saveProjects(projects);
  
}

/**
 * Delete project
 * Note: Caller is responsible for ensuring at least one project exists
 * (e.g., create a default project first if deleting the last one)
 */
export function deleteProject(id: string): void {
  if (typeof window === 'undefined') {
    throw new Error('Cannot delete project in non-browser environment');
  }
  
  const projects = getAllProjects();
  
  const index = projects.findIndex((p) => p.id === id);
  
  if (index === -1) {
    throw new Error(`Project not found: ${id}`);
  }
  
  // Remove project
  const deletedProject = projects[index];
  projects.splice(index, 1);
  
  // Save to localStorage
  const saved = saveProjects(projects);
  
  // If deleted project was active, switch to first available project
  const activeId = getActiveProjectId();
  if (activeId === id && projects.length > 0) {
    setActiveProjectId(projects[0].id);
  }
}

/**
 * Get active project ID
 */
export function getActiveProjectId(): string | null {
  if (typeof window === 'undefined') return null;
  
  try {
    return localStorage.getItem(ACTIVE_PROJECT_KEY);
  } catch (error) {
    logger.error('‚ùå Failed to get active project ID:', error);
    return null;
  }
}

/**
 * Set active project ID
 */
export function setActiveProjectId(id: string): void {
  if (typeof window === 'undefined') {
    throw new Error('Cannot set active project in non-browser environment');
  }
  
  // Verify project exists
  const project = getProject(id);
  if (!project) {
    throw new Error(`Cannot set active project: Project not found (${id})`);
  }
  
  // Save to localStorage
  const saved = safeSetItem(ACTIVE_PROJECT_KEY, id);
  
  if (saved) {
    logger.log('‚úÖ Active project set:', {
      id: project.id,
      name: project.name,
    });
  }
}

/**
 * Save brand voice to project
 * @throws Error if validation fails or storage unavailable
 */
export function saveBrandVoiceToProject(projectId: string, brandVoice: BrandVoice): void {
  if (typeof window === 'undefined') {
    throw new Error('Cannot save brand voice in non-browser environment');
  }
  
  // Ensure storage is available
  ensureStorageAvailable();
  
  // Get project to verify it exists
  const project = getProject(projectId);
  if (!project) {
    throw new Error(`Project not found: ${projectId}`);
  }
  
  // Update localStorage directly (don't call updateProject - it tries to sync to Supabase)
  const projects = getAllProjects();
  const updatedProjects = projects.map(p => 
    p.id === projectId ? { ...p, brandVoice } : p
  );
  
  localStorage.setItem(PROJECTS_KEY, JSON.stringify(updatedProjects));
  
  logger.log('‚úÖ Brand voice saved to project (localStorage):', {
    projectId,
    brandName: brandVoice.brandName,
  });
}

/**
 * Delete brand voice from project
 * @throws Error if project not found or storage unavailable
 */
export function deleteBrandVoiceFromProject(projectId: string): void {
  if (typeof window === 'undefined') {
    throw new Error('Cannot delete brand voice in non-browser environment');
  }
  
  // Ensure storage is available
  ensureStorageAvailable();
  
  // Get project to verify it exists
  const project = getProject(projectId);
  if (!project) {
    throw new Error(`Project not found: ${projectId}`);
  }
  
  // Update localStorage directly (don't call updateProject - it tries to sync to Supabase)
  const projects = getAllProjects();
  const updatedProjects = projects.map(p => 
    p.id === projectId ? { ...p, brandVoice: undefined } : p
  );
  
  localStorage.setItem(PROJECTS_KEY, JSON.stringify(updatedProjects));
  
  logger.log('üóëÔ∏è Brand voice deleted from project (localStorage):', {
    projectId,
  });
}

/**
 * Initialize default project if none exist
 * Called on first app load
 */
export function ensureDefaultProject(): void {
  if (typeof window === 'undefined') return;
  
  const projects = getAllProjects();
  
  if (projects.length === 0) {
    logger.log('üÜï No projects found. Creating default project...');
    const defaultProject = createProject(DEFAULT_PROJECT_NAME);
    setActiveProjectId(defaultProject.id);
  }
}

/**
 * Get current active project
 * Returns null if no active project or project not found
 */
export function getCurrentProject(): Project | null {
  const activeId = getActiveProjectId();
  if (!activeId) return null;
  
  return getProject(activeId);
}


=== FILE: lib/storage/snippet-storage.ts ===

/**
 * @file lib/storage/snippet-storage.ts
 * @description Snippet storage layer using localStorage
 * 
 * Provides CRUD operations for project-scoped snippets.
 * Snippets are stored within the project's data structure,
 * similar to how documents are stored.
 */

'use client';

import type { Snippet, CreateSnippetInput, UpdateSnippetInput } from '@/lib/types/snippet';
import { validateSnippetName, validateSnippetContent } from '@/lib/types/snippet';
import { getProject, getAllProjects } from './project-storage';
import { logError, logWarning } from '@/lib/utils/error-handling';
import { logger } from '@/lib/utils/logger';
import type { Project } from '@/lib/types/project';

// Storage key for projects (used for direct localStorage updates)
const STORAGE_KEY = 'copyworx_projects';

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Generate a unique ID for snippets
 * Uses crypto.randomUUID() if available, falls back to timestamp-based ID
 */
function generateId(): string {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `snippet-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
}

/**
 * Sanitize text to prevent XSS
 * Removes < and > characters from names/descriptions
 */
function sanitizeText(text: string): string {
  return text.trim().replace(/[<>]/g, '');
}

/**
 * Get snippets array from project, initializing if needed
 */
function getProjectSnippets(projectId: string): Snippet[] {
  const project = getProject(projectId);
  if (!project) {
    logWarning(`Project not found when getting snippets: ${projectId}`);
    return [];
  }
  
  // Ensure snippets array exists (for backward compatibility)
  if (!Array.isArray(project.snippets)) {
    return [];
  }
  
  return project.snippets;
}

/**
 * Save snippets array to project (localStorage only)
 */
function saveProjectSnippets(projectId: string, snippets: Snippet[]): void {
  // Save to localStorage directly (don't call updateProject - it tries to sync to Supabase)
  const projects = getAllProjects();
  const updatedProjects: Project[] = projects.map(p =>
    p.id === projectId ? { ...p, snippets } : p
  );
  localStorage.setItem(STORAGE_KEY, JSON.stringify(updatedProjects));
}

// ============================================================================
// CRUD Operations
// ============================================================================

/**
 * Create a new snippet in a project
 * 
 * @param projectId - ID of the project to add snippet to
 * @param input - Snippet creation input (name, content, etc.)
 * @returns The newly created snippet
 * @throws Error if project not found or validation fails
 */
export function createSnippet(
  projectId: string,
  input: CreateSnippetInput
): Snippet {
  if (typeof window === 'undefined') {
    throw new Error('Cannot create snippet in non-browser environment');
  }
  
  // Validate inputs
  validateSnippetName(input.name);
  validateSnippetContent(input.content);
  
  // Get project to verify it exists
  const project = getProject(projectId);
  if (!project) {
    throw new Error(`Project not found: ${projectId}`);
  }
  
  // Create timestamp
  const now = new Date().toISOString();
  
  // Create new snippet
  const newSnippet: Snippet = {
    id: generateId(),
    projectId,
    name: sanitizeText(input.name),
    content: input.content, // Don't sanitize content - may have valid HTML
    description: input.description ? sanitizeText(input.description) : undefined,
    tags: input.tags?.map(tag => sanitizeText(tag)),
    createdAt: now,
    modifiedAt: now,
    usageCount: 0,
  };
  
  // Get existing snippets and add new one
  const snippets = getProjectSnippets(projectId);
  const updatedSnippets = [...snippets, newSnippet];
  
  // Save to project
  saveProjectSnippets(projectId, updatedSnippets);
  
  logger.log('‚úÖ Snippet created:', {
    id: newSnippet.id,
    name: newSnippet.name,
    projectId,
  });
  
  return newSnippet;
}

/**
 * Get all snippets for a project
 * 
 * @param projectId - ID of the project
 * @returns Array of snippets sorted by modifiedAt (newest first)
 */
export function getAllSnippets(projectId: string): Snippet[] {
  if (typeof window === 'undefined') return [];
  
  try {
    const snippets = getProjectSnippets(projectId);
    
    // Sort by modifiedAt (newest first)
    const sorted = [...snippets].sort((a, b) => {
      const dateA = new Date(a.modifiedAt).getTime();
      const dateB = new Date(b.modifiedAt).getTime();
      return dateB - dateA;
    });
    
    logger.log(`üìé Loaded ${sorted.length} snippet(s) for project ${projectId}`);
    
    return sorted;
  } catch (error) {
    logError(error, `Failed to get snippets for project ${projectId}`);
    return [];
  }
}

/**
 * Get a single snippet by ID
 * 
 * @param projectId - ID of the project
 * @param snippetId - ID of the snippet
 * @returns The snippet or null if not found
 */
export function getSnippet(
  projectId: string,
  snippetId: string
): Snippet | null {
  if (typeof window === 'undefined') return null;
  
  try {
    const snippets = getProjectSnippets(projectId);
    const snippet = snippets.find(s => s.id === snippetId);
    
    if (!snippet) {
      logger.warn(`‚ö†Ô∏è Snippet not found: ${snippetId} in project ${projectId}`);
      return null;
    }
    
    return snippet;
  } catch (error) {
    logError(error, `Failed to get snippet ${snippetId}`);
    return null;
  }
}

/**
 * Update a snippet
 * 
 * @param projectId - ID of the project
 * @param snippetId - ID of the snippet to update
 * @param updates - Partial snippet updates
 * @returns The updated snippet
 * @throws Error if project or snippet not found, or validation fails
 */
export function updateSnippet(
  projectId: string,
  snippetId: string,
  updates: UpdateSnippetInput
): Snippet {
  if (typeof window === 'undefined') {
    throw new Error('Cannot update snippet in non-browser environment');
  }
  
  // Validate updates if provided
  if (updates.name !== undefined) {
    validateSnippetName(updates.name);
  }
  if (updates.content !== undefined) {
    validateSnippetContent(updates.content);
  }
  
  // Get existing snippets
  const snippets = getProjectSnippets(projectId);
  const snippetIndex = snippets.findIndex(s => s.id === snippetId);
  
  if (snippetIndex === -1) {
    throw new Error(`Snippet not found: ${snippetId}`);
  }
  
  const existingSnippet = snippets[snippetIndex];
  
  // Merge updates with existing snippet
  const updatedSnippet: Snippet = {
    ...existingSnippet,
    name: updates.name !== undefined ? sanitizeText(updates.name) : existingSnippet.name,
    content: updates.content !== undefined ? updates.content : existingSnippet.content,
    description: updates.description !== undefined 
      ? sanitizeText(updates.description) 
      : existingSnippet.description,
    tags: updates.tags !== undefined 
      ? updates.tags.map(tag => sanitizeText(tag)) 
      : existingSnippet.tags,
    modifiedAt: new Date().toISOString(),
  };
  
  // Update snippets array
  const updatedSnippets = [...snippets];
  updatedSnippets[snippetIndex] = updatedSnippet;
  
  // Save to project
  saveProjectSnippets(projectId, updatedSnippets);
  
  logger.log('‚úÖ Snippet updated:', {
    id: updatedSnippet.id,
    name: updatedSnippet.name,
    projectId,
  });
  
  return updatedSnippet;
}

/**
 * Delete a snippet
 * 
 * @param projectId - ID of the project
 * @param snippetId - ID of the snippet to delete
 * @throws Error if project or snippet not found
 */
export function deleteSnippet(projectId: string, snippetId: string): void {
  if (typeof window === 'undefined') {
    throw new Error('Cannot delete snippet in non-browser environment');
  }
  
  // Get existing snippets
  const snippets = getProjectSnippets(projectId);
  const snippetIndex = snippets.findIndex(s => s.id === snippetId);
  
  if (snippetIndex === -1) {
    throw new Error(`Snippet not found: ${snippetId}`);
  }
  
  const deletedSnippet = snippets[snippetIndex];
  
  // Remove snippet from array
  const updatedSnippets = snippets.filter(s => s.id !== snippetId);
  
  // Save to project
  saveProjectSnippets(projectId, updatedSnippets);
  
  logger.log('üóëÔ∏è Snippet deleted:', {
    id: deletedSnippet.id,
    name: deletedSnippet.name,
    projectId,
  });
}

/**
 * Increment usage count for a snippet
 * Called when snippet is inserted into a document
 * 
 * @param projectId - ID of the project
 * @param snippetId - ID of the snippet
 */
export function incrementSnippetUsage(projectId: string, snippetId: string): void {
  if (typeof window === 'undefined') return;
  
  try {
    const snippets = getProjectSnippets(projectId);
    const snippetIndex = snippets.findIndex(s => s.id === snippetId);
    
    if (snippetIndex === -1) {
      logger.warn(`‚ö†Ô∏è Snippet not found for usage increment: ${snippetId}`);
      return;
    }
    
    // Increment usage count
    const updatedSnippets = [...snippets];
    updatedSnippets[snippetIndex] = {
      ...updatedSnippets[snippetIndex],
      usageCount: (updatedSnippets[snippetIndex].usageCount || 0) + 1,
    };
    
    // Save to project
    saveProjectSnippets(projectId, updatedSnippets);
    
    logger.log('üìä Snippet usage incremented:', {
      id: snippetId,
      newCount: updatedSnippets[snippetIndex].usageCount,
    });
  } catch (error) {
    logError(error, `Failed to increment snippet usage: ${snippetId}`);
  }
}

// ============================================================================
// Search & Filter Functions
// ============================================================================

/**
 * Search snippets by name or content
 * 
 * @param projectId - ID of the project
 * @param query - Search query string
 * @returns Filtered array of snippets matching the query
 */
export function searchSnippets(projectId: string, query: string): Snippet[] {
  if (!query || query.trim().length === 0) {
    return getAllSnippets(projectId);
  }
  
  const snippets = getAllSnippets(projectId);
  const lowerQuery = query.toLowerCase().trim();
  
  return snippets.filter(snippet => {
    const nameMatch = snippet.name.toLowerCase().includes(lowerQuery);
    const contentMatch = snippet.content.toLowerCase().includes(lowerQuery);
    const descriptionMatch = snippet.description?.toLowerCase().includes(lowerQuery);
    const tagMatch = snippet.tags?.some(tag => tag.toLowerCase().includes(lowerQuery));
    
    return nameMatch || contentMatch || descriptionMatch || tagMatch;
  });
}

/**
 * Get snippets by tag
 * 
 * @param projectId - ID of the project
 * @param tag - Tag to filter by
 * @returns Filtered array of snippets with the specified tag
 */
export function getSnippetsByTag(projectId: string, tag: string): Snippet[] {
  const snippets = getAllSnippets(projectId);
  const lowerTag = tag.toLowerCase().trim();
  
  return snippets.filter(snippet => 
    snippet.tags?.some(t => t.toLowerCase() === lowerTag)
  );
}

/**
 * Get all unique tags used in project snippets
 * 
 * @param projectId - ID of the project
 * @returns Array of unique tags sorted alphabetically
 */
export function getAllSnippetTags(projectId: string): string[] {
  const snippets = getAllSnippets(projectId);
  const tagSet = new Set<string>();
  
  snippets.forEach(snippet => {
    snippet.tags?.forEach(tag => tagSet.add(tag));
  });
  
  return Array.from(tagSet).sort((a, b) => a.localeCompare(b));
}

/**
 * Get most frequently used snippets
 * 
 * @param projectId - ID of the project
 * @param limit - Maximum number of snippets to return (default 5)
 * @returns Array of snippets sorted by usage count (highest first)
 */
export function getMostUsedSnippets(projectId: string, limit: number = 5): Snippet[] {
  const snippets = getAllSnippets(projectId);
  
  return [...snippets]
    .sort((a, b) => (b.usageCount || 0) - (a.usageCount || 0))
    .slice(0, limit);
}


=== FILE: lib/storage/supabase-storage.ts ===

/**
 * @file lib/storage/supabase-storage.ts
 * @description Supabase-based storage layer for CopyWorx
 * 
 * This module provides an abstraction layer over the Supabase API routes,
 * offering a similar interface to the localStorage-based storage while
 * enabling cloud persistence and cross-device sync.
 * 
 * ARCHITECTURE:
 * - Browser calls these functions
 * - Functions call API routes (/api/db/*)
 * - API routes interact with Supabase
 * - Data syncs across devices
 */

'use client';

import { isSupabaseConfigured } from '@/lib/supabase';
import type { Project, Persona, Folder, ProjectDocument } from '@/lib/types/project';
import type { BrandVoice } from '@/lib/types/brand';
import type { Snippet, CreateSnippetInput, UpdateSnippetInput } from '@/lib/types/snippet';
import { logger } from '@/lib/utils/logger';

// ============================================================================
// Types
// ============================================================================

interface ApiError {
  error: string;
  details?: string;
}

interface SyncedProject {
  id: string;
  name: string;
  brandVoice: BrandVoice | null;
  personas: Persona[];
  folders: Folder[];
  documents: ProjectDocument[];
  snippets: Snippet[];
  createdAt: string;
  updatedAt: string;
}

interface SyncResponse {
  projects: SyncedProject[];
  activeProjectId: string | null;
  lastSyncedAt: string;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Check if Supabase storage is available
 */
export function isCloudStorageAvailable(): boolean {
  return isSupabaseConfigured();
}

/**
 * Generic API call wrapper with error handling
 */
async function apiCall<T>(
  url: string,
  options?: RequestInit
): Promise<T> {
  const response = await fetch(url, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options?.headers,
    },
  });

  if (!response.ok) {
    const errorData: ApiError = await response.json().catch(() => ({
      error: 'Request failed',
      details: `Status: ${response.status}`,
    }));
    throw new Error(errorData.details || errorData.error);
  }

  return response.json();
}

// ============================================================================
// Sync Operations
// ============================================================================

/**
 * Fetch all projects with nested data from Supabase
 * Returns data in the format expected by the application
 */
export async function syncAllProjects(): Promise<{
  projects: Project[];
  activeProjectId: string | null;
}> {
  if (!isCloudStorageAvailable()) {
    throw new Error('Cloud storage is not configured');
  }

  const data = await apiCall<SyncResponse>('/api/db/sync');

  // Convert synced projects to the Project format
  const projects: Project[] = data.projects.map(sp => ({
    id: sp.id,
    name: sp.name,
    brandVoice: sp.brandVoice,
    personas: sp.personas,
    folders: sp.folders,
    documents: sp.documents,
    snippets: sp.snippets,
    createdAt: sp.createdAt,
    updatedAt: sp.updatedAt,
  }));

  return {
    projects,
    activeProjectId: data.activeProjectId,
  };
}

// ============================================================================
// Project Operations
// ============================================================================

/**
 * Create a new project in Supabase
 */
export async function cloudCreateProject(name: string): Promise<Project> {
  const data = await apiCall<{ id: string; name: string; created_at: string; updated_at: string }>(
    '/api/db/projects',
    {
      method: 'POST',
      body: JSON.stringify({ name }),
    }
  );

  // Return in Project format with empty arrays for nested data
  return {
    id: data.id,
    name: data.name,
    brandVoice: null,
    personas: [],
    folders: [],
    documents: [],
    snippets: [],
    createdAt: data.created_at,
    updatedAt: data.updated_at,
  };
}

/**
 * Update a project in Supabase
 */
export async function cloudUpdateProject(
  id: string,
  updates: Partial<Pick<Project, 'name'>>
): Promise<void> {
  await apiCall('/api/db/projects', {
    method: 'PUT',
    body: JSON.stringify({ id, ...updates }),
  });
}

/**
 * Delete a project from Supabase
 */
export async function cloudDeleteProject(id: string): Promise<void> {
  await apiCall(`/api/db/projects?id=${id}`, {
    method: 'DELETE',
  });
}

// ============================================================================
// Document Operations
// ============================================================================

/**
 * Create a new document in Supabase
 */
export async function cloudCreateDocument(
  projectId: string,
  baseTitle: string,
  content: string = '',
  options?: {
    version?: number;
    parentVersionId?: string;
    folderId?: string;
    metadata?: Record<string, unknown>;
    templateProgress?: unknown;
  }
): Promise<ProjectDocument> {
  const data = await apiCall<Record<string, unknown>>('/api/db/documents', {
    method: 'POST',
    body: JSON.stringify({
      project_id: projectId,
      base_title: baseTitle,
      title: options?.version && options.version > 1 
        ? `${baseTitle} v${options.version}` 
        : baseTitle,
      content,
      version: options?.version || 1,
      parent_version_id: options?.parentVersionId,
      folder_id: options?.folderId,
      metadata: options?.metadata || {},
      template_progress: options?.templateProgress,
    }),
  });

  return {
    id: data.id as string,
    projectId: data.project_id as string,
    baseTitle: data.base_title as string,
    title: data.title as string,
    version: data.version as number,
    parentVersionId: data.parent_version_id as string | undefined,
    folderId: data.folder_id as string | undefined,
    content: data.content as string,
    createdAt: data.created_at as string,
    modifiedAt: data.modified_at as string,
    metadata: data.metadata as ProjectDocument['metadata'],
    templateProgress: data.template_progress as ProjectDocument['templateProgress'],
  };
}

/**
 * Update a document in Supabase
 */
export async function cloudUpdateDocument(
  id: string,
  updates: Partial<Pick<ProjectDocument, 'baseTitle' | 'title' | 'content' | 'folderId' | 'metadata' | 'templateProgress'>>
): Promise<void> {
  const apiUpdates: Record<string, unknown> = {};
  
  if (updates.baseTitle !== undefined) apiUpdates.base_title = updates.baseTitle;
  if (updates.title !== undefined) apiUpdates.title = updates.title;
  if (updates.content !== undefined) apiUpdates.content = updates.content;
  if (updates.folderId !== undefined) apiUpdates.folder_id = updates.folderId;
  if (updates.metadata !== undefined) apiUpdates.metadata = updates.metadata;
  if (updates.templateProgress !== undefined) apiUpdates.template_progress = updates.templateProgress;

  await apiCall('/api/db/documents', {
    method: 'PUT',
    body: JSON.stringify({ id, ...apiUpdates }),
  });
}

/**
 * Delete a document from Supabase
 */
export async function cloudDeleteDocument(id: string): Promise<void> {
  await apiCall(`/api/db/documents?id=${id}`, {
    method: 'DELETE',
  });
}

/**
 * Get a single document by ID from Supabase
 */
export async function cloudGetDocument(id: string): Promise<ProjectDocument | null> {
  try {
    const data = await apiCall<Record<string, unknown>>(`/api/db/documents?id=${id}`);
    
    return {
      id: data.id as string,
      projectId: data.project_id as string,
      baseTitle: data.base_title as string,
      title: data.title as string,
      version: data.version as number,
      parentVersionId: data.parent_version_id as string | undefined,
      folderId: data.folder_id as string | undefined,
      content: data.content as string,
      createdAt: data.created_at as string,
      modifiedAt: data.modified_at as string,
      metadata: data.metadata as ProjectDocument['metadata'],
      templateProgress: data.template_progress as ProjectDocument['templateProgress'],
    };
  } catch (error) {
    // Return null if document not found
    if (error instanceof Error && error.message.includes('not found')) {
      return null;
    }
    throw error;
  }
}

/**
 * Get all documents for a project from Supabase
 */
export async function cloudGetAllDocuments(projectId: string): Promise<ProjectDocument[]> {
  const data = await apiCall<Array<Record<string, unknown>>>(`/api/db/documents?project_id=${projectId}`);
  
  return data.map(doc => ({
    id: doc.id as string,
    projectId: doc.project_id as string,
    baseTitle: doc.base_title as string,
    title: doc.title as string,
    version: doc.version as number,
    parentVersionId: doc.parent_version_id as string | undefined,
    folderId: doc.folder_id as string | undefined,
    content: doc.content as string,
    createdAt: doc.created_at as string,
    modifiedAt: doc.modified_at as string,
    metadata: doc.metadata as ProjectDocument['metadata'],
    templateProgress: doc.template_progress as ProjectDocument['templateProgress'],
  }));
}

/**
 * Get document versions by base title from Supabase
 */
export async function cloudGetDocumentVersions(
  projectId: string,
  baseTitle: string
): Promise<ProjectDocument[]> {
  const data = await apiCall<Array<Record<string, unknown>>>(
    `/api/db/documents?project_id=${projectId}&base_title=${encodeURIComponent(baseTitle)}`
  );
  
  // Sort by version number ascending
  const docs = data.map(doc => ({
    id: doc.id as string,
    projectId: doc.project_id as string,
    baseTitle: doc.base_title as string,
    title: doc.title as string,
    version: doc.version as number,
    parentVersionId: doc.parent_version_id as string | undefined,
    folderId: doc.folder_id as string | undefined,
    content: doc.content as string,
    createdAt: doc.created_at as string,
    modifiedAt: doc.modified_at as string,
    metadata: doc.metadata as ProjectDocument['metadata'],
    templateProgress: doc.template_progress as ProjectDocument['templateProgress'],
  }));
  
  return docs.sort((a, b) => a.version - b.version);
}

/**
 * Rename a document in Supabase (creates new document family)
 */
export async function cloudRenameDocument(
  id: string,
  newBaseTitle: string
): Promise<ProjectDocument> {
  // Rename by updating base_title, title, resetting version to 1, and clearing parent
  const data = await apiCall<Record<string, unknown>>('/api/db/documents', {
    method: 'PUT',
    body: JSON.stringify({
      id,
      base_title: newBaseTitle.trim(),
      title: newBaseTitle.trim(),
      // Note: version and parent_version_id reset is handled server-side for rename operations
    }),
  });

  return {
    id: data.id as string,
    projectId: data.project_id as string,
    baseTitle: data.base_title as string,
    title: data.title as string,
    version: data.version as number,
    parentVersionId: data.parent_version_id as string | undefined,
    folderId: data.folder_id as string | undefined,
    content: data.content as string,
    createdAt: data.created_at as string,
    modifiedAt: data.modified_at as string,
    metadata: data.metadata as ProjectDocument['metadata'],
    templateProgress: data.template_progress as ProjectDocument['templateProgress'],
  };
}

/**
 * Create a new document version in Supabase
 */
export async function cloudCreateDocumentVersion(
  projectId: string,
  sourceDocId: string,
  newContent?: string
): Promise<ProjectDocument> {
  // First, get the source document to find baseTitle and current highest version
  const sourceDoc = await cloudGetDocument(sourceDocId);
  if (!sourceDoc) {
    throw new Error(`Source document not found: ${sourceDocId}`);
  }

  // Get all versions to find the highest version number
  const versions = await cloudGetDocumentVersions(projectId, sourceDoc.baseTitle);
  const highestVersion = versions.length > 0 
    ? Math.max(...versions.map(v => v.version))
    : 1;
  const newVersion = highestVersion + 1;

  // Create the new version
  return cloudCreateDocument(projectId, sourceDoc.baseTitle, newContent ?? sourceDoc.content, {
    version: newVersion,
    parentVersionId: sourceDocId,
    folderId: sourceDoc.folderId,
    metadata: sourceDoc.metadata,
    templateProgress: sourceDoc.templateProgress,
  });
}

// ============================================================================
// Brand Voice Operations
// ============================================================================

/**
 * Save brand voice to Supabase (creates or updates)
 */
export async function cloudSaveBrandVoice(
  projectId: string,
  brandVoice: BrandVoice
): Promise<void> {
  await apiCall('/api/db/brand-voices', {
    method: 'POST',
    body: JSON.stringify({
      project_id: projectId,
      brand_name: brandVoice.brandName,
      brand_tone: brandVoice.brandTone,
      approved_phrases: brandVoice.approvedPhrases,
      forbidden_words: brandVoice.forbiddenWords,
      brand_values: brandVoice.brandValues,
      mission_statement: brandVoice.missionStatement,
    }),
  });
}

/**
 * Delete brand voice from Supabase
 */
export async function cloudDeleteBrandVoice(projectId: string): Promise<void> {
  await apiCall(`/api/db/brand-voices?project_id=${projectId}`, {
    method: 'DELETE',
  });
}

// ============================================================================
// Persona Operations
// ============================================================================

/**
 * Create a new persona in Supabase
 */
export async function cloudCreatePersona(
  projectId: string,
  personaData: Omit<Persona, 'id' | 'createdAt' | 'updatedAt'>
): Promise<Persona> {
  const data = await apiCall<Record<string, unknown>>('/api/db/personas', {
    method: 'POST',
    body: JSON.stringify({
      project_id: projectId,
      name: personaData.name,
      photo_url: personaData.photoUrl,
      demographics: personaData.demographics,
      psychographics: personaData.psychographics,
      pain_points: personaData.painPoints,
      language_patterns: personaData.languagePatterns,
      goals: personaData.goals,
    }),
  });

  return {
    id: data.id as string,
    name: data.name as string,
    photoUrl: data.photo_url as string | undefined,
    demographics: data.demographics as string,
    psychographics: data.psychographics as string,
    painPoints: data.pain_points as string,
    languagePatterns: data.language_patterns as string,
    goals: data.goals as string,
    createdAt: data.created_at as string,
    updatedAt: data.updated_at as string,
  };
}

/**
 * Update a persona in Supabase
 */
export async function cloudUpdatePersona(
  id: string,
  updates: Partial<Omit<Persona, 'id' | 'createdAt'>>
): Promise<void> {
  const apiUpdates: Record<string, unknown> = {};
  
  if (updates.name !== undefined) apiUpdates.name = updates.name;
  if (updates.photoUrl !== undefined) apiUpdates.photo_url = updates.photoUrl;
  if (updates.demographics !== undefined) apiUpdates.demographics = updates.demographics;
  if (updates.psychographics !== undefined) apiUpdates.psychographics = updates.psychographics;
  if (updates.painPoints !== undefined) apiUpdates.pain_points = updates.painPoints;
  if (updates.languagePatterns !== undefined) apiUpdates.language_patterns = updates.languagePatterns;
  if (updates.goals !== undefined) apiUpdates.goals = updates.goals;

  await apiCall('/api/db/personas', {
    method: 'PUT',
    body: JSON.stringify({ id, ...apiUpdates }),
  });
}

/**
 * Delete a persona from Supabase
 */
export async function cloudDeletePersona(id: string): Promise<void> {
  await apiCall(`/api/db/personas?id=${id}`, {
    method: 'DELETE',
  });
}

// ============================================================================
// Folder Operations
// ============================================================================

/**
 * Create a new folder in Supabase
 */
export async function cloudCreateFolder(
  projectId: string,
  name: string,
  parentFolderId?: string
): Promise<Folder> {
  const data = await apiCall<Record<string, unknown>>('/api/db/folders', {
    method: 'POST',
    body: JSON.stringify({
      project_id: projectId,
      name,
      parent_folder_id: parentFolderId,
    }),
  });

  return {
    id: data.id as string,
    name: data.name as string,
    projectId: data.project_id as string,
    parentFolderId: data.parent_folder_id as string | undefined,
    createdAt: data.created_at as string,
    updatedAt: data.updated_at as string,
  };
}

/**
 * Update a folder in Supabase
 */
export async function cloudUpdateFolder(
  id: string,
  updates: Partial<Pick<Folder, 'name' | 'parentFolderId'>>
): Promise<void> {
  const apiUpdates: Record<string, unknown> = {};
  
  if (updates.name !== undefined) apiUpdates.name = updates.name;
  if (updates.parentFolderId !== undefined) apiUpdates.parent_folder_id = updates.parentFolderId;

  await apiCall('/api/db/folders', {
    method: 'PUT',
    body: JSON.stringify({ id, ...apiUpdates }),
  });
}

/**
 * Delete a folder from Supabase
 */
export async function cloudDeleteFolder(id: string, force: boolean = false): Promise<void> {
  await apiCall(`/api/db/folders?id=${id}${force ? '&force=true' : ''}`, {
    method: 'DELETE',
  });
}

// ============================================================================
// Snippet Operations
// ============================================================================

/**
 * Create a new snippet in Supabase
 */
export async function cloudCreateSnippet(
  projectId: string,
  input: CreateSnippetInput
): Promise<Snippet> {
  const data = await apiCall<Record<string, unknown>>('/api/db/snippets', {
    method: 'POST',
    body: JSON.stringify({
      project_id: projectId,
      name: input.name,
      content: input.content,
      description: input.description,
      tags: input.tags,
    }),
  });

  return {
    id: data.id as string,
    projectId: data.project_id as string,
    name: data.name as string,
    content: data.content as string,
    description: data.description as string | undefined,
    tags: data.tags as string[] | undefined,
    createdAt: data.created_at as string,
    modifiedAt: data.modified_at as string,
    usageCount: data.usage_count as number,
  };
}

/**
 * Update a snippet in Supabase
 */
export async function cloudUpdateSnippet(
  id: string,
  updates: UpdateSnippetInput
): Promise<void> {
  await apiCall('/api/db/snippets', {
    method: 'PUT',
    body: JSON.stringify({ id, ...updates }),
  });
}

/**
 * Increment snippet usage count
 */
export async function cloudIncrementSnippetUsage(id: string): Promise<void> {
  await apiCall(`/api/db/snippets?id=${id}`, {
    method: 'PATCH',
  });
}

/**
 * Delete a snippet from Supabase
 */
export async function cloudDeleteSnippet(id: string): Promise<void> {
  await apiCall(`/api/db/snippets?id=${id}`, {
    method: 'DELETE',
  });
}

// ============================================================================
// User Settings Operations
// ============================================================================

/**
 * Get user settings from Supabase
 */
export async function cloudGetUserSettings(): Promise<{
  activeProjectId: string | null;
  settings: Record<string, unknown>;
}> {
  const data = await apiCall<{
    active_project_id: string | null;
    settings: Record<string, unknown>;
  }>('/api/db/user-settings');

  return {
    activeProjectId: data.active_project_id,
    settings: data.settings,
  };
}

/**
 * Update user settings in Supabase
 */
export async function cloudUpdateUserSettings(updates: {
  activeProjectId?: string | null;
  settings?: Record<string, unknown>;
}): Promise<void> {
  await apiCall('/api/db/user-settings', {
    method: 'POST',
    body: JSON.stringify({
      active_project_id: updates.activeProjectId,
      settings: updates.settings,
    }),
  });
}

// ============================================================================
// Migration Operations
// ============================================================================

interface MigrationResult {
  success: boolean;
  migrated: {
    projects: number;
    brandVoices: number;
    personas: number;
    folders: number;
    documents: number;
    snippets: number;
  };
  errors: string[];
  idMapping: Record<string, string>;
}

/**
 * Migrate localStorage data to Supabase
 */
export async function migrateToCloud(
  projects: Project[],
  activeProjectId?: string
): Promise<MigrationResult> {
  // Transform projects to migration format
  const migrationProjects = projects.map(p => ({
    id: p.id,
    name: p.name,
    brandVoice: p.brandVoice,
    personas: p.personas,
    folders: p.folders,
    documents: p.documents,
    snippets: p.snippets,
    createdAt: p.createdAt,
    updatedAt: p.updatedAt,
  }));

  const result = await apiCall<MigrationResult>('/api/db/migrate', {
    method: 'POST',
    body: JSON.stringify({
      projects: migrationProjects,
      activeProjectId,
    }),
  });

  logger.log('üì§ Migration result:', result);

  return result;
}


=== FILE: lib/storage/unified-storage.ts ===

/**
 * @file lib/storage/unified-storage.ts
 * @description Unified storage layer with localStorage fallback and Supabase cloud sync
 * 
 * This module provides a seamless storage interface that:
 * 1. Uses Supabase when available for cloud persistence
 * 2. Falls back to localStorage when offline or Supabase unavailable
 * 3. Provides migration utilities for existing users
 * 4. Handles sync conflicts gracefully
 * 
 * PRIORITY: Supabase (cloud) > localStorage (fallback)
 */

'use client';

import type { Project, Persona, Folder, ProjectDocument } from '@/lib/types/project';
import type { BrandVoice } from '@/lib/types/brand';
import type { Snippet, CreateSnippetInput, UpdateSnippetInput } from '@/lib/types/snippet';

// Import localStorage-based storage (existing)
import * as localProjectStorage from './project-storage';
import * as localDocumentStorage from './document-storage';
import * as localPersonaStorage from './persona-storage';
import * as localFolderStorage from './folder-storage';
import * as localSnippetStorage from './snippet-storage';

// Import Supabase-based storage (new)
import * as cloudStorage from './supabase-storage';

import { logger } from '@/lib/utils/logger';

// ============================================================================
// Storage Mode Configuration
// ============================================================================

/** Storage mode - determines where data is saved/loaded */
type StorageMode = 'cloud' | 'local' | 'hybrid';

/** Current storage mode */
let currentMode: StorageMode = 'hybrid';

/** Flag to track if migration has been checked */
let migrationChecked = false;

/** Local storage key for migration status */
const MIGRATION_STATUS_KEY = 'copyworx_supabase_migrated';

/**
 * Check if cloud storage is available and configured
 */
export function isCloudAvailable(): boolean {
  return cloudStorage.isCloudStorageAvailable();
}

/**
 * Check if migration to cloud has been completed
 */
export function isMigrationComplete(): boolean {
  if (typeof window === 'undefined') return false;
  return localStorage.getItem(MIGRATION_STATUS_KEY) === 'true';
}

/**
 * Mark migration as complete
 */
export function markMigrationComplete(): void {
  if (typeof window === 'undefined') return;
  localStorage.setItem(MIGRATION_STATUS_KEY, 'true');
}

/**
 * Set the storage mode
 */
export function setStorageMode(mode: StorageMode): void {
  currentMode = mode;
  logger.log(`üì¶ Storage mode set to: ${mode}`);
}

/**
 * Get the current storage mode
 */
export function getStorageMode(): StorageMode {
  return currentMode;
}

// ============================================================================
// Migration Utilities
// ============================================================================

/**
 * Check if there's localStorage data that needs migration
 */
export function hasLocalDataToMigrate(): boolean {
  if (typeof window === 'undefined') return false;
  
  const localProjects = localProjectStorage.getAllProjects();
  return localProjects.length > 0 && !isMigrationComplete();
}

/**
 * Migrate localStorage data to Supabase
 * This is a one-time operation for existing users
 */
export async function migrateLocalToCloud(): Promise<{
  success: boolean;
  migrated: number;
  errors: string[];
}> {
  if (!isCloudAvailable()) {
    return { success: false, migrated: 0, errors: ['Cloud storage not configured'] };
  }

  if (isMigrationComplete()) {
    return { success: true, migrated: 0, errors: [] };
  }

  try {
    // Get all local projects with their data
    const localProjects = localProjectStorage.getAllProjects();
    const activeProjectId = localProjectStorage.getActiveProjectId();

    if (localProjects.length === 0) {
      markMigrationComplete();
      return { success: true, migrated: 0, errors: [] };
    }

    logger.log('üîÑ Starting migration of', localProjects.length, 'projects');

    // Call the migration API
    const result = await cloudStorage.migrateToCloud(localProjects, activeProjectId || undefined);

    if (result.success) {
      markMigrationComplete();
      logger.log('‚úÖ Migration completed successfully');
    } else {
      logger.warn('‚ö†Ô∏è Migration completed with errors:', result.errors);
    }

    return {
      success: result.success,
      migrated: result.migrated.projects,
      errors: result.errors,
    };

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    logger.error('‚ùå Migration failed:', errorMessage);
    return { success: false, migrated: 0, errors: [errorMessage] };
  }
}

// ============================================================================
// Unified Project Operations
// ============================================================================

/**
 * Get all projects (from cloud or local)
 */
export async function getAllProjects(): Promise<Project[]> {
  // If cloud is available and we should use it
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      const { projects } = await cloudStorage.syncAllProjects();
      logger.log('‚òÅÔ∏è Loaded', projects.length, 'projects from cloud');
      
      // FIX: Sync projects to localStorage so other storage layers can access them
      // This prevents "Project not found" errors from snippet-storage, folder-storage, etc.
      if (typeof window !== 'undefined' && projects.length > 0) {
        try {
          localStorage.setItem('copyworx_projects', JSON.stringify(projects));
          logger.log('üíæ Synced projects to localStorage for compatibility');
        } catch (error) {
          logger.warn('‚ö†Ô∏è Failed to sync projects to localStorage:', error);
        }
      }
      
      return projects;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud fetch failed, falling back to local:', error);
      // Fall through to local storage
    }
  }

  // Fallback to local storage
  const projects = localProjectStorage.getAllProjects();
  logger.log('üíæ Loaded', projects.length, 'projects from localStorage');
  return projects;
}

/**
 * Create a new project
 */
export async function createProject(name: string): Promise<Project> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      const project = await cloudStorage.cloudCreateProject(name);
      logger.log('‚òÅÔ∏è Project created in cloud:', project.id);
      return project;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud create failed, falling back to local:', error);
    }
  }

  // Fallback to local
  const project = localProjectStorage.createProject(name);
  logger.log('üíæ Project created locally:', project.id);
  return project;
}

/**
 * Update a project
 */
export async function updateProject(id: string, updates: Partial<Project>): Promise<void> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      await cloudStorage.cloudUpdateProject(id, { name: updates.name });
      logger.log('‚òÅÔ∏è Project updated in cloud:', id);
      return;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud update failed, falling back to local:', error);
    }
  }

  // Fallback to local
  localProjectStorage.updateProject(id, updates);
  logger.log('üíæ Project updated locally:', id);
}

/**
 * Delete a project
 */
export async function deleteProject(id: string): Promise<void> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      await cloudStorage.cloudDeleteProject(id);
      logger.log('‚òÅÔ∏è Project deleted from cloud:', id);
      return;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud delete failed, falling back to local:', error);
    }
  }

  // Fallback to local
  localProjectStorage.deleteProject(id);
  logger.log('üíæ Project deleted locally:', id);
}

/**
 * Get active project ID
 */
export async function getActiveProjectId(): Promise<string | null> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      const { activeProjectId } = await cloudStorage.cloudGetUserSettings();
      return activeProjectId;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud settings fetch failed, falling back to local:', error);
    }
  }

  return localProjectStorage.getActiveProjectId();
}

/**
 * Set active project ID
 */
export async function setActiveProjectId(id: string): Promise<void> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      await cloudStorage.cloudUpdateUserSettings({ activeProjectId: id });
      logger.log('‚òÅÔ∏è Active project set in cloud:', id);
      return;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud settings update failed, falling back to local:', error);
    }
  }

  localProjectStorage.setActiveProjectId(id);
  logger.log('üíæ Active project set locally:', id);
}

// ============================================================================
// Unified Document Operations
// Re-export from document-storage.ts which now handles API + localStorage internally
// ============================================================================

export {
  createDocument,
  updateDocument,
  deleteDocument,
  getDocument,
  getAllDocuments,
  getDocumentVersions,
  renameDocument,
  createDocumentVersion,
  getLatestVersion,
} from './document-storage';

// ============================================================================
// Unified Brand Voice Operations
// ============================================================================

/**
 * Save brand voice to project
 */
export async function saveBrandVoice(projectId: string, brandVoice: BrandVoice): Promise<void> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      await cloudStorage.cloudSaveBrandVoice(projectId, brandVoice);
      logger.log('‚òÅÔ∏è Brand voice saved to cloud');
      return;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud save failed, falling back to local:', error);
    }
  }

  localProjectStorage.saveBrandVoiceToProject(projectId, brandVoice);
  logger.log('üíæ Brand voice saved locally');
}

/**
 * Delete brand voice from project
 */
export async function deleteBrandVoice(projectId: string): Promise<void> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      await cloudStorage.cloudDeleteBrandVoice(projectId);
      logger.log('‚òÅÔ∏è Brand voice deleted from cloud');
      return;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud delete failed, falling back to local:', error);
    }
  }

  localProjectStorage.deleteBrandVoiceFromProject(projectId);
  logger.log('üíæ Brand voice deleted locally');
}

// ============================================================================
// Unified Persona Operations
// Re-export from persona-storage.ts which now handles API + localStorage internally
// ============================================================================

export {
  createPersona,
  updatePersona,
  deletePersona,
  getProjectPersonas,
  getPersona,
} from './persona-storage';

// ============================================================================
// Unified Folder Operations
// ============================================================================

/**
 * Create a new folder
 */
export async function createFolder(
  projectId: string,
  name: string,
  parentFolderId?: string
): Promise<Folder> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      const folder = await cloudStorage.cloudCreateFolder(projectId, name, parentFolderId);
      logger.log('‚òÅÔ∏è Folder created in cloud:', folder.id);
      return folder;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud create failed, falling back to local:', error);
    }
  }

  const folder = localFolderStorage.createFolder(projectId, name, parentFolderId);
  logger.log('üíæ Folder created locally:', folder.id);
  return folder;
}

/**
 * Update a folder
 */
export async function updateFolder(
  projectId: string,
  folderId: string,
  updates: Partial<Pick<Folder, 'name'>>
): Promise<void> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      await cloudStorage.cloudUpdateFolder(folderId, updates);
      logger.log('‚òÅÔ∏è Folder updated in cloud:', folderId);
      return;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud update failed, falling back to local:', error);
    }
  }

  localFolderStorage.updateFolder(projectId, folderId, updates);
  logger.log('üíæ Folder updated locally:', folderId);
}

/**
 * Delete a folder
 */
export async function deleteFolder(projectId: string, folderId: string): Promise<void> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      await cloudStorage.cloudDeleteFolder(folderId);
      logger.log('‚òÅÔ∏è Folder deleted from cloud:', folderId);
      return;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud delete failed, falling back to local:', error);
    }
  }

  localFolderStorage.deleteFolder(projectId, folderId);
  logger.log('üíæ Folder deleted locally:', folderId);
}

/**
 * Get all folders for a project
 */
export async function getAllFolders(projectId: string): Promise<Folder[]> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      const { projects } = await cloudStorage.syncAllProjects();
      const project = projects.find(p => p.id === projectId);
      const folders = project?.folders || [];
      logger.log('‚òÅÔ∏è Loaded', folders.length, 'folders from cloud');
      return folders;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud fetch failed, falling back to local:', error);
    }
  }

  const folders = localFolderStorage.getAllFolders(projectId);
  logger.log('üíæ Loaded', folders.length, 'folders locally');
  return folders;
}

/**
 * Move a folder to a new parent
 */
export async function moveFolder(
  projectId: string,
  folderId: string,
  newParentFolderId: string | null
): Promise<void> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      await cloudStorage.cloudUpdateFolder(folderId, { parentFolderId: newParentFolderId || undefined });
      logger.log('‚òÅÔ∏è Folder moved in cloud:', folderId);
      return;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud move failed, falling back to local:', error);
    }
  }

  localFolderStorage.moveFolder(projectId, folderId, newParentFolderId);
  logger.log('üíæ Folder moved locally:', folderId);
}

// ============================================================================
// Brand Voice Aliases (for backward compatibility)
// ============================================================================

/**
 * Alias for saveBrandVoice (matches project-storage API)
 */
export const saveBrandVoiceToProject = saveBrandVoice;

/**
 * Alias for deleteBrandVoice (matches project-storage API)
 */
export const deleteBrandVoiceFromProject = deleteBrandVoice;

// ============================================================================
// Unified Snippet Operations
// ============================================================================

/**
 * Create a new snippet
 */
export async function createSnippet(
  projectId: string,
  input: CreateSnippetInput
): Promise<Snippet> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      const snippet = await cloudStorage.cloudCreateSnippet(projectId, input);
      logger.log('‚òÅÔ∏è Snippet created in cloud:', snippet.id);
      return snippet;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud create failed, falling back to local:', error);
    }
  }

  const snippet = localSnippetStorage.createSnippet(projectId, input);
  logger.log('üíæ Snippet created locally:', snippet.id);
  return snippet;
}

/**
 * Update a snippet
 */
export async function updateSnippet(
  projectId: string,
  snippetId: string,
  updates: UpdateSnippetInput
): Promise<void> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      await cloudStorage.cloudUpdateSnippet(snippetId, updates);
      logger.log('‚òÅÔ∏è Snippet updated in cloud:', snippetId);
      return;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud update failed, falling back to local:', error);
    }
  }

  localSnippetStorage.updateSnippet(projectId, snippetId, updates);
  logger.log('üíæ Snippet updated locally:', snippetId);
}

/**
 * Delete a snippet
 */
export async function deleteSnippet(projectId: string, snippetId: string): Promise<void> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      await cloudStorage.cloudDeleteSnippet(snippetId);
      logger.log('‚òÅÔ∏è Snippet deleted from cloud:', snippetId);
      return;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud delete failed, falling back to local:', error);
    }
  }

  localSnippetStorage.deleteSnippet(projectId, snippetId);
  logger.log('üíæ Snippet deleted locally:', snippetId);
}

/**
 * Increment snippet usage
 */
export async function incrementSnippetUsage(projectId: string, snippetId: string): Promise<void> {
  if (isCloudAvailable() && currentMode !== 'local') {
    try {
      await cloudStorage.cloudIncrementSnippetUsage(snippetId);
      return;
    } catch (error) {
      logger.warn('‚ö†Ô∏è Cloud increment failed, falling back to local:', error);
    }
  }

  localSnippetStorage.incrementSnippetUsage(projectId, snippetId);
}

// ============================================================================
// Initialization
// ============================================================================

/**
 * Initialize unified storage
 * Call this on app startup to check migration status and configure storage
 */
export async function initializeStorage(): Promise<{
  mode: StorageMode;
  migrationNeeded: boolean;
  migrationComplete: boolean;
}> {
  const cloudAvailable = isCloudAvailable();
  const migrationComplete = isMigrationComplete();
  const localDataExists = hasLocalDataToMigrate();

  logger.log('üîß Storage initialization:', {
    cloudAvailable,
    migrationComplete,
    localDataExists,
  });

  // Determine mode
  if (cloudAvailable) {
    currentMode = 'hybrid'; // Use cloud with local fallback
  } else {
    currentMode = 'local'; // Local only
  }

  return {
    mode: currentMode,
    migrationNeeded: cloudAvailable && localDataExists && !migrationComplete,
    migrationComplete,
  };
}


=== FILE: lib/stores/slideOutStore.ts ===

/**
 * @file lib/stores/slideOutStore.ts
 * @description Zustand store for managing slide-out panel state
 * 
 * Features:
 * - Track which panel is currently open (by ID)
 * - Only one panel can be open at a time
 * - Opening a new panel auto-closes the current one
 * - Clean open/close actions
 * 
 * @example
 * ```tsx
 * const { activeSlideOutId, openSlideOut, closeSlideOut } = useSlideOutStore();
 * 
 * // Open a panel
 * openSlideOut('navigation-panel');
 * 
 * // Close any open panel
 * closeSlideOut();
 * 
 * // Check if specific panel is open
 * const isOpen = activeSlideOutId === 'navigation-panel';
 * ```
 */

'use client';

import { create } from 'zustand';
import { useShallow } from 'zustand/react/shallow';

/**
 * Slide-out panel state interface
 */
interface SlideOutState {
  /** Set of IDs for currently open slide-out panels */
  openSlideOutIds: Set<string>;
  
  /**
   * Open a slide-out panel by ID
   * Multiple panels can be open simultaneously
   * @param id - Unique identifier for the panel
   */
  openSlideOut: (id: string) => void;
  
  /**
   * Close a specific slide-out panel by ID
   * @param id - Unique identifier for the panel to close (optional - closes all if omitted)
   */
  closeSlideOut: (id?: string) => void;
  
  /**
   * Toggle a slide-out panel
   * If the panel is open, close it. If closed, open it.
   * @param id - Unique identifier for the panel
   */
  toggleSlideOut: (id: string) => void;
  
  /**
   * Check if a specific panel is open
   * @param id - Unique identifier for the panel
   * @returns true if the panel is open
   */
  isSlideOutOpen: (id: string) => boolean;
  
  /**
   * Close all open slide-out panels
   */
  closeAllSlideOuts: () => void;
}

/**
 * Zustand store for slide-out panel state
 * 
 * Not persisted - panels should always start closed on page load
 * Supports multiple panels open simultaneously (e.g., templates browser + template form)
 */
export const useSlideOutStore = create<SlideOutState>()((set, get) => ({
  openSlideOutIds: new Set<string>(),
  
  openSlideOut: (id: string) => {
    const { openSlideOutIds } = get();
    if (!openSlideOutIds.has(id)) {
      const newSet = new Set(openSlideOutIds);
      newSet.add(id);
      set({ openSlideOutIds: newSet });
    }
  },
  
  closeSlideOut: (id?: string) => {
    const { openSlideOutIds } = get();
    if (id) {
      // Close specific panel
      if (openSlideOutIds.has(id)) {
        const newSet = new Set(openSlideOutIds);
        newSet.delete(id);
        set({ openSlideOutIds: newSet });
      }
    } else {
      // Close all panels
      if (openSlideOutIds.size > 0) {
        set({ openSlideOutIds: new Set() });
      }
    }
  },
  
  toggleSlideOut: (id: string) => {
    const { openSlideOutIds } = get();
    const newSet = new Set(openSlideOutIds);
    if (newSet.has(id)) {
      newSet.delete(id);
    } else {
      newSet.add(id);
    }
    set({ openSlideOutIds: newSet });
  },
  
  isSlideOutOpen: (id: string) => {
    return get().openSlideOutIds.has(id);
  },
  
  closeAllSlideOuts: () => {
    const { openSlideOutIds } = get();
    if (openSlideOutIds.size > 0) {
      set({ openSlideOutIds: new Set() });
    }
  },
}));

/**
 * Selector hooks for optimized re-renders
 */

/**
 * Hook to get all open slide-out IDs
 * @returns Set of currently open panel IDs
 */
export const useOpenSlideOutIds = () => useSlideOutStore((state) => state.openSlideOutIds);

/**
 * Hook to get slide-out actions with stable references
 * Uses useShallow to prevent unnecessary re-renders
 */
export const useSlideOutActions = () => useSlideOutStore(
  useShallow((state) => ({
    openSlideOut: state.openSlideOut,
    closeSlideOut: state.closeSlideOut,
    toggleSlideOut: state.toggleSlideOut,
    closeAllSlideOuts: state.closeAllSlideOuts,
  }))
);

/**
 * Hook to check if a specific slide-out is open
 * @param id - Panel ID to check
 * @returns true if the panel is currently open
 */
export const useIsSlideOutOpen = (id: string) => {
  return useSlideOutStore((state) => state.openSlideOutIds.has(id));
};


=== FILE: lib/stores/snippetStore.ts ===

/**
 * @file lib/stores/snippetStore.ts
 * @description Zustand store for managing snippet state and editor integration
 * 
 * Handles:
 * - Current project's snippets
 * - Snippet modal states (add/edit)
 * - Editor reference for snippet insertion
 * - Search/filter state
 */

'use client';

import { create } from 'zustand';
import { useShallow } from 'zustand/react/shallow';
import type { Editor } from '@tiptap/react';
import type { Snippet, CreateSnippetInput, UpdateSnippetInput } from '@/lib/types/snippet';
import {
  getAllSnippets,
  createSnippet as createSnippetStorage,
  updateSnippet as updateSnippetStorage,
  deleteSnippet as deleteSnippetStorage,
  incrementSnippetUsage,
  searchSnippets as searchSnippetsStorage,
} from '@/lib/storage/snippet-storage';
import { insertTextAtSelection } from '@/lib/editor-utils';
import { logger } from '@/lib/utils/logger';

// ============================================================================
// Types
// ============================================================================

interface SnippetState {
  // Snippet data
  snippets: Snippet[];
  currentProjectId: string | null;
  
  // Search/filter state
  searchQuery: string;
  filteredSnippets: Snippet[];
  
  // Modal states
  isAddModalOpen: boolean;
  isEditModalOpen: boolean;
  editingSnippet: Snippet | null;
  
  // Save as snippet modal
  isSaveAsSnippetOpen: boolean;
  selectedTextForSnippet: string;
  
  // Editor reference (stored outside React to avoid stale closures)
  editorRef: Editor | null;
  
  // Loading states
  isLoading: boolean;
  error: string | null;
  
  // Actions
  loadSnippets: (projectId: string) => void;
  refreshSnippets: () => void;
  
  // CRUD actions
  createSnippet: (input: CreateSnippetInput) => Promise<Snippet | null>;
  updateSnippet: (snippetId: string, updates: UpdateSnippetInput) => Promise<Snippet | null>;
  deleteSnippet: (snippetId: string) => Promise<boolean>;
  
  // Editor actions
  setEditorRef: (editor: Editor | null) => void;
  insertSnippet: (snippet: Snippet) => boolean;
  
  // Search actions
  setSearchQuery: (query: string) => void;
  clearSearch: () => void;
  
  // Modal actions
  openAddModal: () => void;
  closeAddModal: () => void;
  openEditModal: (snippet: Snippet) => void;
  closeEditModal: () => void;
  openSaveAsSnippet: (selectedText: string) => void;
  closeSaveAsSnippet: () => void;
  
  // Error handling
  clearError: () => void;
}

// ============================================================================
// Store
// ============================================================================

export const useSnippetStore = create<SnippetState>()((set, get) => ({
  // Initial state
  snippets: [],
  currentProjectId: null,
  searchQuery: '',
  filteredSnippets: [],
  isAddModalOpen: false,
  isEditModalOpen: false,
  editingSnippet: null,
  isSaveAsSnippetOpen: false,
  selectedTextForSnippet: '',
  editorRef: null,
  isLoading: false,
  error: null,
  
  // Load snippets for a project
  loadSnippets: (projectId: string) => {
    if (!projectId) {
      set({ snippets: [], filteredSnippets: [], currentProjectId: null });
      return;
    }
    
    set({ isLoading: true, error: null });
    
    try {
      const snippets = getAllSnippets(projectId);
      set({ 
        snippets, 
        filteredSnippets: snippets,
        currentProjectId: projectId,
        isLoading: false,
        searchQuery: '', // Reset search on project change
      });
      logger.log(`üìé Loaded ${snippets.length} snippets for project ${projectId}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to load snippets';
      set({ error: errorMessage, isLoading: false });
      logger.error('‚ùå Failed to load snippets:', error);
    }
  },
  
  // Refresh snippets for current project
  refreshSnippets: () => {
    const { currentProjectId, searchQuery } = get();
    if (!currentProjectId) return;
    
    try {
      const snippets = getAllSnippets(currentProjectId);
      
      // Apply current search filter if any
      const filteredSnippets = searchQuery 
        ? searchSnippetsStorage(currentProjectId, searchQuery)
        : snippets;
      
      set({ snippets, filteredSnippets });
      logger.log('üîÑ Snippets refreshed');
    } catch (error) {
      logger.error('‚ùå Failed to refresh snippets:', error);
    }
  },
  
  // Create a new snippet
  createSnippet: async (input: CreateSnippetInput): Promise<Snippet | null> => {
    const { currentProjectId } = get();
    if (!currentProjectId) {
      set({ error: 'No project selected' });
      return null;
    }
    
    set({ isLoading: true, error: null });
    
    try {
      const newSnippet = createSnippetStorage(currentProjectId, input);
      
      // Refresh snippets list
      get().refreshSnippets();
      
      set({ isLoading: false, isAddModalOpen: false, isSaveAsSnippetOpen: false });
      logger.log('‚úÖ Snippet created:', newSnippet.name);
      
      return newSnippet;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to create snippet';
      set({ error: errorMessage, isLoading: false });
      logger.error('‚ùå Failed to create snippet:', error);
      return null;
    }
  },
  
  // Update an existing snippet
  updateSnippet: async (snippetId: string, updates: UpdateSnippetInput): Promise<Snippet | null> => {
    const { currentProjectId } = get();
    if (!currentProjectId) {
      set({ error: 'No project selected' });
      return null;
    }
    
    set({ isLoading: true, error: null });
    
    try {
      const updatedSnippet = updateSnippetStorage(currentProjectId, snippetId, updates);
      
      // Refresh snippets list
      get().refreshSnippets();
      
      set({ isLoading: false, isEditModalOpen: false, editingSnippet: null });
      logger.log('‚úÖ Snippet updated:', updatedSnippet.name);
      
      return updatedSnippet;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to update snippet';
      set({ error: errorMessage, isLoading: false });
      logger.error('‚ùå Failed to update snippet:', error);
      return null;
    }
  },
  
  // Delete a snippet
  deleteSnippet: async (snippetId: string): Promise<boolean> => {
    const { currentProjectId } = get();
    if (!currentProjectId) {
      set({ error: 'No project selected' });
      return false;
    }
    
    set({ isLoading: true, error: null });
    
    try {
      deleteSnippetStorage(currentProjectId, snippetId);
      
      // Refresh snippets list
      get().refreshSnippets();
      
      set({ isLoading: false });
      logger.log('üóëÔ∏è Snippet deleted');
      
      return true;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Failed to delete snippet';
      set({ error: errorMessage, isLoading: false });
      logger.error('‚ùå Failed to delete snippet:', error);
      return false;
    }
  },
  
  // Set editor reference
  setEditorRef: (editor: Editor | null) => {
    set({ editorRef: editor });
  },
  
  // Insert snippet into editor
  insertSnippet: (snippet: Snippet): boolean => {
    const { editorRef, currentProjectId } = get();
    
    if (!editorRef) {
      logger.warn('‚ö†Ô∏è No editor reference available for snippet insertion');
      set({ error: 'Editor not available' });
      return false;
    }
    
    try {
      // Insert the snippet content at cursor position
      const success = insertTextAtSelection(editorRef, snippet.content);
      
      if (success && currentProjectId) {
        // Increment usage count
        incrementSnippetUsage(currentProjectId, snippet.id);
        // Refresh to update usage count in UI
        get().refreshSnippets();
      }
      
      logger.log(success ? '‚úÖ Snippet inserted' : '‚ùå Failed to insert snippet');
      return success;
    } catch (error) {
      logger.error('‚ùå Error inserting snippet:', error);
      set({ error: 'Failed to insert snippet' });
      return false;
    }
  },
  
  // Search actions
  setSearchQuery: (query: string) => {
    const { currentProjectId, snippets } = get();
    
    if (!query.trim()) {
      set({ searchQuery: '', filteredSnippets: snippets });
      return;
    }
    
    if (currentProjectId) {
      const filtered = searchSnippetsStorage(currentProjectId, query);
      set({ searchQuery: query, filteredSnippets: filtered });
    }
  },
  
  clearSearch: () => {
    const { snippets } = get();
    set({ searchQuery: '', filteredSnippets: snippets });
  },
  
  // Modal actions
  openAddModal: () => {
    set({ isAddModalOpen: true, error: null });
  },
  
  closeAddModal: () => {
    set({ isAddModalOpen: false, error: null });
  },
  
  openEditModal: (snippet: Snippet) => {
    set({ isEditModalOpen: true, editingSnippet: snippet, error: null });
  },
  
  closeEditModal: () => {
    set({ isEditModalOpen: false, editingSnippet: null, error: null });
  },
  
  openSaveAsSnippet: (selectedText: string) => {
    set({ isSaveAsSnippetOpen: true, selectedTextForSnippet: selectedText, error: null });
  },
  
  closeSaveAsSnippet: () => {
    set({ isSaveAsSnippetOpen: false, selectedTextForSnippet: '', error: null });
  },
  
  // Error handling
  clearError: () => {
    set({ error: null });
  },
}));

// ============================================================================
// Selector Hooks
// ============================================================================

/**
 * Hook to get all snippets
 */
export const useSnippets = () => useSnippetStore((state) => state.filteredSnippets);

/**
 * Hook to get snippet search query
 */
export const useSnippetSearchQuery = () => useSnippetStore((state) => state.searchQuery);

/**
 * Hook to get snippet loading state
 */
export const useSnippetLoading = () => useSnippetStore((state) => state.isLoading);

/**
 * Hook to get snippet error
 */
export const useSnippetError = () => useSnippetStore((state) => state.error);

/**
 * Hook to get add modal state
 */
export const useAddSnippetModalOpen = () => useSnippetStore((state) => state.isAddModalOpen);

/**
 * Hook to get edit modal state
 */
export const useEditSnippetModal = () => useSnippetStore(
  useShallow((state) => ({
    isOpen: state.isEditModalOpen,
    snippet: state.editingSnippet,
  }))
);

/**
 * Hook to get save as snippet modal state
 */
export const useSaveAsSnippetModal = () => useSnippetStore(
  useShallow((state) => ({
    isOpen: state.isSaveAsSnippetOpen,
    selectedText: state.selectedTextForSnippet,
  }))
);

/**
 * Hook to get snippet actions
 */
export const useSnippetActions = () => useSnippetStore(
  useShallow((state) => ({
    loadSnippets: state.loadSnippets,
    refreshSnippets: state.refreshSnippets,
    createSnippet: state.createSnippet,
    updateSnippet: state.updateSnippet,
    deleteSnippet: state.deleteSnippet,
    insertSnippet: state.insertSnippet,
    setEditorRef: state.setEditorRef,
    setSearchQuery: state.setSearchQuery,
    clearSearch: state.clearSearch,
    openAddModal: state.openAddModal,
    closeAddModal: state.closeAddModal,
    openEditModal: state.openEditModal,
    closeEditModal: state.closeEditModal,
    openSaveAsSnippet: state.openSaveAsSnippet,
    closeSaveAsSnippet: state.closeSaveAsSnippet,
    clearError: state.clearError,
  }))
);


=== FILE: lib/stores/workspaceStore.ts ===

/**
 * @file lib/stores/workspaceStore.ts
 * @description Zustand store for managing workspace UI state
 * 
 * ARCHITECTURE (Simplified):
 * - Zustand tracks UI state ONLY (sidebar visibility, active IDs, tool results)
 * - Document CONTENT is stored in localStorage via document-storage.ts
 * - No document content caching in Zustand = no sync issues
 * 
 * Manages:
 * - Active document ID (not content!)
 * - Active project ID
 * - Sidebar visibility
 * - Tool and AI analysis state
 * - Tone Shifter, Expand, Shorten, Rewrite functionality
 */

'use client';

import React from 'react';
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { useShallow } from 'zustand/react/shallow';
import type { ToolCategory, AIAnalysisMode, ViewMode } from '@/lib/types';
import type { Editor } from '@tiptap/react';
import type { Project } from '@/lib/types/project';
import type { BrandVoice, BrandAlignmentResult } from '@/lib/types/brand';
import type { Persona } from '@/lib/types/project';
import { logger } from '@/lib/utils/logger';

/**
 * Insights panel types for the right slide-out
 */
export type InsightsPanelType = 'brand-alignment' | 'persona-alignment' | null;

/**
 * Persona alignment result from AI analysis
 */
export interface PersonaAlignmentResult {
  score: number;
  assessment: string;
  strengths: string[];
  improvements: string[];
  recommendations: string[];
}
import {
  getAllProjects,
  getActiveProjectId,
  setActiveProjectId as setStorageActiveProjectId,
  updateProject as updateStorageProject,
  deleteProject as deleteStorageProject,
} from '@/lib/storage/unified-storage';
import { 
  fetchWithTimeout, 
  retryWithBackoff, 
  formatErrorForUser, 
  validateTextLength, 
  validateNotEmpty,
  logError
} from '@/lib/utils/error-handling';
import {
  type ToneType,
  TONE_SHIFTER_SYSTEM_PROMPT,
  buildToneShifterUserPrompt,
} from '@/lib/prompts/tone-shifter';

// Re-export ToneType for components that import from this file
export type { ToneType } from '@/lib/prompts/tone-shifter';

/**
 * Workspace state interface
 * 
 * IMPORTANT: No document content storage here!
 * Document content lives in localStorage via document-storage.ts
 */
interface WorkspaceState {
  // Project state
  projects: Project[];
  activeProjectId: string | null;
  
  // Document state - ONLY the ID, not content!
  activeDocumentId: string | null;
  
  // UI state
  leftSidebarOpen: boolean;
  rightSidebarOpen: boolean;
  activeToolId: string | null;
  aiAnalysisMode: AIAnalysisMode;
  viewMode: ViewMode;
  
  // Editor selection state
  selectedText: string | null;
  selectedHTML: string | null;
  selectionRange: { from: number; to: number } | null;
  
  // Tone Shifter state
  toneShiftResult: string | null;
  toneShiftLoading: boolean;
  toneShiftError: string | null;
  selectedTone: ToneType | null;
  
  // Expand Tool state
  expandResult: string | null;
  expandLoading: boolean;
  expandError: string | null;
  
  // Shorten Tool state
  shortenResult: string | null;
  shortenLoading: boolean;
  shortenError: string | null;
  
  // Rewrite Channel Tool state
  rewriteChannelResult: string | null;
  rewriteChannelLoading: boolean;
  rewriteChannelError: string | null;
  
  // Brand Alignment Tool state
  brandAlignmentResult: BrandAlignmentResult | null;
  brandAlignmentLoading: boolean;
  brandAlignmentError: string | null;
  /** Brand name that was analyzed against */
  brandAlignmentBrandName: string | null;
  /** Text that was analyzed (stored for optimization) */
  brandAlignmentAnalyzedText: string | null;
  
  // Persona Alignment Tool state
  personaAlignmentResult: PersonaAlignmentResult | null;
  personaAlignmentLoading: boolean;
  personaAlignmentError: string | null;
  /** Persona name that was analyzed against */
  personaAlignmentPersonaName: string | null;
  /** Text that was analyzed (stored for optimization) */
  personaAlignmentAnalyzedText: string | null;
  
  // Optimize Alignment Tool state (rewrite to optimize)
  optimizeAlignmentResult: string | null;
  optimizeAlignmentChangesSummary: string[];
  optimizeAlignmentLoading: boolean;
  optimizeAlignmentError: string | null;
  /** Target name (persona or brand) for optimization */
  optimizeAlignmentTargetName: string | null;
  /** Type of optimization (persona or brand) */
  optimizeAlignmentType: 'persona' | 'brand' | null;
  /** Original text being optimized */
  optimizeAlignmentOriginalText: string | null;
  /** Whether comparison modal is open */
  optimizeAlignmentModalOpen: boolean;
  
  // Template Generator state
  selectedTemplateId: string | null;
  isGeneratingTemplate: boolean;
  
  // Active insights panel for right slide-out
  activeInsightsPanel: InsightsPanelType;
  
  // Pending edit targets for slide-outs
  pendingBrandVoiceEdit: string | null; // Brand name to edit
  pendingPersonaEdit: string | null; // Persona ID to edit
  
  // Project actions
  setProjects: (projects: Project[]) => void;
  setActiveProjectId: (id: string) => Promise<void>;
  addProject: (project: Project) => void;
  updateProject: (id: string, updates: Partial<Project>) => void;
  deleteProject: (id: string) => Promise<void>;
  refreshProjects: () => Promise<void>;
  
  // Document actions - SIMPLIFIED
  setActiveDocumentId: (id: string | null) => void;
  
  // UI actions
  toggleLeftSidebar: () => void;
  toggleRightSidebar: () => void;
  setLeftSidebarOpen: (open: boolean) => void;
  setRightSidebarOpen: (open: boolean) => void;
  setActiveTool: (toolId: string | null) => void;
  clearActiveTool: () => void;
  setAIAnalysisMode: (mode: AIAnalysisMode) => void;
  setViewMode: (mode: ViewMode) => void;
  
  // Editor selection actions
  setSelectedText: (text: string | null, html: string | null, range: { from: number; to: number } | null) => void;
  clearSelection: () => void;
  
  // Tone Shifter actions
  setSelectedTone: (tone: ToneType | null) => void;
  runToneShift: (text: string, tone: ToneType) => Promise<void>;
  clearToneShiftResult: () => void;
  insertToneShiftResult: (editor: Editor) => void;
  
  // Expand Tool actions
  runExpand: (text: string) => Promise<void>;
  clearExpandResult: () => void;
  insertExpandResult: (editor: Editor) => void;
  
  // Shorten Tool actions
  runShorten: (text: string) => Promise<void>;
  clearShortenResult: () => void;
  insertShortenResult: (editor: Editor) => void;
  
  // Rewrite Channel Tool actions
  runRewriteChannel: (text: string, channel: string) => Promise<void>;
  clearRewriteChannelResult: () => void;
  insertRewriteChannelResult: (editor: Editor) => void;
  
  // Brand Alignment Tool actions
  runBrandAlignment: (text: string, brandVoice: BrandVoice) => Promise<void>;
  clearBrandAlignmentResult: () => void;
  
  // Persona Alignment Tool actions
  runPersonaAlignment: (text: string, persona: Persona) => Promise<void>;
  clearPersonaAlignmentResult: () => void;
  
  // Optimize Alignment Tool actions (rewrite to optimize)
  runOptimizeAlignment: (
    text: string,
    type: 'persona' | 'brand',
    analysisResult: PersonaAlignmentResult | BrandAlignmentResult,
    personaOrBrand: Persona | BrandVoice
  ) => Promise<void>;
  clearOptimizeAlignmentResult: () => void;
  setOptimizeAlignmentModalOpen: (open: boolean) => void;
  acceptOptimizeResult: (editor: Editor) => void;
  
  // Template Generator actions
  setSelectedTemplateId: (id: string | null) => void;
  setIsGeneratingTemplate: (isGenerating: boolean) => void;
  
  // Insights panel actions
  setActiveInsightsPanel: (panel: InsightsPanelType) => void;
  openInsightsPanel: (panel: InsightsPanelType) => void;
  closeInsightsPanel: () => void;
  
  // Pending edit actions
  setPendingBrandVoiceEdit: (brandName: string | null) => void;
  setPendingPersonaEdit: (personaId: string | null) => void;
}

/**
 * Zustand store with persistence
 */
export const useWorkspaceStore = create<WorkspaceState>()(
  persist(
    (set, get) => ({
      // Initial project state
      projects: [],
      activeProjectId: null,
      
      // Initial document state - ONLY ID
      activeDocumentId: null,
      
      // Initial UI state
      leftSidebarOpen: true,
      rightSidebarOpen: true,
      activeToolId: null,
      aiAnalysisMode: null,
      viewMode: 'scrolling' as ViewMode,
      
      // Editor selection initial state
      selectedText: null,
      selectedHTML: null,
      selectionRange: null,
      
      // Tone Shifter initial state
      toneShiftResult: null,
      toneShiftLoading: false,
      toneShiftError: null,
      selectedTone: null,
      
      // Expand Tool initial state
      expandResult: null,
      expandLoading: false,
      expandError: null,
      
      // Shorten Tool initial state
      shortenResult: null,
      shortenLoading: false,
      shortenError: null,
      
      // Rewrite Channel Tool initial state
      rewriteChannelResult: null,
      rewriteChannelLoading: false,
      rewriteChannelError: null,
      
      // Brand Alignment Tool initial state
      brandAlignmentResult: null,
      brandAlignmentLoading: false,
      brandAlignmentError: null,
      brandAlignmentBrandName: null,
      brandAlignmentAnalyzedText: null,
      
      // Persona Alignment Tool initial state
      personaAlignmentResult: null,
      personaAlignmentLoading: false,
      personaAlignmentError: null,
      personaAlignmentPersonaName: null,
      personaAlignmentAnalyzedText: null,
      
      // Optimize Alignment Tool initial state
      optimizeAlignmentResult: null,
      optimizeAlignmentChangesSummary: [],
      optimizeAlignmentLoading: false,
      optimizeAlignmentError: null,
      optimizeAlignmentTargetName: null,
      optimizeAlignmentType: null,
      optimizeAlignmentOriginalText: null,
      optimizeAlignmentModalOpen: false,
      
      // Template Generator initial state
      selectedTemplateId: null,
      isGeneratingTemplate: false,
      
      // Active insights panel - null means closed
      activeInsightsPanel: null,
      
      // Pending edit targets - null means no pending edit
      pendingBrandVoiceEdit: null,
      pendingPersonaEdit: null,

      // Project actions
      setProjects: (projects: Project[]) => {
        set({ projects });
      },

      setActiveProjectId: async (id: string) => {
        set({ activeProjectId: id, activeDocumentId: null }); // Clear doc when switching projects
        await setStorageActiveProjectId(id);
        
        // Clear tool results when switching projects
        set({
          brandAlignmentResult: null,
          brandAlignmentError: null,
          personaAlignmentResult: null,
          personaAlignmentError: null,
          toneShiftResult: null,
          toneShiftError: null,
          expandResult: null,
          expandError: null,
          shortenResult: null,
          shortenError: null,
          rewriteChannelResult: null,
          rewriteChannelError: null,
        });
      },

      addProject: (project: Project) => {
        const { projects } = get();
        set({ projects: [...projects, project] });
      },

      updateProject: (id: string, updates: Partial<Project>) => {
        const { projects } = get();
        const index = projects.findIndex((p) => p.id === id);
        
        if (index === -1) {
          logger.error('‚ùå Project not found:', id);
          return;
        }
        
        // Update in storage (async but we don't wait)
        updateStorageProject(id, updates);
        
        // Update in state
        const updatedProjects = [...projects];
        updatedProjects[index] = {
          ...updatedProjects[index],
          ...updates,
          id: updatedProjects[index].id,
          updatedAt: new Date().toISOString(),
        };
        
        set({ projects: updatedProjects });
      },

      deleteProject: async (id: string) => {
        const { projects } = get();
        
        try {
          await deleteStorageProject(id);
          const updatedProjects = projects.filter((p) => p.id !== id);
          set({ projects: updatedProjects });
        } catch (error) {
          logger.error('‚ùå Failed to delete project:', error);
        }
      },

      refreshProjects: async () => {
        try {
          const projects = await getAllProjects();
          const activeProjectId = await getActiveProjectId();
          const safeProjects = Array.isArray(projects) ? projects : [];
          set({ projects: safeProjects, activeProjectId });
        } catch (error) {
          logger.error('‚ùå Failed to refresh projects:', error);
        }
      },

      // Document actions - SIMPLIFIED
      setActiveDocumentId: (id: string | null) => {
        set({ activeDocumentId: id });
      },

      // UI actions
      toggleLeftSidebar: () => {
        set((state) => ({ leftSidebarOpen: !state.leftSidebarOpen }));
      },

      toggleRightSidebar: () => {
        set((state) => ({ rightSidebarOpen: !state.rightSidebarOpen }));
      },

      setLeftSidebarOpen: (open: boolean) => {
        set({ leftSidebarOpen: open });
      },

      setRightSidebarOpen: (open: boolean) => {
        set({ rightSidebarOpen: open });
      },

      setActiveTool: (toolId: string | null) => {
        set({ activeToolId: toolId });
        
        if (toolId !== null && !get().rightSidebarOpen) {
          set({ rightSidebarOpen: true });
        }
      },

      clearActiveTool: () => {
        set({ activeToolId: null });
      },

      setAIAnalysisMode: (mode: AIAnalysisMode) => {
        set({ aiAnalysisMode: mode });
        
        if (mode !== null && !get().rightSidebarOpen) {
          set({ rightSidebarOpen: true });
        }
      },

      setViewMode: (mode: ViewMode) => {
        set({ viewMode: mode });
      },

      // Editor selection actions
      setSelectedText: (text: string | null, html: string | null, range: { from: number; to: number } | null) => {
        set({ 
          selectedText: text,
          selectedHTML: html,
          selectionRange: range 
        });
      },

      clearSelection: () => {
        set({ 
          selectedText: null,
          selectedHTML: null,
          selectionRange: null 
        });
      },

      // Tone Shifter actions
      setSelectedTone: (tone: ToneType | null) => {
        set({ selectedTone: tone });
        logger.log('üé® Selected tone:', tone);
      },

      runToneShift: async (text: string, tone: ToneType) => {
        // Validate inputs
        try {
          validateNotEmpty(text, 'Text');
          validateTextLength(text, 'Text');
        } catch (error) {
          set({ 
            toneShiftError: formatErrorForUser(error, 'Validation'),
            toneShiftLoading: false 
          });
          logError(error, 'Tone shift validation');
          return;
        }

        set({ 
          toneShiftLoading: true, 
          toneShiftError: null,
          toneShiftResult: null 
        });

        try {
          // Build the user prompt with tone-specific instructions
          const userPrompt = buildToneShifterUserPrompt(text, tone);

          const data = await retryWithBackoff(async () => {
            // Call centralized Claude API with feature tracking
            const response = await fetchWithTimeout('/api/claude', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                messages: [{ role: 'user', content: userPrompt }],
                system: TONE_SHIFTER_SYSTEM_PROMPT,
                feature: 'tone_shifter',
                maxTokens: 4000,
              }),
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({ 
                error: 'API request failed',
                details: `Status: ${response.status}` 
              }));
              throw new Error(errorData.details || errorData.error || 'Failed to rewrite copy');
            }

            const data = await response.json();
            if (!data.text) {
              throw new Error('No rewritten text received from API');
            }
            return data;
          }, 2);

          set({ 
            toneShiftResult: data.text, // Changed from data.rewrittenText
            toneShiftLoading: false,
            toneShiftError: null 
          });

        } catch (error) {
          set({ 
            toneShiftError: formatErrorForUser(error, 'Tone shift'),
            toneShiftLoading: false,
            toneShiftResult: null 
          });
          logError(error, 'Tone shift');
        }
      },

      clearToneShiftResult: () => {
        set({ 
          toneShiftResult: null,
          toneShiftError: null,
          selectedTone: null 
        });
      },

      insertToneShiftResult: (editor: Editor) => {
        const { toneShiftResult } = get();
        
        if (!toneShiftResult) {
          logger.warn('‚ö†Ô∏è No tone shift result to insert');
          return;
        }

        if (!editor) {
          logger.error('‚ùå No editor instance provided');
          set({ toneShiftError: 'Editor not available' });
          return;
        }

        try {
          editor.commands.setContent(toneShiftResult);
          set({ toneShiftResult: null, toneShiftError: null });
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Failed to insert content';
          set({ toneShiftError: errorMessage });
          logger.error('‚ùå Failed to insert tone shift result:', errorMessage);
        }
      },

      // Expand Tool actions
      runExpand: async (text: string) => {
        try {
          validateNotEmpty(text, 'Text');
          validateTextLength(text, 'Text');
        } catch (error) {
          set({ 
            expandError: formatErrorForUser(error, 'Validation'),
            expandLoading: false 
          });
          logError(error, 'Expand validation');
          return;
        }

        set({ 
          expandLoading: true, 
          expandError: null,
          expandResult: null 
        });

        try {
          const data = await retryWithBackoff(async () => {
            const response = await fetchWithTimeout('/api/expand', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text }),
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({ 
                error: 'API request failed',
                details: `Status: ${response.status}` 
              }));
              throw new Error(errorData.details || errorData.error || 'Failed to expand copy');
            }

            const data = await response.json();
            if (!data.expandedText) {
              throw new Error('No expanded text received from API');
            }
            return data;
          }, 2);

          set({ 
            expandResult: data.expandedText,
            expandLoading: false,
            expandError: null 
          });

        } catch (error) {
          set({ 
            expandError: formatErrorForUser(error, 'Expand'),
            expandLoading: false,
            expandResult: null 
          });
          logError(error, 'Expand');
        }
      },

      clearExpandResult: () => {
        set({ expandResult: null, expandError: null });
      },

      insertExpandResult: (editor: Editor) => {
        const { expandResult } = get();
        
        if (!expandResult || !editor) return;

        try {
          editor.commands.setContent(expandResult);
          set({ expandResult: null, expandError: null });
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Failed to insert content';
          set({ expandError: errorMessage });
        }
      },

      // Shorten Tool actions
      runShorten: async (text: string) => {
        try {
          validateNotEmpty(text, 'Text');
          validateTextLength(text, 'Text');
        } catch (error) {
          set({ 
            shortenError: formatErrorForUser(error, 'Validation'),
            shortenLoading: false 
          });
          logError(error, 'Shorten validation');
          return;
        }

        set({ 
          shortenLoading: true, 
          shortenError: null,
          shortenResult: null 
        });

        try {
          const data = await retryWithBackoff(async () => {
            const response = await fetchWithTimeout('/api/shorten', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text }),
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({ 
                error: 'API request failed',
                details: `Status: ${response.status}` 
              }));
              throw new Error(errorData.details || errorData.error || 'Failed to shorten copy');
            }

            const data = await response.json();
            if (!data.shortenedText) {
              throw new Error('No shortened text received from API');
            }
            return data;
          }, 2);

          set({ 
            shortenResult: data.shortenedText,
            shortenLoading: false,
            shortenError: null 
          });

        } catch (error) {
          set({ 
            shortenError: formatErrorForUser(error, 'Shorten'),
            shortenLoading: false,
            shortenResult: null 
          });
          logError(error, 'Shorten');
        }
      },

      clearShortenResult: () => {
        set({ shortenResult: null, shortenError: null });
      },

      insertShortenResult: (editor: Editor) => {
        const { shortenResult } = get();
        
        if (!shortenResult || !editor) return;

        try {
          editor.commands.setContent(shortenResult);
          set({ shortenResult: null, shortenError: null });
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Failed to insert content';
          set({ shortenError: errorMessage });
        }
      },

      // Rewrite Channel Tool actions
      runRewriteChannel: async (text: string, channel: string) => {
        try {
          validateNotEmpty(text, 'Text');
          validateTextLength(text, 'Text');
          validateNotEmpty(channel, 'Channel');
        } catch (error) {
          set({ 
            rewriteChannelError: formatErrorForUser(error, 'Validation'),
            rewriteChannelLoading: false 
          });
          logError(error, 'Rewrite channel validation');
          return;
        }

        set({ 
          rewriteChannelLoading: true, 
          rewriteChannelError: null,
          rewriteChannelResult: null 
        });

        try {
          const data = await retryWithBackoff(async () => {
            const response = await fetchWithTimeout('/api/rewrite-channel', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text, channel }),
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({ 
                error: 'API request failed',
                details: `Status: ${response.status}` 
              }));
              throw new Error(errorData.details || errorData.error || 'Failed to rewrite copy');
            }

            const data = await response.json();
            if (!data.rewrittenText) {
              throw new Error('No rewritten text received from API');
            }
            return data;
          }, 2);

          set({ 
            rewriteChannelResult: data.rewrittenText,
            rewriteChannelLoading: false,
            rewriteChannelError: null 
          });

        } catch (error) {
          set({ 
            rewriteChannelError: formatErrorForUser(error, 'Rewrite channel'),
            rewriteChannelLoading: false,
            rewriteChannelResult: null 
          });
          logError(error, 'Rewrite channel');
        }
      },

      clearRewriteChannelResult: () => {
        set({ rewriteChannelResult: null, rewriteChannelError: null });
      },

      insertRewriteChannelResult: (editor: Editor) => {
        const { rewriteChannelResult } = get();
        
        if (!rewriteChannelResult || !editor) return;

        try {
          editor.commands.setContent(rewriteChannelResult);
          set({ rewriteChannelResult: null, rewriteChannelError: null });
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Failed to insert content';
          set({ rewriteChannelError: errorMessage });
        }
      },

      // Brand Alignment Tool actions
      runBrandAlignment: async (text: string, brandVoice: BrandVoice): Promise<void> => {
        try {
          validateNotEmpty(text, 'Text');
          validateTextLength(text, 'Text');
          
          if (!brandVoice || !brandVoice.brandName) {
            throw new Error('Please set up your brand voice first');
          }
        } catch (error) {
          set({ 
            brandAlignmentError: formatErrorForUser(error, 'Validation'),
            brandAlignmentLoading: false 
          });
          logError(error, 'Brand alignment validation');
          return;
        }

        set({ 
          brandAlignmentLoading: true, 
          brandAlignmentError: null,
          brandAlignmentResult: null,
          brandAlignmentBrandName: null,
          brandAlignmentAnalyzedText: text, // Store the text being analyzed
        });

        try {
          const data = await retryWithBackoff(async () => {
            const response = await fetchWithTimeout('/api/brand-alignment', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text, brandVoice }),
            });

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({ 
                error: 'API request failed',
                details: `Status: ${response.status}` 
              }));
              throw new Error(errorData.details || errorData.error || 'Failed to check brand alignment');
            }

            const data = await response.json();
            if (!data.result) {
              throw new Error('No result received from API');
            }
            return data;
          }, 2);

          set({ 
            brandAlignmentResult: data.result,
            brandAlignmentLoading: false,
            brandAlignmentError: null,
            brandAlignmentBrandName: data.brandName || brandVoice.brandName,
            // Keep brandAlignmentAnalyzedText as set above
          });

        } catch (error) {
          set({ 
            brandAlignmentError: formatErrorForUser(error, 'Brand alignment'),
            brandAlignmentLoading: false,
            brandAlignmentResult: null,
            brandAlignmentBrandName: null,
            brandAlignmentAnalyzedText: null,
          });
          logError(error, 'Brand alignment');
        }
      },

      clearBrandAlignmentResult: () => {
        set({ brandAlignmentResult: null, brandAlignmentError: null, brandAlignmentBrandName: null, brandAlignmentAnalyzedText: null });
      },

      // Persona Alignment Tool actions
      runPersonaAlignment: async (text: string, persona: Persona): Promise<void> => {
        // Validate inputs
        try {
          validateNotEmpty(text, 'Text');
          validateTextLength(text, 'Text');
          validateNotEmpty(persona.name, 'Persona name');
        } catch (error) {
          set({ 
            personaAlignmentError: formatErrorForUser(error, 'Validation'),
            personaAlignmentLoading: false 
          });
          return;
        }

        // Set loading state
        set({ 
          personaAlignmentLoading: true, 
          personaAlignmentError: null,
          personaAlignmentResult: null,
          personaAlignmentPersonaName: null,
          personaAlignmentAnalyzedText: text, // Store the text being analyzed
        });

        try {
          const response = await retryWithBackoff(
            () => fetchWithTimeout('/api/persona-alignment', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text, persona }),
            }),
            2, // maxRetries
            1000 // baseDelay
          );

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.details || errorData.error || 'Failed to check persona alignment');
          }

          const data = await response.json();
          
          set({ 
            personaAlignmentResult: data.result,
            personaAlignmentLoading: false,
            personaAlignmentError: null,
            personaAlignmentPersonaName: data.personaName || persona.name,
            // Keep personaAlignmentAnalyzedText as set above
          });
        } catch (error) {
          set({ 
            personaAlignmentError: formatErrorForUser(error, 'Persona alignment'),
            personaAlignmentLoading: false,
            personaAlignmentResult: null,
            personaAlignmentPersonaName: null,
            personaAlignmentAnalyzedText: null,
          });
          logError(error, 'Persona alignment');
        }
      },

      clearPersonaAlignmentResult: () => {
        set({ personaAlignmentResult: null, personaAlignmentError: null, personaAlignmentPersonaName: null, personaAlignmentAnalyzedText: null });
      },

      // Optimize Alignment Tool actions
      runOptimizeAlignment: async (
        text: string,
        type: 'persona' | 'brand',
        analysisResult: PersonaAlignmentResult | BrandAlignmentResult,
        personaOrBrand: Persona | BrandVoice
      ): Promise<void> => {
        // Validate inputs
        try {
          validateNotEmpty(text, 'Text');
          validateTextLength(text, 'Text');
        } catch (error) {
          set({ 
            optimizeAlignmentError: formatErrorForUser(error, 'Validation'),
            optimizeAlignmentLoading: false 
          });
          logError(error, 'Optimize alignment validation');
          return;
        }

        // Set loading state and store original text
        set({ 
          optimizeAlignmentLoading: true, 
          optimizeAlignmentError: null,
          optimizeAlignmentResult: null,
          optimizeAlignmentChangesSummary: [],
          optimizeAlignmentTargetName: null,
          optimizeAlignmentType: type,
          optimizeAlignmentOriginalText: text,
          optimizeAlignmentModalOpen: false,
        });

        try {
          // Build the request based on type
          const analysisContext = {
            score: analysisResult.score,
            assessment: analysisResult.assessment,
            strengths: type === 'persona' 
              ? (analysisResult as PersonaAlignmentResult).strengths 
              : (analysisResult as BrandAlignmentResult).matches,
            issues: type === 'persona'
              ? (analysisResult as PersonaAlignmentResult).improvements
              : (analysisResult as BrandAlignmentResult).violations,
            recommendations: analysisResult.recommendations,
          };

          const requestBody: Record<string, unknown> = {
            text,
            type,
            analysisContext,
          };

          if (type === 'persona') {
            const persona = personaOrBrand as Persona;
            requestBody.personaContext = {
              name: persona.name,
              demographics: persona.demographics,
              psychographics: persona.psychographics,
              painPoints: persona.painPoints,
              goals: persona.goals,
            };
          } else {
            const brand = personaOrBrand as BrandVoice;
            requestBody.brandContext = {
              brandName: brand.brandName,
              brandTone: brand.brandTone,
              missionStatement: brand.missionStatement,
              brandValues: brand.brandValues,
              approvedPhrases: brand.approvedPhrases,
              forbiddenWords: brand.forbiddenWords,
            };
          }

          const data = await retryWithBackoff(async () => {
            const response = await fetchWithTimeout('/api/optimize-alignment', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(requestBody),
            }, 60000); // 60 second timeout for optimization

            if (!response.ok) {
              const errorData = await response.json().catch(() => ({ 
                error: 'API request failed',
                details: `Status: ${response.status}` 
              }));
              throw new Error(errorData.details || errorData.error || 'Failed to optimize alignment');
            }

            const responseData = await response.json();
            if (!responseData.rewrittenText) {
              throw new Error('No result received from API');
            }
            return responseData;
          }, 2);

          set({ 
            optimizeAlignmentResult: data.rewrittenText,
            optimizeAlignmentChangesSummary: data.changesSummary || [],
            optimizeAlignmentLoading: false,
            optimizeAlignmentError: null,
            optimizeAlignmentTargetName: data.targetName,
            optimizeAlignmentModalOpen: true, // Open the comparison modal
            // rightSidebarOpen already closed at the start, keep it closed
          });

        } catch (error) {
          set({ 
            optimizeAlignmentError: formatErrorForUser(error, 'Optimize alignment'),
            optimizeAlignmentLoading: false,
            optimizeAlignmentResult: null,
            optimizeAlignmentChangesSummary: [],
            optimizeAlignmentTargetName: null,
            optimizeAlignmentModalOpen: false,
          });
          logError(error, 'Optimize alignment');
        }
      },

      clearOptimizeAlignmentResult: () => {
        set({ 
          optimizeAlignmentResult: null, 
          optimizeAlignmentChangesSummary: [],
          optimizeAlignmentError: null, 
          optimizeAlignmentTargetName: null,
          optimizeAlignmentType: null,
          optimizeAlignmentOriginalText: null,
          optimizeAlignmentModalOpen: false,
        });
      },

      setOptimizeAlignmentModalOpen: (open: boolean) => {
        set({ optimizeAlignmentModalOpen: open });
      },

      acceptOptimizeResult: (editor: Editor) => {
        const { optimizeAlignmentResult, selectionRange } = get();
        
        if (!optimizeAlignmentResult) {
          logger.warn('‚ö†Ô∏è No optimize result to accept');
          return;
        }

        try {
          // Import the insert function dynamically to avoid circular deps
          const { insertTextAtSelection } = require('@/lib/editor-utils');
          
          // If we have a selection range, replace that selection
          if (selectionRange) {
            const success = insertTextAtSelection(editor, optimizeAlignmentResult, { isHTML: true });
            if (success) {
              logger.log('‚úÖ Optimized content inserted at selection');
            }
          } else {
            // Otherwise replace entire content
            editor.commands.setContent(optimizeAlignmentResult);
            logger.log('‚úÖ Optimized content replaced entire document');
          }

          // Clear the result after inserting
          set({
            optimizeAlignmentResult: null,
            optimizeAlignmentChangesSummary: [],
            optimizeAlignmentTargetName: null,
            optimizeAlignmentType: null,
            optimizeAlignmentOriginalText: null,
            optimizeAlignmentModalOpen: false,
          });
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : 'Failed to insert content';
          set({ optimizeAlignmentError: errorMessage });
          logError(error, 'Accept optimize result');
        }
      },
      
      // Template Generator actions
      setSelectedTemplateId: (id: string | null) => {
        set({ selectedTemplateId: id });
      },
      
      setIsGeneratingTemplate: (isGenerating: boolean) => {
        set({ isGeneratingTemplate: isGenerating });
      },
      
      // Insights panel actions
      setActiveInsightsPanel: (panel: InsightsPanelType) => {
        set({ activeInsightsPanel: panel });
      },
      
      openInsightsPanel: (panel: InsightsPanelType) => {
        set({ activeInsightsPanel: panel });
      },
      
      closeInsightsPanel: () => {
        set({ activeInsightsPanel: null });
      },
      
      // Pending edit actions
      setPendingBrandVoiceEdit: (brandName: string | null) => {
        set({ pendingBrandVoiceEdit: brandName });
      },
      
      setPendingPersonaEdit: (personaId: string | null) => {
        set({ pendingPersonaEdit: personaId });
      },
    }),
    {
      name: 'copyworx-workspace',
      // Persist ONLY UI state - NO document content!
      partialize: (state) => ({
        activeDocumentId: state.activeDocumentId,
        activeProjectId: state.activeProjectId,
        leftSidebarOpen: state.leftSidebarOpen,
        rightSidebarOpen: state.rightSidebarOpen,
        activeToolId: state.activeToolId,
        aiAnalysisMode: state.aiAnalysisMode,
        viewMode: state.viewMode,
      }),
      onRehydrateStorage: () => (state) => {
        if (state) {
          logger.log('üíæ Store rehydrated from localStorage', {
            activeDocumentId: state.activeDocumentId,
            activeProjectId: state.activeProjectId,
          });
        }
      },
    }
  )
);

/**
 * Hook to check if we're on the client side
 */
export function useIsClient(): boolean {
  const [isClient, setIsClient] = React.useState(false);
  
  React.useEffect(() => {
    setIsClient(true);
  }, []);
  
  return isClient;
}

/**
 * Selector hooks for optimized re-renders
 */
export const useActiveDocumentId = () => useWorkspaceStore((state) => state.activeDocumentId);
export const useLeftSidebarOpen = () => useWorkspaceStore((state) => state.leftSidebarOpen);
export const useRightSidebarOpen = () => useWorkspaceStore((state) => state.rightSidebarOpen);
export const useActiveToolId = () => useWorkspaceStore((state) => state.activeToolId);
export const useAIAnalysisMode = () => useWorkspaceStore((state) => state.aiAnalysisMode);
export const useViewMode = () => useWorkspaceStore((state) => state.viewMode);
export const useSetViewMode = () => useWorkspaceStore((state) => state.setViewMode);

/**
 * Tone Shifter selector hooks
 */
export const useToneShiftResult = () => useWorkspaceStore((state) => state.toneShiftResult);
export const useToneShiftLoading = () => useWorkspaceStore((state) => state.toneShiftLoading);
export const useToneShiftError = () => useWorkspaceStore((state) => state.toneShiftError);
export const useSelectedTone = () => useWorkspaceStore((state) => state.selectedTone);

/**
 * Expand Tool selector hooks
 */
export const useExpandResult = () => useWorkspaceStore((state) => state.expandResult);
export const useExpandLoading = () => useWorkspaceStore((state) => state.expandLoading);
export const useExpandError = () => useWorkspaceStore((state) => state.expandError);

/**
 * Shorten Tool selector hooks
 */
export const useShortenResult = () => useWorkspaceStore((state) => state.shortenResult);
export const useShortenLoading = () => useWorkspaceStore((state) => state.shortenLoading);
export const useShortenError = () => useWorkspaceStore((state) => state.shortenError);

/**
 * Rewrite Channel Tool selector hooks
 */
export const useRewriteChannelResult = () => useWorkspaceStore((state) => state.rewriteChannelResult);
export const useRewriteChannelLoading = () => useWorkspaceStore((state) => state.rewriteChannelLoading);
export const useRewriteChannelError = () => useWorkspaceStore((state) => state.rewriteChannelError);

/**
 * Brand Alignment Tool selector hooks
 */
export const useBrandAlignmentResult = () => useWorkspaceStore((state) => state.brandAlignmentResult);
export const useBrandAlignmentLoading = () => useWorkspaceStore((state) => state.brandAlignmentLoading);
export const useBrandAlignmentError = () => useWorkspaceStore((state) => state.brandAlignmentError);
export const useBrandAlignmentBrandName = () => useWorkspaceStore((state) => state.brandAlignmentBrandName);
export const useBrandAlignmentAnalyzedText = () => useWorkspaceStore((state) => state.brandAlignmentAnalyzedText);

/**
 * Persona Alignment Tool selector hooks
 */
export const usePersonaAlignmentResult = () => useWorkspaceStore((state) => state.personaAlignmentResult);
export const usePersonaAlignmentLoading = () => useWorkspaceStore((state) => state.personaAlignmentLoading);
export const usePersonaAlignmentError = () => useWorkspaceStore((state) => state.personaAlignmentError);
export const usePersonaAlignmentPersonaName = () => useWorkspaceStore((state) => state.personaAlignmentPersonaName);
export const usePersonaAlignmentAnalyzedText = () => useWorkspaceStore((state) => state.personaAlignmentAnalyzedText);

/**
 * Editor selection selector hooks
 */
export const useSelectedText = () => useWorkspaceStore((state) => state.selectedText);
export const useSelectedHTML = () => useWorkspaceStore((state) => state.selectedHTML);
export const useSelectionRange = () => useWorkspaceStore((state) => state.selectionRange);

/**
 * Project selector hooks
 */
export const useProjects = () => useWorkspaceStore((state) => 
  Array.isArray(state.projects) ? state.projects : []
);
export const useActiveProjectId = () => useWorkspaceStore((state) => state.activeProjectId);

/**
 * Template Generator selector hooks
 */
export const useSelectedTemplateId = () => useWorkspaceStore((state) => state.selectedTemplateId);
export const useIsGeneratingTemplate = () => useWorkspaceStore((state) => state.isGeneratingTemplate);

/**
 * Action selector hooks
 */
export const useToneShiftActions = () => useWorkspaceStore(
  useShallow((state) => ({
    runToneShift: state.runToneShift,
    clearToneShiftResult: state.clearToneShiftResult,
    insertToneShiftResult: state.insertToneShiftResult,
    setSelectedTone: state.setSelectedTone,
  }))
);

export const useExpandActions = () => useWorkspaceStore(
  useShallow((state) => ({
    runExpand: state.runExpand,
    clearExpandResult: state.clearExpandResult,
    insertExpandResult: state.insertExpandResult,
  }))
);

export const useShortenActions = () => useWorkspaceStore(
  useShallow((state) => ({
    runShorten: state.runShorten,
    clearShortenResult: state.clearShortenResult,
    insertShortenResult: state.insertShortenResult,
  }))
);

export const useRewriteChannelActions = () => useWorkspaceStore(
  useShallow((state) => ({
    runRewriteChannel: state.runRewriteChannel,
    clearRewriteChannelResult: state.clearRewriteChannelResult,
    insertRewriteChannelResult: state.insertRewriteChannelResult,
  }))
);

export const useBrandAlignmentActions = () => useWorkspaceStore(
  useShallow((state) => ({
    runBrandAlignment: state.runBrandAlignment,
    clearBrandAlignmentResult: state.clearBrandAlignmentResult,
  }))
);

export const usePersonaAlignmentActions = () => useWorkspaceStore(
  useShallow((state) => ({
    runPersonaAlignment: state.runPersonaAlignment,
    clearPersonaAlignmentResult: state.clearPersonaAlignmentResult,
  }))
);

// Optimize Alignment selectors
export const useOptimizeAlignmentResult = () => useWorkspaceStore((state) => state.optimizeAlignmentResult);
export const useOptimizeAlignmentChangesSummary = () => useWorkspaceStore((state) => state.optimizeAlignmentChangesSummary);
export const useOptimizeAlignmentLoading = () => useWorkspaceStore((state) => state.optimizeAlignmentLoading);
export const useOptimizeAlignmentError = () => useWorkspaceStore((state) => state.optimizeAlignmentError);
export const useOptimizeAlignmentTargetName = () => useWorkspaceStore((state) => state.optimizeAlignmentTargetName);
export const useOptimizeAlignmentType = () => useWorkspaceStore((state) => state.optimizeAlignmentType);
export const useOptimizeAlignmentOriginalText = () => useWorkspaceStore((state) => state.optimizeAlignmentOriginalText);
export const useOptimizeAlignmentModalOpen = () => useWorkspaceStore((state) => state.optimizeAlignmentModalOpen);

export const useOptimizeAlignmentActions = () => useWorkspaceStore(
  useShallow((state) => ({
    runOptimizeAlignment: state.runOptimizeAlignment,
    clearOptimizeAlignmentResult: state.clearOptimizeAlignmentResult,
    setOptimizeAlignmentModalOpen: state.setOptimizeAlignmentModalOpen,
    acceptOptimizeResult: state.acceptOptimizeResult,
  }))
);

export const useProjectActions = () => useWorkspaceStore(
  useShallow((state) => ({
    setActiveProjectId: state.setActiveProjectId,
    addProject: state.addProject,
    updateProject: state.updateProject,
    deleteProject: state.deleteProject,
    refreshProjects: state.refreshProjects,
  }))
);

export const useDocumentActions = () => useWorkspaceStore(
  useShallow((state) => ({
    setActiveDocumentId: state.setActiveDocumentId,
    setSelectedText: state.setSelectedText,
  }))
);

export const useUIActions = () => useWorkspaceStore(
  useShallow((state) => ({
    toggleLeftSidebar: state.toggleLeftSidebar,
    toggleRightSidebar: state.toggleRightSidebar,
    setLeftSidebarOpen: state.setLeftSidebarOpen,
    setRightSidebarOpen: state.setRightSidebarOpen,
    setActiveTool: state.setActiveTool,
    clearActiveTool: state.clearActiveTool,
    setAIAnalysisMode: state.setAIAnalysisMode,
    setViewMode: state.setViewMode,
  }))
);

export const useTemplateActions = () => useWorkspaceStore(
  useShallow((state) => ({
    setSelectedTemplateId: state.setSelectedTemplateId,
    setIsGeneratingTemplate: state.setIsGeneratingTemplate,
    clearToneShiftResult: state.clearToneShiftResult,
    clearExpandResult: state.clearExpandResult,
    clearShortenResult: state.clearShortenResult,
    clearRewriteChannelResult: state.clearRewriteChannelResult,
    clearBrandAlignmentResult: state.clearBrandAlignmentResult,
  }))
);

/**
 * Insights panel selector hooks
 */
export const useActiveInsightsPanel = () => useWorkspaceStore((state) => state.activeInsightsPanel);
export const useInsightsPanelActions = () => useWorkspaceStore(
  useShallow((state) => ({
    setActiveInsightsPanel: state.setActiveInsightsPanel,
    openInsightsPanel: state.openInsightsPanel,
    closeInsightsPanel: state.closeInsightsPanel,
  }))
);

/**
 * Pending edit selector hooks
 */
export const usePendingBrandVoiceEdit = () => useWorkspaceStore((state) => state.pendingBrandVoiceEdit);
export const usePendingPersonaEdit = () => useWorkspaceStore((state) => state.pendingPersonaEdit);
export const usePendingEditActions = () => useWorkspaceStore(
  useShallow((state) => ({
    setPendingBrandVoiceEdit: state.setPendingBrandVoiceEdit,
    setPendingPersonaEdit: state.setPendingPersonaEdit,
  }))
);

// ============================================================================
// LEGACY COMPATIBILITY - Keep these for components that haven't been updated
// ============================================================================

/**
 * @deprecated Use useActiveDocumentId instead. This is kept for backward compatibility.
 * Returns null always since we no longer store document content in Zustand.
 */
export const useActiveDocument = () => {
  logger.warn('‚ö†Ô∏è useActiveDocument is deprecated. Use useActiveDocumentId and load from localStorage.');
  return null;
};


=== FILE: lib/supabase.ts ===

/**
 * @file lib/supabase.ts
 * @description Supabase client configuration for CopyWorx
 * 
 * Provides two clients:
 * - supabase: Public client for browser-side operations (uses anon key)
 * - supabaseAdmin: Server-side client for API routes (uses service role key)
 * 
 * IMPORTANT: Always use the appropriate client based on context:
 * - Components/Browser: Use `supabase` 
 * - API Routes: Use `supabaseAdmin` for elevated privileges
 */

import { createClient, SupabaseClient } from '@supabase/supabase-js';
import type { Database } from './types/database';

// Environment variables
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

// Validation for required environment variables
if (!supabaseUrl) {
  console.warn('‚ö†Ô∏è NEXT_PUBLIC_SUPABASE_URL is not set. Supabase features will be disabled.');
}

if (!supabaseAnonKey) {
  console.warn('‚ö†Ô∏è NEXT_PUBLIC_SUPABASE_ANON_KEY is not set. Supabase features will be disabled.');
}

/**
 * Check if Supabase is properly configured
 */
export const isSupabaseConfigured = (): boolean => {
  return Boolean(supabaseUrl && supabaseAnonKey);
};

/**
 * Public Supabase client for browser-side operations
 * Uses anon key - respects Row Level Security (RLS) policies
 */
export const supabase: SupabaseClient<Database> | null = 
  supabaseUrl && supabaseAnonKey
    ? createClient<Database>(supabaseUrl, supabaseAnonKey, {
        auth: {
          persistSession: false, // We use Clerk for auth
          autoRefreshToken: false,
        },
      })
    : null;

/**
 * Admin Supabase client for server-side API routes
 * Uses service role key - bypasses RLS (use carefully!)
 * 
 * SECURITY: Only use in API routes, never expose to client
 */
export const supabaseAdmin: SupabaseClient<Database> | null =
  supabaseUrl && supabaseServiceKey
    ? createClient<Database>(supabaseUrl, supabaseServiceKey, {
        auth: {
          persistSession: false,
          autoRefreshToken: false,
        },
      })
    : null;

/**
 * Get a Supabase client, throwing if not configured
 * Use this when Supabase is required (not optional fallback)
 */
export function getSupabaseClient(): SupabaseClient<Database> {
  if (!supabase) {
    throw new Error(
      'Supabase is not configured. Please set NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY environment variables.'
    );
  }
  return supabase;
}

/**
 * Get the admin Supabase client, throwing if not configured
 * Use this in API routes when elevated privileges are needed
 */
export function getSupabaseAdmin(): SupabaseClient<Database> {
  if (!supabaseAdmin) {
    throw new Error(
      'Supabase admin is not configured. Please set SUPABASE_SERVICE_ROLE_KEY environment variable.'
    );
  }
  return supabaseAdmin;
}


=== FILE: lib/templates/brochure-multi-section-config.ts ===

/**
 * @file lib/templates/brochure-multi-section-config.ts
 * @description Configuration for the Multi-Section Brochure Template
 * 
 * This template allows copywriters to generate brochure content section by section,
 * with each section receiving context from previous sections for consistency.
 * 
 * Sections:
 * 1. Cover/Title
 * 2. Hero/Introduction/Benefits
 * 3. Solutions/Features
 * 4. Case Study/Proof
 * 5. Call-to-Action
 * 6. Other (custom section)
 */

import type { MultiSectionTemplate, TemplateSection } from '@/lib/types/template-progress';

/**
 * Section separator used between generated sections
 * Visible as horizontal rule in editor, clean for print
 */
export const SECTION_SEPARATOR = '\n\n<hr class="brochure-section-break" />\n\n';

/**
 * Cover/Title Section Configuration
 */
export const COVER_SECTION: TemplateSection = {
  id: 'cover',
  name: 'Cover/Title',
  description: 'The front cover that creates first impression and establishes brand identity',
  fields: [
    {
      id: 'brochureTitle',
      label: 'Brochure Title',
      type: 'text',
      placeholder: 'e.g., Transform Your Business with AI-Powered Solutions',
      helperText: 'Main headline for the brochure cover',
      required: true,
      maxLength: 100,
    },
    {
      id: 'subtitle',
      label: 'Subtitle/Tagline',
      type: 'text',
      placeholder: 'e.g., Your Partner in Digital Transformation',
      helperText: 'Supporting line beneath the main title',
      required: false,
      maxLength: 150,
    },
    {
      id: 'companyName',
      label: 'Company Name',
      type: 'text',
      placeholder: 'e.g., Acme Technologies Inc.',
      helperText: 'Your company or brand name',
      required: true,
      maxLength: 100,
    },
    {
      id: 'coverTone',
      label: 'Tone',
      type: 'select',
      helperText: 'The overall tone for the cover',
      required: true,
      options: ['Professional', 'Bold', 'Friendly', 'Authoritative'],
    },
  ],
};

/**
 * Hero/Introduction/Benefits Section Configuration
 */
export const HERO_SECTION: TemplateSection = {
  id: 'hero',
  name: 'Hero/Introduction/Benefits',
  description: 'The opening section that hooks readers and communicates core value',
  fields: [
    {
      id: 'mainValueProp',
      label: 'Main Value Proposition',
      type: 'textarea',
      placeholder: 'e.g., We help mid-size businesses reduce operational costs by 40% through intelligent automation while improving customer satisfaction scores.',
      helperText: 'The core promise and unique value you deliver (2-3 sentences)',
      required: true,
      maxLength: 500,
    },
    {
      id: 'keyBenefits',
      label: 'Key Benefits',
      type: 'textarea',
      placeholder: 'e.g., Reduce costs by 40%, Automate repetitive tasks, 24/7 customer support, Seamless integration',
      helperText: 'Main benefits, separated by commas',
      required: true,
      maxLength: 400,
    },
    {
      id: 'targetAudience',
      label: 'Target Audience',
      type: 'text',
      placeholder: 'e.g., Operations managers at companies with 100-500 employees',
      helperText: 'Who is this brochure for?',
      required: true,
      maxLength: 200,
    },
    {
      id: 'emotionalAngle',
      label: 'Emotional Angle',
      type: 'select',
      helperText: 'Primary emotional driver to emphasize',
      required: true,
      options: ['Trust', 'Innovation', 'Results', 'Transformation'],
    },
  ],
};

/**
 * Solutions/Features Section Configuration
 */
export const SOLUTIONS_SECTION: TemplateSection = {
  id: 'solutions',
  name: 'Solutions/Features',
  description: 'Detailed breakdown of your product/service offerings',
  fields: [
    {
      id: 'productServiceName',
      label: 'Product/Service Name',
      type: 'text',
      placeholder: 'e.g., AutomateNow Platform',
      helperText: 'Name of the product or service being featured',
      required: true,
      maxLength: 100,
    },
    {
      id: 'mainFeatures',
      label: 'Main Features',
      type: 'textarea',
      placeholder: 'e.g.,\nAI-powered workflow automation\nReal-time analytics dashboard\nCustom integration API\n24/7 support portal',
      helperText: 'Key features, one per line',
      required: true,
      maxLength: 600,
    },
    {
      id: 'featureEmphasis',
      label: 'Feature Emphasis',
      type: 'select',
      helperText: 'How should features be presented?',
      required: true,
      options: ['Technical specs', 'User benefits', 'Both'],
    },
  ],
};

/**
 * Case Study/Proof Section Configuration
 */
export const CASE_STUDY_SECTION: TemplateSection = {
  id: 'caseStudy',
  name: 'Case Study/Proof',
  description: 'Social proof through customer success stories or data',
  fields: [
    {
      id: 'includeCaseStudy',
      label: 'Include Case Study?',
      type: 'select',
      helperText: 'Choose the type of proof to include',
      required: true,
      options: ['Yes - Full case study', 'No - Other proof type'],
    },
    // Case study fields (conditional on includeCaseStudy = Yes)
    {
      id: 'clientName',
      label: 'Client Name',
      type: 'text',
      placeholder: 'e.g., GlobalTech Industries',
      helperText: 'Name of the client (can be anonymized)',
      required: false,
      maxLength: 100,
      conditionalOn: {
        fieldId: 'includeCaseStudy',
        value: 'Yes - Full case study',
      },
    },
    {
      id: 'challenge',
      label: 'Challenge',
      type: 'textarea',
      placeholder: 'e.g., GlobalTech was processing 10,000+ invoices monthly with a 5% error rate and 3-day average processing time...',
      helperText: 'What problem did the client face?',
      required: false,
      maxLength: 400,
      conditionalOn: {
        fieldId: 'includeCaseStudy',
        value: 'Yes - Full case study',
      },
    },
    {
      id: 'result',
      label: 'Result',
      type: 'textarea',
      placeholder: 'e.g., Reduced processing time to 4 hours, achieved 99.9% accuracy, saved $200K annually in labor costs...',
      helperText: 'What results did they achieve? Include specific metrics',
      required: false,
      maxLength: 400,
      conditionalOn: {
        fieldId: 'includeCaseStudy',
        value: 'Yes - Full case study',
      },
    },
    // Alternative proof fields (conditional on includeCaseStudy = No)
    {
      id: 'proofType',
      label: 'Other Proof Type',
      type: 'textarea',
      placeholder: 'e.g., "Trusted by 500+ companies including Fortune 500 brands"\n"Winner of 2024 Innovation Award"\n"4.9/5 rating from 1,000+ reviews"',
      helperText: 'Enter testimonials, statistics, awards, or certifications',
      required: false,
      maxLength: 500,
      conditionalOn: {
        fieldId: 'includeCaseStudy',
        value: 'No - Other proof type',
      },
    },
  ],
};

/**
 * Call-to-Action Section Configuration
 */
export const CTA_SECTION: TemplateSection = {
  id: 'cta',
  name: 'Call-to-Action',
  description: 'The closing section that drives reader to take action',
  fields: [
    {
      id: 'primaryCTA',
      label: 'Primary CTA',
      type: 'text',
      placeholder: 'e.g., Schedule Your Free Demo Today',
      helperText: 'The main action you want readers to take',
      required: true,
      maxLength: 100,
    },
    {
      id: 'urgencyLevel',
      label: 'Urgency Level',
      type: 'select',
      helperText: 'How urgent should the call-to-action feel?',
      required: true,
      options: ['High', 'Medium', 'Low'],
    },
    {
      id: 'contactMethod',
      label: 'Contact Method',
      type: 'select',
      helperText: 'How should readers reach you?',
      required: true,
      options: ['Phone', 'Email', 'Website', 'Schedule demo'],
    },
  ],
};

/**
 * Other/Custom Section Configuration
 */
export const OTHER_SECTION: TemplateSection = {
  id: 'other',
  name: 'Other',
  description: 'Custom section for additional content not covered by standard sections',
  fields: [
    {
      id: 'sectionName',
      label: 'Section Name',
      type: 'text',
      placeholder: 'e.g., Pricing Plans, FAQ, Team, History',
      helperText: 'What should this section be called?',
      required: true,
      maxLength: 50,
    },
    {
      id: 'sectionPurpose',
      label: 'Section Purpose',
      type: 'textarea',
      placeholder: 'e.g., This section should outline our three pricing tiers and help readers choose the right plan for their needs...',
      helperText: 'What should this section accomplish? Be specific about goals',
      required: true,
      maxLength: 300,
    },
    {
      id: 'keyPoints',
      label: 'Key Points',
      type: 'textarea',
      placeholder: 'e.g.,\nStarter: $99/mo - up to 10 users\nPro: $299/mo - up to 50 users\nEnterprise: Custom - unlimited users',
      helperText: 'Main points to include in this section',
      required: true,
      maxLength: 600,
    },
  ],
};

/**
 * All sections in order
 */
export const BROCHURE_SECTIONS: TemplateSection[] = [
  COVER_SECTION,
  HERO_SECTION,
  SOLUTIONS_SECTION,
  CASE_STUDY_SECTION,
  CTA_SECTION,
  OTHER_SECTION,
];

/**
 * Get section by ID
 */
export function getSectionById(sectionId: string): TemplateSection | undefined {
  return BROCHURE_SECTIONS.find(section => section.id === sectionId);
}

/**
 * Get section index by ID
 */
export function getSectionIndex(sectionId: string): number {
  return BROCHURE_SECTIONS.findIndex(section => section.id === sectionId);
}

/**
 * System prompt prefix for brochure sections
 */
export const BROCHURE_SYSTEM_PROMPT_PREFIX = `You are an expert B2B copywriter with 20+ years of experience creating high-converting marketing collateral. You specialize in brochure copy that is:
- Benefit-focused and customer-centric
- Professional yet engaging
- Scannable with clear hierarchy
- Consistent in tone and messaging
- Persuasive without being pushy

OUTPUT FORMAT: Generate ONLY clean HTML using these tags:
- <h2> or <h3> for headings
- <p> for paragraphs
- <ul> and <li> for bullet lists
- <strong> for emphasis
- <em> for subtle emphasis

Do NOT include section titles/headers in your output - those are added automatically.
Generate ONLY the body content for the section.`;

/**
 * Build section-specific prompt
 */
export function buildSectionPrompt(
  sectionId: string,
  formData: Record<string, string>,
  previousContent?: string,
  brandVoice?: string,
  persona?: string
): string {
  const section = getSectionById(sectionId);
  if (!section) {
    throw new Error(`Unknown section ID: ${sectionId}`);
  }

  let prompt = BROCHURE_SYSTEM_PROMPT_PREFIX;

  // Add context from previous sections
  if (previousContent && previousContent.trim().length > 0) {
    prompt += `\n\n=== PREVIOUS BROCHURE CONTENT ===
${previousContent}
=== END PREVIOUS CONTENT ===

Your new section MUST:
- Flow naturally from the content above
- Maintain consistent tone and messaging
- Reference and build upon key themes
- Not repeat information already covered`;
  } else {
    prompt += `\n\nThis is the FIRST section of the brochure. Establish the tone and core messaging that subsequent sections will follow.`;
  }

  // Add brand voice if provided
  if (brandVoice) {
    prompt += `\n\n=== BRAND VOICE GUIDELINES ===
${brandVoice}`;
  }

  // Add persona if provided
  if (persona) {
    prompt += `\n\n=== TARGET PERSONA ===
${persona}`;
  }

  // Add section-specific instructions
  prompt += `\n\n=== SECTION: ${section.name.toUpperCase()} ===
${getSectionInstructions(sectionId)}

=== FORM INPUTS ===
${JSON.stringify(formData, null, 2)}

Generate compelling copy for this section that:
1. Achieves the specific goals of a ${section.name} section
2. Uses professional, benefit-focused language
3. Is appropriate length for a brochure (100-250 words)
4. Flows naturally if following previous content

OUTPUT ONLY THE HTML CONTENT. No preamble, no explanations.`;

  return prompt;
}

/**
 * Get section-specific instructions for Claude
 */
function getSectionInstructions(sectionId: string): string {
  const instructions: Record<string, string> = {
    cover: `Purpose: Create an impactful opening that captures attention and establishes brand identity.
Requirements:
- Compelling headline that communicates the core benefit
- Tagline that supports the headline
- Professional brand positioning
Length: Brief - this is cover copy, not body copy. 2-4 lines max.`,

    hero: `Purpose: Hook the reader and communicate your unique value proposition.
Requirements:
- Open with the main value proposition prominently
- Present key benefits in a scannable format
- Address the target audience's needs directly
- Create emotional connection based on the specified angle
Length: 150-200 words, including benefit bullets.`,

    solutions: `Purpose: Detail your product/service offerings and how they solve problems.
Requirements:
- Lead with the product/service name and brief overview
- Present features with clear benefit statements
- Use the specified emphasis (technical, benefits, or both)
- Make it scannable with bullets or short paragraphs
Length: 150-250 words.`,

    caseStudy: `Purpose: Build credibility through proof of results.
Requirements:
- If case study: Tell a compelling transformation story (Challenge ‚Üí Solution ‚Üí Result)
- Include specific metrics and outcomes
- If alternative proof: Present testimonials, stats, or awards compellingly
- Make the proof relevant to the target audience
Length: 150-200 words.`,

    cta: `Purpose: Drive the reader to take immediate action.
Requirements:
- Clear, compelling primary call-to-action
- Match urgency level to the specified setting
- Include appropriate contact method
- Create a sense of what they'll gain by acting
Length: 75-125 words. Keep it focused and actionable.`,

    other: `Purpose: Create a custom section based on user specifications.
Requirements:
- Match the section name and purpose provided
- Cover all key points specified
- Maintain consistency with the brochure's overall tone
- Format appropriately for the content type
Length: 100-200 words.`,
  };

  return instructions[sectionId] || 'Generate professional brochure copy for this section.';
}

/**
 * Complete Multi-Section Brochure Template Definition
 */
export const BROCHURE_MULTI_SECTION_TEMPLATE: MultiSectionTemplate = {
  id: 'brochure-multi-section',
  name: 'Brochure Copy (Multi-Section)',
  category: 'advanced',
  description: 'Generate complete brochure copy section by section with context. Progress saves across sessions.',
  complexity: 'Advanced',
  estimatedTime: '30-45 min',
  icon: 'BookOpen',
  sections: BROCHURE_SECTIONS,
  sectionSeparator: SECTION_SEPARATOR,
  systemPromptPrefix: BROCHURE_SYSTEM_PROMPT_PREFIX,
};

/**
 * Export for template registry
 */
export default BROCHURE_MULTI_SECTION_TEMPLATE;


=== FILE: lib/tiptap/font-size.ts ===

/**
 * @file lib/tiptap/font-size.ts
 * @description Custom TipTap extension for font size support
 * 
 * This extension adds font-size styling capability to TipTap editor.
 * It works with the TextStyle extension to apply inline styles.
 * 
 * Usage:
 * - editor.chain().focus().setFontSize('16px').run()
 * - editor.chain().focus().unsetFontSize().run()
 * - editor.getAttributes('textStyle').fontSize
 */

import { Extension } from '@tiptap/core';

export interface FontSizeOptions {
  /**
   * Available font sizes that can be applied.
   * Default includes common sizes from 8px to 72px.
   */
  sizes: string[];
}

declare module '@tiptap/core' {
  interface Commands<ReturnType> {
    fontSize: {
      /**
       * Set the font size
       */
      setFontSize: (size: string) => ReturnType;
      /**
       * Unset the font size
       */
      unsetFontSize: () => ReturnType;
    };
  }
}

/**
 * FontSize extension for TipTap
 * 
 * Adds font-size as a style attribute to the textStyle mark.
 * Requires @tiptap/extension-text-style to be installed.
 */
export const FontSize = Extension.create<FontSizeOptions>({
  name: 'fontSize',

  addOptions() {
    return {
      sizes: ['8px', '10px', '11px', '12px', '14px', '16px', '18px', '20px', '24px', '28px', '32px', '36px', '48px', '72px'],
    };
  },

  addGlobalAttributes() {
    return [
      {
        types: ['textStyle'],
        attributes: {
          fontSize: {
            default: null,
            parseHTML: element => element.style.fontSize?.replace(/['"]+/g, '') || null,
            renderHTML: attributes => {
              if (!attributes.fontSize) {
                return {};
              }
              return {
                style: `font-size: ${attributes.fontSize}`,
              };
            },
          },
        },
      },
    ];
  },

  addCommands() {
    return {
      setFontSize:
        (size: string) =>
        ({ chain }) => {
          return chain().setMark('textStyle', { fontSize: size }).run();
        },
      unsetFontSize:
        () =>
        ({ chain }) => {
          return chain().setMark('textStyle', { fontSize: null }).removeEmptyTextStyle().run();
        },
    };
  },
});

export default FontSize;


=== FILE: lib/tools/index.ts ===

/**
 * @file lib/tools/index.ts
 * @description Barrel export for tools module
 */

export * from './toolRegistry';


=== FILE: lib/tools/toolRegistry.ts ===

/**
 * @file lib/tools/toolRegistry.ts
 * @description Centralized tool registry for CopyWorx workspace
 * 
 * Manages all tools available in the workspace with their metadata,
 * organization into sections, and helper functions for tool lookup.
 * 
 * Architecture:
 * - LEFT SIDEBAR: Tool selector with collapsible sections
 * - RIGHT SIDEBAR: Active tool interface dynamically rendered
 */

import type { LucideIcon } from 'lucide-react';
import {
  Wand2,
  Maximize2,
  Minimize2,
  Repeat,
  Users,
  Volume2,
  Target,
  UserCheck,
  Zap,
} from 'lucide-react';

/**
 * Tool section types for organizing tools in the left sidebar
 */
export type ToolSection = 'optimizer' | 'brand' | 'insights';

/**
 * Tool configuration interface
 */
export interface ToolConfig {
  /** Unique identifier for the tool */
  id: string;
  
  /** Display name of the tool */
  name: string;
  
  /** Lucide icon component */
  icon: LucideIcon;
  
  /** Section this tool belongs to */
  section: ToolSection;
  
  /** Short description */
  description: string;
  
  /** Optional: Whether tool requires a document to be open */
  requiresDocument?: boolean;
  
  /** Optional: Badge text (e.g., "NEW", "BETA") */
  badge?: string;
}

/**
 * Complete tool registry
 * All tools available in CopyWorx workspace
 */
export const TOOLS: ToolConfig[] = [
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // MY COPY OPTIMIZER
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 'tone-shifter',
    name: 'Tone Shifter',
    icon: Wand2,
    section: 'optimizer',
    description: 'Rewrite in different tones',
    requiresDocument: true,
  },
  {
    id: 'expand',
    name: 'Expand',
    icon: Maximize2,
    section: 'optimizer',
    description: 'Make copy longer and more detailed',
    requiresDocument: true,
  },
  {
    id: 'shorten',
    name: 'Shorten',
    icon: Minimize2,
    section: 'optimizer',
    description: 'Make copy more concise',
    requiresDocument: true,
  },
  {
    id: 'rewrite-channel',
    name: 'Rewrite for Channel',
    icon: Repeat,
    section: 'optimizer',
    description: 'Adapt for different platforms',
    requiresDocument: true,
  },
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // MY BRAND & AUDIENCE
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 'personas',
    name: 'Personas',
    icon: Users,
    section: 'brand',
    description: 'Target audience profiles',
    requiresDocument: false,
  },
  {
    id: 'brand-voice',
    name: 'Brand Voice',
    icon: Volume2,
    section: 'brand',
    description: 'Brand tone & style guidelines',
    requiresDocument: false,
  },
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // MY INSIGHTS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    id: 'competitor-analyzer',
    name: 'Competitor Analyzer',
    icon: Target,
    section: 'insights',
    description: 'Analyze competitor copy',
    requiresDocument: false,
  },
  {
    id: 'persona-alignment',
    name: 'Persona Alignment',
    icon: UserCheck,
    section: 'insights',
    description: 'Check persona fit',
    requiresDocument: true,
  },
  {
    id: 'brand-alignment',
    name: 'Brand Alignment',
    icon: Zap,
    section: 'insights',
    description: 'Check brand consistency',
    requiresDocument: true,
  },
];

/**
 * Section metadata for organizing the left sidebar
 */
export interface SectionConfig {
  id: ToolSection;
  name: string;
  icon: LucideIcon;
  description: string;
  defaultExpanded?: boolean;
}

export const SECTIONS: SectionConfig[] = [
  {
    id: 'optimizer',
    name: 'My Copy Optimizer',
    icon: Wand2,
    description: 'Improve and refine your copy',
    defaultExpanded: true,
  },
  {
    id: 'brand',
    name: 'Brand & Audience',
    icon: Users,
    description: 'Brand voice and target personas',
    defaultExpanded: false,
  },
  {
    id: 'insights',
    name: 'My Insights',
    icon: Target,
    description: 'Analyze and align your copy',
    defaultExpanded: false,
  },
];

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HELPER FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

/**
 * Get a tool by its ID
 * @param id Tool identifier
 * @returns Tool configuration or undefined
 */
export function getToolById(id: string): ToolConfig | undefined {
  return TOOLS.find((tool) => tool.id === id);
}

/**
 * Get all tools in a specific section
 * @param section Section identifier
 * @returns Array of tools in that section
 */
export function getToolsBySection(section: ToolSection): ToolConfig[] {
  return TOOLS.filter((tool) => tool.section === section);
}

/**
 * Get section configuration by ID
 * @param id Section identifier
 * @returns Section configuration or undefined
 */
export function getSectionById(id: ToolSection): SectionConfig | undefined {
  return SECTIONS.find((section) => section.id === id);
}

/**
 * Check if a tool requires an active document
 * @param toolId Tool identifier
 * @returns True if tool requires a document
 */
export function toolRequiresDocument(toolId: string): boolean {
  const tool = getToolById(toolId);
  return tool?.requiresDocument ?? false;
}

/**
 * Get all tool IDs
 * @returns Array of all tool IDs
 */
export function getAllToolIds(): string[] {
  return TOOLS.map((tool) => tool.id);
}

/**
 * Get all section IDs
 * @returns Array of all section IDs
 */
export function getAllSectionIds(): ToolSection[] {
  return SECTIONS.map((section) => section.id);
}

/**
 * Validate if a tool ID exists
 * @param toolId Tool identifier to validate
 * @returns True if tool exists
 */
export function isValidToolId(toolId: string): boolean {
  return TOOLS.some((tool) => tool.id === toolId);
}

/**
 * Validate if a section ID exists
 * @param sectionId Section identifier to validate
 * @returns True if section exists
 */
export function isValidSectionId(sectionId: string): sectionId is ToolSection {
  return SECTIONS.some((section) => section.id === sectionId);
}


=== FILE: lib/types/brand.ts ===

/**
 * @file lib/types/brand.ts
 * @description TypeScript types for Brand Voice feature
 */

/**
 * Brand Voice configuration interface
 */
export interface BrandVoice {
  /** Brand name (required) */
  brandName: string;
  
  /** Description of brand tone and personality */
  brandTone: string;
  
  /** List of approved phrases that align with brand voice */
  approvedPhrases: string[];
  
  /** List of forbidden words/phrases to avoid */
  forbiddenWords: string[];
  
  /** Core brand values */
  brandValues: string[];
  
  /** Mission statement */
  missionStatement: string;
  
  /** Timestamp when saved */
  savedAt?: Date;
}

/**
 * Brand alignment check result
 */
export interface BrandAlignmentResult {
  /** Overall alignment score (0-100) */
  score: number;
  
  /** Overall assessment text */
  assessment: string;
  
  /** What matches brand voice well */
  matches: string[];
  
  /** What violates brand voice */
  violations: string[];
  
  /** Specific recommendations for improvement */
  recommendations: string[];
}

/**
 * Brand alignment check request
 */
export interface BrandAlignmentRequest {
  /** Text to check */
  text: string;
  
  /** Brand voice configuration */
  brandVoice: BrandVoice;
}

/**
 * Brand alignment check response
 */
export interface BrandAlignmentResponse {
  result: BrandAlignmentResult;
  textLength: number;
  /** Brand name that was analyzed against */
  brandName: string;
}

// ============================================================================
// Optimize Alignment Types
// ============================================================================

/**
 * Type of alignment optimization
 */
export type OptimizeAlignmentType = 'persona' | 'brand';

/**
 * Analysis results used for optimization context
 */
export interface OptimizeAnalysisContext {
  /** Alignment score from analysis */
  score: number;
  /** Assessment summary */
  assessment: string;
  /** Strengths/matches to preserve */
  strengths: string[];
  /** Issues/violations to fix */
  issues: string[];
  /** Recommendations to implement */
  recommendations: string[];
}

/**
 * Persona context for optimization
 */
export interface OptimizePersonaContext {
  name: string;
  demographics?: string;
  psychographics?: string;
  painPoints?: string;
  goals?: string;
}

/**
 * Brand context for optimization
 */
export interface OptimizeBrandContext {
  brandName: string;
  brandTone?: string;
  missionStatement?: string;
  brandValues?: string[];
  approvedPhrases?: string[];
  forbiddenWords?: string[];
}

/**
 * Request body for optimize alignment API
 */
export interface OptimizeAlignmentRequest {
  /** Original copy text to rewrite */
  text: string;
  /** Type of alignment optimization */
  type: OptimizeAlignmentType;
  /** Analysis results for context */
  analysisContext: OptimizeAnalysisContext;
  /** Persona context (required if type is 'persona') */
  personaContext?: OptimizePersonaContext;
  /** Brand context (required if type is 'brand') */
  brandContext?: OptimizeBrandContext;
}

/**
 * Response from optimize alignment API
 */
export interface OptimizeAlignmentResponse {
  /** Rewritten copy optimized for alignment */
  rewrittenText: string;
  /** Brief summary of changes made */
  changesSummary: string[];
  /** Original text length */
  originalLength: number;
  /** New text length */
  newLength: number;
  /** Target name (persona or brand) */
  targetName: string;
}


=== FILE: lib/types/database.ts ===

/**
 * @file lib/types/database.ts
 * @description TypeScript types for Supabase database schema
 * 
 * This file defines the database schema types for type-safe
 * Supabase operations. Update this file when schema changes.
 */

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[];

/**
 * Database schema types for Supabase
 */
export interface Database {
  public: {
    Tables: {
      /**
       * Projects table - Top-level organizational unit
       */
      projects: {
        Row: {
          id: string;
          user_id: string;
          name: string;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          name: string;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          user_id?: string;
          name?: string;
          created_at?: string;
          updated_at?: string;
        };
      };

      /**
       * Documents table - Copywriting content with version control
       */
      documents: {
        Row: {
          id: string;
          project_id: string;
          user_id: string;
          base_title: string;
          title: string;
          version: number;
          parent_version_id: string | null;
          folder_id: string | null;
          content: string;
          metadata: Json | null;
          template_progress: Json | null;
          created_at: string;
          modified_at: string;
        };
        Insert: {
          id?: string;
          project_id: string;
          user_id: string;
          base_title: string;
          title: string;
          version?: number;
          parent_version_id?: string | null;
          folder_id?: string | null;
          content?: string;
          metadata?: Json | null;
          template_progress?: Json | null;
          created_at?: string;
          modified_at?: string;
        };
        Update: {
          id?: string;
          project_id?: string;
          user_id?: string;
          base_title?: string;
          title?: string;
          version?: number;
          parent_version_id?: string | null;
          folder_id?: string | null;
          content?: string;
          metadata?: Json | null;
          template_progress?: Json | null;
          created_at?: string;
          modified_at?: string;
        };
      };

      /**
       * Brand voices table - Brand configuration per project
       */
      brand_voices: {
        Row: {
          id: string;
          project_id: string;
          user_id: string;
          brand_name: string;
          brand_tone: string;
          approved_phrases: string[];
          forbidden_words: string[];
          brand_values: string[];
          mission_statement: string;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          project_id: string;
          user_id: string;
          brand_name: string;
          brand_tone?: string;
          approved_phrases?: string[];
          forbidden_words?: string[];
          brand_values?: string[];
          mission_statement?: string;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          project_id?: string;
          user_id?: string;
          brand_name?: string;
          brand_tone?: string;
          approved_phrases?: string[];
          forbidden_words?: string[];
          brand_values?: string[];
          mission_statement?: string;
          created_at?: string;
          updated_at?: string;
        };
      };

      /**
       * Personas table - Target audience profiles
       */
      personas: {
        Row: {
          id: string;
          project_id: string;
          user_id: string;
          name: string;
          photo_url: string | null;
          demographics: string;
          psychographics: string;
          pain_points: string;
          language_patterns: string;
          goals: string;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          project_id: string;
          user_id: string;
          name: string;
          photo_url?: string | null;
          demographics?: string;
          psychographics?: string;
          pain_points?: string;
          language_patterns?: string;
          goals?: string;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          project_id?: string;
          user_id?: string;
          name?: string;
          photo_url?: string | null;
          demographics?: string;
          psychographics?: string;
          pain_points?: string;
          language_patterns?: string;
          goals?: string;
          created_at?: string;
          updated_at?: string;
        };
      };

      /**
       * Folders table - Document organization
       */
      folders: {
        Row: {
          id: string;
          project_id: string;
          user_id: string;
          name: string;
          parent_folder_id: string | null;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          project_id: string;
          user_id: string;
          name: string;
          parent_folder_id?: string | null;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          project_id?: string;
          user_id?: string;
          name?: string;
          parent_folder_id?: string | null;
          created_at?: string;
          updated_at?: string;
        };
      };

      /**
       * Snippets table - Reusable copy elements
       */
      snippets: {
        Row: {
          id: string;
          project_id: string;
          user_id: string;
          name: string;
          content: string;
          description: string | null;
          tags: string[] | null;
          usage_count: number;
          created_at: string;
          modified_at: string;
        };
        Insert: {
          id?: string;
          project_id: string;
          user_id: string;
          name: string;
          content: string;
          description?: string | null;
          tags?: string[] | null;
          usage_count?: number;
          created_at?: string;
          modified_at?: string;
        };
        Update: {
          id?: string;
          project_id?: string;
          user_id?: string;
          name?: string;
          content?: string;
          description?: string | null;
          tags?: string[] | null;
          usage_count?: number;
          created_at?: string;
          modified_at?: string;
        };
      };

      /**
       * User settings table - Per-user preferences
       */
      user_settings: {
        Row: {
          id: string;
          user_id: string;
          active_project_id: string | null;
          settings: Json;
          created_at: string;
          updated_at: string;
        };
        Insert: {
          id?: string;
          user_id: string;
          active_project_id?: string | null;
          settings?: Json;
          created_at?: string;
          updated_at?: string;
        };
        Update: {
          id?: string;
          user_id?: string;
          active_project_id?: string | null;
          settings?: Json;
          created_at?: string;
          updated_at?: string;
        };
      };

      /**
       * API usage logs table - Tracks Claude API token usage per user
       */
      api_usage_logs: {
        Row: {
          id: string;
          user_id: string;
          timestamp: string;
          model: string;
          input_tokens: number;
          output_tokens: number;
          total_tokens: number;
          feature: string;
          cost_usd: number;
        };
        Insert: {
          id?: string;
          user_id: string;
          timestamp?: string;
          model: string;
          input_tokens: number;
          output_tokens: number;
          feature: string;
          cost_usd: number;
        };
        Update: {
          id?: string;
          user_id?: string;
          timestamp?: string;
          model?: string;
          input_tokens?: number;
          output_tokens?: number;
          feature?: string;
          cost_usd?: number;
        };
      };
    };
    Views: {
      /**
       * User usage summary view - Aggregated usage statistics per user
       */
      user_usage_summary: {
        Row: {
          user_id: string;
          total_api_calls: number;
          total_input_tokens: number;
          total_output_tokens: number;
          total_tokens_used: number;
          total_cost_usd: number;
          last_api_call: string | null;
        };
      };
      /**
       * User usage current month view - Monthly usage for limit enforcement
       */
      user_usage_current_month: {
        Row: {
          user_id: string;
          api_calls_this_month: number;
          input_tokens_this_month: number;
          output_tokens_this_month: number;
          total_tokens_this_month: number;
          cost_this_month: number;
          last_api_call: string | null;
        };
      };
      /**
       * User usage today view - Daily usage for rate limiting
       */
      user_usage_today: {
        Row: {
          user_id: string;
          api_calls_today: number;
          tokens_today: number;
          cost_today: number;
        };
      };
    };
    Functions: {
      /**
       * Get user usage for a specific period
       */
      get_user_usage: {
        Args: {
          p_user_id: string;
          p_start_date?: string | null;
          p_end_date?: string | null;
        };
        Returns: {
          total_api_calls: number;
          total_input_tokens: number;
          total_output_tokens: number;
          total_tokens: number;
          total_cost: number;
        }[];
      };
      /**
       * Check if user is within beta limits
       */
      check_user_within_limits: {
        Args: {
          p_user_id: string;
          p_monthly_token_limit?: number;
          p_daily_token_limit?: number;
        };
        Returns: {
          within_monthly_limit: boolean;
          within_daily_limit: boolean;
          monthly_tokens_used: number;
          daily_tokens_used: number;
          monthly_tokens_remaining: number;
          daily_tokens_remaining: number;
        }[];
      };
    };
    Enums: {
      [_ in never]: never;
    };
  };
}

/**
 * Helper type to extract Row type from a table
 */
export type TableRow<T extends keyof Database['public']['Tables']> =
  Database['public']['Tables'][T]['Row'];

/**
 * Helper type to extract Insert type from a table
 */
export type TableInsert<T extends keyof Database['public']['Tables']> =
  Database['public']['Tables'][T]['Insert'];

/**
 * Helper type to extract Update type from a table
 */
export type TableUpdate<T extends keyof Database['public']['Tables']> =
  Database['public']['Tables'][T]['Update'];


=== FILE: lib/types/docshift.d.ts ===

/**
 * @file lib/types/docshift.d.ts
 * @description Type declarations for the docshift module
 * 
 * DocShift is a client-side library for converting between HTML and DOCX formats.
 * @see https://github.com/ducbao414/docshift
 */

declare module 'docshift' {
  /**
   * Convert HTML content to DOCX format
   * 
   * @param html - HTML string to convert
   * @returns Promise<Blob> - The DOCX file as a Blob
   */
  export function toDocx(html: string): Promise<Blob>;

  /**
   * Convert DOCX file to HTML format
   * 
   * @param docx - DOCX file as Blob or ArrayBuffer
   * @returns Promise<string> - The HTML string
   */
  export function toHtml(docx: Blob | ArrayBuffer): Promise<string>;
}


=== FILE: lib/types/global.d.ts ===

/**
 * @file lib/types/global.d.ts
 * @description Global TypeScript type declarations
 * 
 * Extends global interfaces and types used throughout the application
 */

import type { Editor } from '@tiptap/react';

/**
 * Extend Window interface to include custom properties
 */
declare global {
  interface Window {
    /**
     * TipTap editor instance exposed for debugging and toolbar access
     * @internal Used by EditorArea and Toolbar components
     */
    __tiptapEditor?: Editor;
  }
}

// This export is needed to make this file a module
export {};


=== FILE: lib/types/index.ts ===

/**
 * @file lib/types/index.ts
 * @description Core TypeScript type definitions for CopyWorx v2
 * 
 * Exports all shared types used across the application including:
 * - Document models
 * - Tool categories
 * - AI analysis modes
 * - Workspace state
 * - Project types
 */

// Re-export project types
export type { Project, Persona, ProjectDocument, Folder } from './project';
export { isProject, isFolder } from './project';

// Re-export snippet types
export type { Snippet, CreateSnippetInput, UpdateSnippetInput } from './snippet';
export { isSnippet, validateSnippetName, validateSnippetContent } from './snippet';

// Re-export brand types
export type { BrandVoice, BrandAlignmentResult, BrandAlignmentRequest, BrandAlignmentResponse } from './brand';

// Re-export template types
export type { 
  Template as TemplateDefinition,
  TemplateCategory,
  TemplateField,
  TemplateFormData,
  TemplateGenerationRequest,
  TemplateGenerationResponse
} from './template';

// Re-export template progress types for multi-section templates
export type {
  TemplateProgress,
  TemplateSection,
  TemplateSectionField,
  CompletedSection,
  MultiSectionTemplate,
  SectionGenerationRequest,
  SectionGenerationResponse,
  SectionStatus
} from './template-progress';
export {
  isValidTemplateProgress,
  createInitialProgress,
  generateContentHash
} from './template-progress';

/**
 * Represents a copywriting document in the workspace
 */
export interface Document {
  /** Unique identifier for the document */
  id: string;
  
  /** Document title/name */
  title: string;
  
  /** Raw text content of the document */
  content: string;
  
  /** Timestamp when document was first created */
  createdAt: Date;
  
  /** Timestamp when document was last modified */
  modifiedAt: Date;
  
  /** Optional metadata for document */
  metadata?: {
    /** Word count */
    wordCount?: number;
    
    /** Character count */
    charCount?: number;
    
    /** Associated template ID if created from template */
    templateId?: string;
    
    /** Tags for organization */
    tags?: string[];
  };
}

/**
 * Categories of tools available in the left sidebar
 */
export type ToolCategory = 
  | 'optimizer'   // Text optimization tools
  | 'templates'   // Copywriting templates
  | 'brand'       // Brand voice tools
  | 'insights';   // Analytics and insights

/**
 * AI analysis modes for the right sidebar
 */
export type AIAnalysisMode = 
  | 'emotional'   // Emotional tone analysis
  | 'persona'     // Target persona analysis
  | 'brand'       // Brand voice consistency
  | null;         // No analysis active

/**
 * Sidebar position identifier
 */
export type SidebarPosition = 'left' | 'right';

/**
 * Workspace action types for routing
 */
export type WorkspaceAction = 
  | 'new'         // Create new blank document
  | 'template'    // Start from template
  | 'import';     // Import text file

/**
 * @deprecated Use TemplateDefinition from './template' instead
 * Legacy Template interface maintained for backwards compatibility
 */
export interface Template {
  /** Template unique identifier */
  id: string;
  
  /** Template display name */
  name: string;
  
  /** Template description */
  description: string;
  
  /** Template category */
  category: string;
  
  /** Template content structure */
  structure: string;
  
  /** Example/placeholder content */
  example?: string;
}

/**
 * AI analysis result
 */
export interface AnalysisResult {
  /** Analysis type */
  type: AIAnalysisMode;
  
  /** Timestamp of analysis */
  timestamp: Date;
  
  /** Analysis data */
  data: Record<string, unknown>;
  
  /** Confidence score (0-1) */
  confidence?: number;
}

/**
 * Editor content representation
 */
export interface EditorContent {
  /** HTML content from TipTap editor */
  html: string;
  
  /** Plain text content (stripped of HTML) */
  text: string;
  
  /** Word count */
  wordCount: number;
  
  /** Character count (including spaces) */
  characterCount: number;
}

/**
 * Auto-save status indicator
 */
export type SaveStatus = 'idle' | 'saving' | 'saved' | 'error';

/**
 * Editor view mode options
 * - scrolling: Continuous scroll mode (default)
 * - focus: Distraction-free writing mode
 */
export type ViewMode = 'scrolling' | 'focus';

=== FILE: lib/types/pagedjs.d.ts ===

/**
 * @file lib/types/pagedjs.d.ts
 * @description TypeScript type declarations for Paged.js library
 * 
 * Paged.js is a free and open source JavaScript library that paginates content
 * in the browser to create PDF output from any HTML content.
 * 
 * @see https://www.pagedjs.org/
 */

declare module 'pagedjs' {
  /**
   * Configuration options for the Paged.js Previewer
   */
  export interface PreviewerOptions {
    /** The content to paginate (HTML string or DOM element) */
    content?: string | HTMLElement;
    
    /** CSS stylesheets to apply */
    stylesheets?: string[];
    
    /** Container element to render pages into */
    renderTo?: HTMLElement;
    
    /** Whether to use polisher for CSS processing */
    polisher?: boolean;
    
    /** Whether to automatically start preview */
    autoStart?: boolean;
  }

  /**
   * Represents a single rendered page
   */
  export interface RenderedPage {
    /** Page index (0-based) */
    id: number;
    
    /** DOM element containing the page */
    element: HTMLElement;
    
    /** Page width in pixels */
    width: number;
    
    /** Page height in pixels */
    height: number;
    
    /** Whether this is a left or right page (for spreads) */
    side?: 'left' | 'right';
  }

  /**
   * Result returned after preview completes
   */
  export interface PreviewResult {
    /** Total number of pages */
    total: number;
    
    /** Array of rendered page objects */
    pages: RenderedPage[];
    
    /** The container element with all pages */
    container: HTMLElement;
  }

  /**
   * The Previewer class - main entry point for rendering paginated content
   */
  export class Previewer {
    /**
     * Creates a new Previewer instance
     * @param options - Configuration options
     */
    constructor(options?: PreviewerOptions);

    /**
     * Preview content and render pages
     * @param content - HTML content to paginate
     * @param stylesheets - Array of CSS stylesheet URLs
     * @param renderTo - Container element to render into
     * @returns Promise resolving to preview result
     */
    preview(
      content?: string | HTMLElement,
      stylesheets?: string[],
      renderTo?: HTMLElement
    ): Promise<PreviewResult>;

    /**
     * Destroy the previewer and clean up resources
     */
    destroy(): void;

    /**
     * Get all rendered pages
     */
    pages: RenderedPage[];

    /**
     * Total number of pages
     */
    total: number;

    /**
     * Register hooks for various stages of the rendering process
     */
    registerHandlers(handlers: object): void;
  }

  /**
   * The Chunker class - handles content chunking for pagination
   */
  export class Chunker {
    constructor();
    
    /**
     * Chunk content into pages
     */
    flow(content: HTMLElement, renderTo: HTMLElement): Promise<void>;
  }

  /**
   * The Polisher class - processes CSS for paged media
   */
  export class Polisher {
    constructor();
    
    /**
     * Add CSS stylesheets for processing
     */
    add(...sheets: (string | CSSStyleSheet)[]): Promise<void>;
    
    /**
     * Get the processed CSS
     */
    toString(): string;
  }

  /**
   * Handler class for customizing pagination behavior
   */
  export class Handler {
    constructor();
  }

  /**
   * Initialize Paged.js polyfill (for automatic pagination on page load)
   */
  export function initializeHandler(): void;

  /**
   * Register custom handlers
   */
  export function registerHandlers(...handlers: Handler[]): void;
}


=== FILE: lib/types/project.ts ===

/**
 * @file lib/types/project.ts
 * @description TypeScript type definitions for project-based architecture
 * 
 * Projects are the top-level organizational unit in CopyWorx.
 * Each project contains:
 * - Brand voice configuration
 * - Personas (target audience profiles)
 * - Documents (copywriting content)
 */

import type { BrandVoice } from './brand';
import type { Snippet } from './snippet';
import type { TemplateProgress } from './template-progress';

/**
 * Folder interface - Organizational container for documents
 * 
 * Folder Hierarchy:
 * - Top-level folders: parentFolderId is undefined/null (sits at project root)
 * - Nested folders: parentFolderId points to another folder (subfolder)
 * 
 * Example structure:
 * Project: EFI
 * ‚îú‚îÄ‚îÄ folders: [
 * ‚îÇ     { id: "f1", name: "Website Copy", parentFolderId: null },
 * ‚îÇ     { id: "f2", name: "Email Campaigns", parentFolderId: null },
 * ‚îÇ     { id: "f3", name: "Q1 Launch", parentFolderId: "f2" }  ‚Üê nested under Email
 * ‚îÇ   ]
 */
export interface Folder {
  /** Unique identifier (UUID format) */
  id: string;
  
  /** Folder name (e.g., "Website Copy") */
  name: string;
  
  /** Project ID this folder belongs to */
  projectId: string;
  
  /** Parent folder ID for nested folders (undefined/null for top-level) */
  parentFolderId?: string;
  
  /** ISO date string when folder was created */
  createdAt: string;
  
  /** ISO date string when folder was last updated */
  updatedAt: string;
}

/**
 * Project interface - Top-level organizational unit
 */
export interface Project {
  /** Unique identifier (UUID format) */
  id: string;
  
  /** Project name (user-defined) */
  name: string;
  
  /** Brand voice configuration for this project */
  brandVoice: BrandVoice | null;
  
  /** Array of personas (target audience profiles) */
  personas: Persona[];
  
  /** Array of folders for document organization */
  folders: Folder[];
  
  /** Array of documents (copywriting content) */
  documents: ProjectDocument[];
  
  /** Array of reusable copy snippets */
  snippets: Snippet[];
  
  /** ISO date string when project was created */
  createdAt: string;
  
  /** ISO date string when project was last updated */
  updatedAt: string;
}

/**
 * Persona interface - Target audience profile
 * Represents a detailed persona for targeting specific audiences
 */
export interface Persona {
  /** Unique identifier */
  id: string;
  
  /** Persona name and title (e.g., "Sarah, the Startup Founder") */
  name: string;
  
  /** Optional photo URL or base64 encoded image */
  photoUrl?: string;
  
  /** Demographics: Age, income, location, job title */
  demographics: string;
  
  /** Psychographics: Values, interests, lifestyle, personality traits */
  psychographics: string;
  
  /** Pain points: Problems and frustrations they face */
  painPoints: string;
  
  /** Language patterns: Words and phrases they use and respond to */
  languagePatterns: string;
  
  /** Goals and aspirations: What they want to achieve */
  goals: string;
  
  /** ISO date string when created */
  createdAt: string;
  
  /** ISO date string when last updated */
  updatedAt: string;
}

/**
 * Project Document interface - Copywriting content with version control
 * 
 * Version Control Model:
 * - baseTitle: Root name without version (e.g., "EFI Homepage Hero")
 * - title: Computed as "{baseTitle} v{version}" (e.g., "EFI Homepage Hero v2")
 * - version: Sequential number (1, 2, 3, etc.)
 * - parentVersionId: Links to the original version this was created from
 * 
 * This enables:
 * 1. Tracking document versions (v1, v2, v3)
 * 2. Creating new versions while preserving originals
 * 3. Linking versions together via parentVersionId
 * 4. Grouping versions in the UI by baseTitle
 */
export interface ProjectDocument {
  /** Unique identifier (UUID format) */
  id: string;
  
  /** Project this document belongs to */
  projectId: string;
  
  /** Base title without version number (e.g., "EFI Homepage Hero") */
  baseTitle: string;
  
  /** Full document title, computed as "{baseTitle} v{version}" */
  title: string;
  
  /** Version number (1, 2, 3, etc.) */
  version: number;
  
  /** ID of the parent version this was created from (optional) */
  parentVersionId?: string;
  
  /** Folder ID for future folder organization support (optional) */
  folderId?: string;
  
  /** Document content (HTML from TipTap editor) */
  content: string;
  
  /** ISO date string when created */
  createdAt: string;
  
  /** ISO date string when last modified */
  modifiedAt: string;
  
  /** Optional metadata */
  metadata?: {
    /** Word count */
    wordCount?: number;
    
    /** Character count */
    charCount?: number;
    
    /** Associated template ID */
    templateId?: string;
    
    /** Tags for organization */
    tags?: string[];
  };
  
  /**
   * Template progress state for multi-section templates
   * Tracks section-by-section generation progress and allows resuming
   */
  templateProgress?: TemplateProgress;
}

/**
 * Type guard to check if a value is a valid Folder
 */
export function isFolder(value: unknown): value is Folder {
  if (!value || typeof value !== 'object') return false;
  
  const obj = value as Record<string, unknown>;
  
  return (
    typeof obj.id === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.projectId === 'string' &&
    (obj.parentFolderId === undefined || obj.parentFolderId === null || typeof obj.parentFolderId === 'string') &&
    typeof obj.createdAt === 'string' &&
    typeof obj.updatedAt === 'string'
  );
}

/**
 * Type guard to check if a value is a valid Project
 */
export function isProject(value: unknown): value is Project {
  if (!value || typeof value !== 'object') return false;
  
  const obj = value as Record<string, unknown>;
  
  return (
    typeof obj.id === 'string' &&
    typeof obj.name === 'string' &&
    (obj.brandVoice === null || typeof obj.brandVoice === 'object') &&
    Array.isArray(obj.personas) &&
    Array.isArray(obj.folders) &&
    Array.isArray(obj.documents) &&
    // snippets is optional for backward compatibility
    (obj.snippets === undefined || Array.isArray(obj.snippets)) &&
    typeof obj.createdAt === 'string' &&
    typeof obj.updatedAt === 'string'
  );
}


=== FILE: lib/types/snippet.ts ===

/**
 * @file lib/types/snippet.ts
 * @description TypeScript type definitions for project-scoped snippets
 * 
 * Snippets are reusable copy elements that belong to a specific project.
 * Users can save frequently used text (taglines, CTAs, boilerplate, etc.)
 * and quickly insert them into documents.
 */

/**
 * Snippet interface - Reusable copy element
 * 
 * Snippets are project-scoped, meaning each project has its own set of snippets.
 * They are stored within the project's data structure in localStorage.
 */
export interface Snippet {
  /** Unique identifier (UUID format) */
  id: string;
  
  /** Project ID this snippet belongs to */
  projectId: string;
  
  /** User-defined name/title for the snippet (e.g., "Hero CTA", "Email Sign-off") */
  name: string;
  
  /** The actual copy text content (can include HTML formatting) */
  content: string;
  
  /** Optional description/notes about when to use this snippet */
  description?: string;
  
  /** Optional tags for organization and filtering */
  tags?: string[];
  
  /** ISO date string when snippet was created */
  createdAt: string;
  
  /** ISO date string when snippet was last modified */
  modifiedAt: string;
  
  /** Number of times this snippet has been used/inserted */
  usageCount: number;
}

/**
 * Snippet creation input - Fields required to create a new snippet
 */
export interface CreateSnippetInput {
  /** User-defined name/title for the snippet */
  name: string;
  
  /** The actual copy text content */
  content: string;
  
  /** Optional description/notes */
  description?: string;
  
  /** Optional tags for organization */
  tags?: string[];
}

/**
 * Snippet update input - Fields that can be updated
 */
export interface UpdateSnippetInput {
  /** Updated name (optional) */
  name?: string;
  
  /** Updated content (optional) */
  content?: string;
  
  /** Updated description (optional) */
  description?: string;
  
  /** Updated tags (optional) */
  tags?: string[];
}

/**
 * Type guard to check if a value is a valid Snippet
 */
export function isSnippet(value: unknown): value is Snippet {
  if (!value || typeof value !== 'object') return false;
  
  const obj = value as Record<string, unknown>;
  
  return (
    typeof obj.id === 'string' &&
    typeof obj.projectId === 'string' &&
    typeof obj.name === 'string' &&
    typeof obj.content === 'string' &&
    typeof obj.createdAt === 'string' &&
    typeof obj.modifiedAt === 'string' &&
    typeof obj.usageCount === 'number'
  );
}

/**
 * Validate snippet name
 * @throws Error if name is invalid
 */
export function validateSnippetName(name: string): void {
  if (!name || name.trim().length === 0) {
    throw new Error('Snippet name cannot be empty');
  }
  
  if (name.trim().length > 100) {
    throw new Error('Snippet name cannot exceed 100 characters');
  }
}

/**
 * Validate snippet content
 * @throws Error if content is invalid
 */
export function validateSnippetContent(content: string): void {
  if (!content || content.trim().length === 0) {
    throw new Error('Snippet content cannot be empty');
  }
  
  if (content.length > 50000) {
    throw new Error('Snippet content is too long (max 50,000 characters)');
  }
}


=== FILE: lib/types/template-progress.ts ===

/**
 * @file lib/types/template-progress.ts
 * @description TypeScript type definitions for multi-section template progress tracking
 * 
 * Used to persist progress across sessions for complex templates like
 * multi-section brochures that generate content section by section.
 */

/**
 * Section status for tracking completion
 */
export type SectionStatus = 'pending' | 'in_progress' | 'completed' | 'skipped' | 'modified';

/**
 * Individual section definition within a multi-section template
 */
export interface TemplateSection {
  /** Unique section identifier (e.g., 'cover', 'hero', 'solutions') */
  id: string;
  
  /** Display name (e.g., 'Cover/Title', 'Hero/Introduction/Benefits') */
  name: string;
  
  /** Form fields specific to this section */
  fields: TemplateSectionField[];
  
  /** Optional description shown to user */
  description?: string;
}

/**
 * Field definition for section forms
 * Extends the base template field with section-specific options
 */
export interface TemplateSectionField {
  /** Unique field identifier within the section */
  id: string;
  
  /** Human-readable label */
  label: string;
  
  /** Field input type */
  type: 'text' | 'textarea' | 'select' | 'number';
  
  /** Placeholder text for input */
  placeholder?: string;
  
  /** Helper text shown below field */
  helperText?: string;
  
  /** Whether field is required */
  required: boolean;
  
  /** Maximum character length (for text/textarea) */
  maxLength?: number;
  
  /** Options for select fields */
  options?: string[];
  
  /** Conditional visibility based on another field's value */
  conditionalOn?: {
    fieldId: string;
    value: string | string[];
  };
}

/**
 * Completed section with stored data and generated content
 */
export interface CompletedSection {
  /** Section ID */
  sectionId: string;
  
  /** Form data submitted for this section */
  formData: Record<string, string>;
  
  /** Generated content for this section */
  generatedContent: string;
  
  /** Timestamp when section was completed */
  completedAt: string;
  
  /** Whether user manually edited the generated content */
  wasModified: boolean;
  
  /** Content hash to detect manual edits */
  contentHash?: string;
}

/**
 * Template progress state stored in document
 * Tracks multi-section template generation progress
 */
export interface TemplateProgress {
  /** Template identifier (e.g., 'brochure-multi-section') */
  templateId: string;
  
  /** Current section index (0-based) */
  currentSection: number;
  
  /** Total number of sections */
  totalSections: number;
  
  /** Array of completed section IDs (in order of completion) */
  completedSections: string[];
  
  /** Detailed data for each completed section */
  sectionData: Record<string, CompletedSection>;
  
  /** Whether the entire template is complete */
  isComplete: boolean;
  
  /** Timestamp when template was started */
  startedAt: string;
  
  /** Timestamp when template was completed (if isComplete) */
  completedAt?: string;
  
  /** Brand voice enabled for this template session */
  applyBrandVoice?: boolean;
  
  /** Selected persona ID for this template session */
  selectedPersonaId?: string;
}

/**
 * Multi-section template definition
 * Extended template type for sequential section generation
 */
export interface MultiSectionTemplate {
  /** Unique template identifier */
  id: string;
  
  /** Template display name */
  name: string;
  
  /** Category (should be 'advanced') */
  category: 'advanced';
  
  /** Template description */
  description: string;
  
  /** Difficulty level */
  complexity: 'Advanced';
  
  /** Estimated time (e.g., '30-45 min') */
  estimatedTime: string;
  
  /** Lucide-react icon name */
  icon: string;
  
  /** Array of sections in order */
  sections: TemplateSection[];
  
  /** Separator to use between sections in final document */
  sectionSeparator: string;
  
  /** System prompt prefix used for all sections */
  systemPromptPrefix: string;
}

/**
 * Section generation request sent to API
 */
export interface SectionGenerationRequest {
  /** Template ID */
  templateId: string;
  
  /** Section ID being generated */
  sectionId: string;
  
  /** Section index (0-based) */
  sectionIndex: number;
  
  /** Form data for this section */
  formData: Record<string, string>;
  
  /** Previous document content for context */
  previousContent?: string;
  
  /** Apply brand voice */
  applyBrandVoice?: boolean;
  
  /** Brand voice data if applying */
  brandVoice?: {
    brandName: string;
    brandTone: string;
    approvedPhrases: string[];
    forbiddenWords: string[];
    brandValues: string[];
    missionStatement: string;
  };
  
  /** Persona data if selected */
  persona?: {
    name: string;
    demographics: string;
    psychographics: string;
    painPoints: string;
    languagePatterns: string;
    goals: string;
  };
}

/**
 * Section generation response from API
 */
export interface SectionGenerationResponse {
  /** Generated section content */
  generatedContent: string;
  
  /** Section ID */
  sectionId: string;
  
  /** Metadata about generation */
  metadata?: {
    textLength: number;
    sectionName: string;
    brandVoiceApplied: boolean;
    personaUsed: boolean;
  };
}

/**
 * Type guard to check if templateProgress is valid
 */
export function isValidTemplateProgress(value: unknown): value is TemplateProgress {
  if (!value || typeof value !== 'object') return false;
  
  const obj = value as Record<string, unknown>;
  
  return (
    typeof obj.templateId === 'string' &&
    typeof obj.currentSection === 'number' &&
    typeof obj.totalSections === 'number' &&
    Array.isArray(obj.completedSections) &&
    typeof obj.sectionData === 'object' &&
    typeof obj.isComplete === 'boolean' &&
    typeof obj.startedAt === 'string'
  );
}

/**
 * Create initial template progress state
 */
export function createInitialProgress(
  templateId: string,
  totalSections: number,
  applyBrandVoice?: boolean,
  selectedPersonaId?: string
): TemplateProgress {
  return {
    templateId,
    currentSection: 0,
    totalSections,
    completedSections: [],
    sectionData: {},
    isComplete: false,
    startedAt: new Date().toISOString(),
    applyBrandVoice,
    selectedPersonaId,
  };
}

/**
 * Generate a simple hash of content for modification detection
 */
export function generateContentHash(content: string): string {
  let hash = 0;
  for (let i = 0; i < content.length; i++) {
    const char = content.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }
  return hash.toString(36);
}


=== FILE: lib/types/template.ts ===

/**
 * @file lib/types/template.ts
 * @description TypeScript types for template generation system
 * 
 * Templates provide structured forms for generating specific types of copy
 * like sales emails, landing pages, social media posts, etc.
 */

import type { BrandVoice } from './brand';
import type { Persona } from './project';

/**
 * Template category types
 */
export type TemplateCategory =
  | 'email'
  | 'advertising'
  | 'landing-page'
  | 'social'
  | 'collateral'
  | 'website'
  | 'blog'
  | 'other';

/**
 * Field types for template forms
 */
export type FieldType = 'text' | 'textarea' | 'select' | 'number';

/**
 * Template field definition
 * Describes a single form field in a template
 */
export interface TemplateField {
  /** Unique field identifier */
  id: string;
  
  /** Human-readable label */
  label: string;
  
  /** Field input type */
  type: FieldType;
  
  /** Placeholder text for input */
  placeholder?: string;
  
  /** Helper text shown below field */
  helperText?: string;
  
  /** Whether field is required */
  required: boolean;
  
  /** Maximum character length (for text/textarea) */
  maxLength?: number;
  
  /** Options for select fields */
  options?: string[];
}

/**
 * Template definition
 * Complete specification for a copywriting template
 */
export interface Template {
  /** Unique template identifier */
  id: string;
  
  /** Template name displayed to user */
  name: string;
  
  /** Category this template belongs to */
  category: TemplateCategory;
  
  /** Short description of what this template creates */
  description: string;
  
  /** Difficulty level for user guidance */
  complexity: 'Beginner' | 'Intermediate' | 'Advanced';
  
  /** Estimated time to complete (e.g., "15-20 min") */
  estimatedTime: string;
  
  /** Lucide-react icon name */
  icon: string;
  
  /** Form fields for this template */
  fields: TemplateField[];
  
  /** 
   * Claude system prompt template with placeholders
   * Placeholders use {fieldId} format and special ones:
   * - {brandVoiceInstructions} - Auto-injected if brand voice enabled
   * - {personaInstructions} - Auto-injected if persona selected
   */
  systemPrompt: string;
}

/**
 * Form data collected from user
 * Maps field IDs to their values
 */
export interface TemplateFormData {
  [fieldId: string]: string;
}

/**
 * Template generation request
 */
export interface TemplateGenerationRequest {
  /** Template ID being used */
  templateId: string;
  
  /** Form data from user */
  formData: TemplateFormData;
  
  /** Whether to apply brand voice */
  applyBrandVoice?: boolean;
  
  /** Brand voice configuration if applying */
  brandVoice?: BrandVoice;
  
  /** Persona ID if selected */
  personaId?: string;
  
  /** Persona data if selected */
  persona?: Persona;
}

/**
 * Template generation response
 */
export interface TemplateGenerationResponse {
  /** Generated copy */
  generatedCopy: string;
  
  /** Original prompt sent to Claude */
  prompt?: string;
  
  /** Metadata about generation */
  metadata?: {
    textLength: number;
    templateUsed: string;
    brandVoiceApplied: boolean;
    personaUsed: boolean;
  };
}


=== FILE: lib/types/workspace.ts ===

/**
 * @file lib/types/workspace.ts
 * @description Workspace-specific type definitions for Zustand store
 * 
 * Defines the shape of the workspace state and all available actions
 */

import { Document, ToolCategory, AIAnalysisMode } from './index';

/**
 * Workspace state shape
 * Used by Zustand store to manage application state
 */
export interface WorkspaceState {
  // Sidebar visibility
  /** Controls left sidebar visibility */
  leftSidebarOpen: boolean;
  
  /** Controls right sidebar visibility */
  rightSidebarOpen: boolean;
  
  // Document state
  /** Currently active document in the editor */
  activeDocument: Document | null;
  
  /** List of all documents in workspace */
  documents: Document[];
  
  // Tool state
  /** Currently selected tool in left sidebar */
  activeTool: ToolCategory | null;
  
  /** Current AI analysis mode in right sidebar */
  aiAnalysisMode: AIAnalysisMode;
  
  // Actions
  /** Toggle left sidebar visibility */
  toggleLeftSidebar: () => void;
  
  /** Toggle right sidebar visibility */
  toggleRightSidebar: () => void;
  
  /** Set left sidebar visibility explicitly */
  setLeftSidebarOpen: (open: boolean) => void;
  
  /** Set right sidebar visibility explicitly */
  setRightSidebarOpen: (open: boolean) => void;
  
  /** Create a new document */
  createDocument: (title?: string) => void;
  
  /** Set active document by ID */
  setActiveDocument: (documentId: string | null) => void;
  
  /** Update document content */
  updateDocument: (documentId: string, content: Partial<Document>) => void;
  
  /** Delete document by ID */
  deleteDocument: (documentId: string) => void;
  
  /** Set active tool */
  setActiveTool: (tool: ToolCategory | null) => void;
  
  /** Set AI analysis mode */
  setAIAnalysisMode: (mode: AIAnalysisMode) => void;
  
  /** Load document from external source */
  loadDocument: (document: Document) => void;
  
  /** Reset workspace to initial state */
  resetWorkspace: () => void;
}





=== FILE: lib/utils.ts ===

/**
 * @file lib/utils.ts
 * @description Utility functions for the CopyWorx application
 * 
 * Contains helper functions for:
 * - Class name merging (clsx + tailwind-merge)
 * - Common utilities used across components
 */

import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

/**
 * Merges class names using clsx and tailwind-merge
 * Handles conditional classes and resolves Tailwind conflicts
 * 
 * @param inputs - Class values to merge (strings, objects, arrays)
 * @returns Merged class string with resolved Tailwind conflicts
 * 
 * @example
 * cn('px-4 py-2', { 'bg-blue-500': true }, 'hover:bg-blue-600')
 * // Returns: 'px-4 py-2 bg-blue-500 hover:bg-blue-600'
 */
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}

/**
 * Formats a number as currency
 * 
 * @param amount - The amount to format
 * @param currency - Currency code (default: 'USD')
 * @returns Formatted currency string
 */
export function formatCurrency(amount: number, currency: string = 'USD'): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
  }).format(amount);
}

/**
 * Truncates a string to a specified length
 * 
 * @param str - String to truncate
 * @param length - Maximum length
 * @returns Truncated string with ellipsis if needed
 */
export function truncate(str: string, length: number): string {
  if (str.length <= length) {
    return str;
  }
  return `${str.slice(0, length)}...`;
}

/**
 * Capitalizes the first letter of a string
 * 
 * @param str - String to capitalize
 * @returns Capitalized string
 */
export function capitalize(str: string): string {
  if (!str || str.length === 0) {
    return str;
  }
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Generates a random ID
 * 
 * @returns Random string ID
 */
export function generateId(): string {
  return Math.random().toString(36).substring(2, 9);
}

/**
 * Delays execution for specified milliseconds
 * 
 * @param ms - Milliseconds to wait
 * @returns Promise that resolves after delay
 */
export function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Safely parses JSON with a fallback
 * 
 * @param json - JSON string to parse
 * @param fallback - Fallback value if parsing fails
 * @returns Parsed object or fallback
 */
export function safeJsonParse<T>(json: string, fallback: T): T {
  try {
    return JSON.parse(json) as T;
  } catch {
    return fallback;
  }
}



=== FILE: lib/utils/api-auth.ts ===

/**
 * @file lib/utils/api-auth.ts
 * @description Authentication and usage limit utilities for API routes
 * 
 * Provides helper functions to:
 * - Get authenticated user ID from Clerk
 * - Check if user is within API usage limits
 * - Create standardized error responses
 */

import { auth } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';
import { supabaseAdmin, isSupabaseConfigured } from '@/lib/supabase';
import { logger } from '@/lib/utils/logger';

/**
 * Error response for unauthorized requests
 */
export interface UnauthorizedResponse {
  error: string;
  details: string;
}

/**
 * Get the authenticated user ID from Clerk
 * Returns null if no user is authenticated
 */
export async function getUserId(): Promise<string | null> {
  const { userId } = await auth();
  return userId;
}

/**
 * Get the authenticated user ID or throw an error
 * Use this when authentication is required
 */
export async function requireUserId(): Promise<string> {
  const userId = await getUserId();
  
  if (!userId) {
    throw new Error('UNAUTHORIZED');
  }
  
  return userId;
}

/**
 * Create an unauthorized response
 */
export function unauthorizedResponse(): NextResponse<UnauthorizedResponse> {
  return NextResponse.json(
    { 
      error: 'Unauthorized',
      details: 'You must be logged in to access this resource'
    },
    { status: 401 }
  );
}

/**
 * Create a not found response
 */
export function notFoundResponse(resource: string): NextResponse {
  return NextResponse.json(
    { 
      error: 'Not found',
      details: `${resource} not found`
    },
    { status: 404 }
  );
}

/**
 * Create a bad request response
 */
export function badRequestResponse(message: string): NextResponse {
  return NextResponse.json(
    { 
      error: 'Bad request',
      details: message
    },
    { status: 400 }
  );
}

/**
 * Create an internal error response
 */
export function internalErrorResponse(error: unknown): NextResponse {
  console.error('API Error:', error);
  
  return NextResponse.json(
    { 
      error: 'Internal server error',
      details: error instanceof Error ? error.message : 'An unexpected error occurred'
    },
    { status: 500 }
  );
}

// ============================================================================
// Usage Limit Checking
// ============================================================================

/** Beta usage limit in USD */
const BETA_LIMIT_USD = 5.00;

/**
 * Result of usage limit check
 */
export interface UsageLimitResult {
  /** Whether user is within the usage limit */
  withinLimit: boolean;
  /** Total cost spent by user in USD */
  totalCost: number;
  /** Remaining budget in USD */
  remainingBudget: number;
  /** The limit amount in USD */
  limit: number;
}

/**
 * Response structure for usage limit exceeded error
 */
export interface UsageLimitExceededResponse {
  error: string;
  details: string;
  usage: {
    totalCost: number;
    limit: number;
    percentUsed: number;
  };
}

/**
 * Check if a user is within their API usage limit
 * 
 * Queries the api_usage_logs table to sum up the user's total cost
 * and compares against the beta limit ($5.00).
 * 
 * @param userId - Clerk user ID to check
 * @returns UsageLimitResult with limit status and usage details
 * 
 * @example
 * ```ts
 * const result = await checkUserWithinLimit(userId);
 * if (!result.withinLimit) {
 *   return usageLimitExceededResponse(result.totalCost);
 * }
 * ```
 */
export async function checkUserWithinLimit(userId: string): Promise<UsageLimitResult> {
  // Default to within limit if Supabase is not configured
  // This allows development without Supabase setup
  if (!isSupabaseConfigured() || !supabaseAdmin) {
    logger.log('‚ö†Ô∏è Supabase not configured, skipping usage limit check');
    return {
      withinLimit: true,
      totalCost: 0,
      remainingBudget: BETA_LIMIT_USD,
      limit: BETA_LIMIT_USD,
    };
  }

  try {
    // Query the user_usage_summary view for aggregated usage
    const { data, error } = await (supabaseAdmin
      .from('user_usage_summary') as any)
      .select('total_cost_usd')
      .eq('user_id', userId)
      .single();

    // Handle case where user has no usage records yet
    if (error && error.code === 'PGRST116') {
      // No rows found - user hasn't used the API yet
      logger.log('üìä No usage records found for user, within limit');
      return {
        withinLimit: true,
        totalCost: 0,
        remainingBudget: BETA_LIMIT_USD,
        limit: BETA_LIMIT_USD,
      };
    }

    if (error) {
      // Log error but default to allowing the request
      // We don't want to block users due to database errors
      logger.error('‚ùå Error checking usage limit:', error);
      return {
        withinLimit: true,
        totalCost: 0,
        remainingBudget: BETA_LIMIT_USD,
        limit: BETA_LIMIT_USD,
      };
    }

    const totalCost = data?.total_cost_usd || 0;
    const withinLimit = totalCost < BETA_LIMIT_USD;
    const remainingBudget = Math.max(0, BETA_LIMIT_USD - totalCost);

    logger.log('üìä Usage limit check:', {
      userId: userId.substring(0, 8) + '...',
      totalCost: `$${totalCost.toFixed(4)}`,
      withinLimit,
      remainingBudget: `$${remainingBudget.toFixed(4)}`,
    });

    return {
      withinLimit,
      totalCost,
      remainingBudget,
      limit: BETA_LIMIT_USD,
    };
  } catch (err) {
    // Log error but default to allowing the request
    logger.error('‚ùå Exception checking usage limit:', err);
    return {
      withinLimit: true,
      totalCost: 0,
      remainingBudget: BETA_LIMIT_USD,
      limit: BETA_LIMIT_USD,
    };
  }
}

/**
 * Create a 403 response for when user exceeds usage limit
 * 
 * @param totalCost - User's current total cost
 * @returns NextResponse with 403 status and usage details
 */
export function usageLimitExceededResponse(totalCost: number): NextResponse<UsageLimitExceededResponse> {
  const percentUsed = Math.round((totalCost / BETA_LIMIT_USD) * 100);
  
  return NextResponse.json<UsageLimitExceededResponse>(
    {
      error: 'Usage limit exceeded',
      details: `API usage limit reached ($${BETA_LIMIT_USD.toFixed(2)}). Please contact support to continue.`,
      usage: {
        totalCost: Math.round(totalCost * 100) / 100, // Round to 2 decimals
        limit: BETA_LIMIT_USD,
        percentUsed,
      },
    },
    { status: 403 }
  );
}


=== FILE: lib/utils/content-formatting.ts ===

/**
 * @file lib/utils/content-formatting.ts
 * @description Utilities for sanitizing and processing HTML output from Claude API
 * 
 * Claude now outputs HTML directly, so we just need to:
 * - Sanitize for security (remove scripts, event handlers)
 * - Validate structure
 * - Handle edge cases
 */

import { logger } from './logger';

/**
 * Sanitize HTML from Claude
 * Removes potentially dangerous content while preserving formatting
 * 
 * @param html - Raw HTML from Claude
 * @returns Sanitized HTML safe for TipTap editor
 */
export function sanitizeGeneratedHTML(html: string): string {
  if (!html || typeof html !== 'string') {
    logger.warn('‚ö†Ô∏è sanitizeGeneratedHTML received invalid input:', html);
    return '<p>Error: No content generated</p>';
  }
  
  // Remove script tags and dangerous content
  let cleaned = html
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/on\w+="[^"]*"/gi, '') // Remove inline event handlers like onclick
    .replace(/on\w+='[^']*'/gi, '')
    .replace(/javascript:/gi, '')
    .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '');
  
  // REMOVE EXCESSIVE WHITESPACE BETWEEN TAGS
  // This prevents double or triple spacing between paragraphs
  cleaned = cleaned.replace(/>\s+</g, '><');
  
  // Trim overall whitespace
  cleaned = cleaned.trim();
  
  // If content doesn't start with HTML tag, wrap it
  if (cleaned && !cleaned.startsWith('<')) {
    cleaned = `<p>${cleaned}</p>`;
  }
  
  // Validate it's not empty after sanitization
  if (!cleaned || cleaned.trim().length === 0) {
    logger.error('‚ùå Content was empty after sanitization');
    return '<p>Error: Generated content was empty</p>';
  }
  
  logger.log('‚úÖ HTML sanitized:', {
    originalLength: html.length,
    cleanedLength: cleaned.length,
    hasParagraphs: cleaned.includes('<p>'),
    hasHeadings: cleaned.includes('<h'),
    hasLists: cleaned.includes('<ul>'),
    hasBold: cleaned.includes('<strong>'),
  });
  
  return cleaned;
}

/**
 * Process HTML for email templates
 * Ensures Subject: line is properly formatted as heading
 * 
 * @param html - HTML from Claude (email template)
 * @returns Processed HTML with Subject line as heading
 */
export function processEmailHTML(html: string): string {
  if (!html || typeof html !== 'string') {
    logger.warn('‚ö†Ô∏è processEmailHTML received invalid input:', html);
    return '<p>Error: No content generated</p>';
  }
  
  let processed = html;
  
  // Check if Subject: line exists as plain text (not already wrapped in heading)
  const subjectMatch = processed.match(/^Subject:\s*(.+?)(?:<|$)/m);
  
  if (subjectMatch && !processed.includes('<h3>Subject:')) {
    const subject = subjectMatch[1].trim();
    processed = processed.replace(
      /^Subject:\s*.+?$/m,
      `<h3>Subject: ${subject}</h3>`
    );
    logger.log('üìß Email subject converted to heading:', subject.substring(0, 50));
  }
  
  return sanitizeGeneratedHTML(processed);
}

/**
 * Process HTML for email sequence templates
 * Ensures proper formatting and visual separation between multiple emails
 * 
 * @param html - HTML from Claude (email sequence)
 * @returns Processed HTML with proper email separators and styling
 */
export function processEmailSequenceHTML(html: string): string {
  if (!html || typeof html !== 'string') {
    logger.warn('‚ö†Ô∏è processEmailSequenceHTML received invalid input:', html);
    return '<p>Error: No content generated</p>';
  }
  
  let processed = html;
  
  // Count emails in the sequence for logging
  const emailCount = (processed.match(/‚ïê‚ïê‚ïê\s*EMAIL\s*\d+/gi) || []).length;
  logger.log(`üìß Processing email sequence with ${emailCount} emails`);
  
  // Ensure horizontal rules are properly formatted for TipTap
  // TipTap uses <hr> tags which render as horizontal dividers
  processed = processed.replace(/<hr\s*\/?>/gi, '<hr>');
  
  // Add visual spacing around email headers if they exist as plain text
  // Pattern: === EMAIL X of Y: TITLE ===
  processed = processed.replace(
    /‚ïê{3,}\s*(EMAIL\s*\d+[^‚ïê]*?)‚ïê{3,}/gi,
    (match, content) => {
      // Keep it as-is if already in h2 tags, otherwise the h2 should handle it
      return match;
    }
  );
  
  // Ensure all Subject: lines are h3 headings
  processed = processed.replace(
    /<p>\s*Subject:\s*([^<]+)<\/p>/gi,
    '<h3>Subject: $1</h3>'
  );
  
  // Also handle Subject: that may be wrapped directly (not in p tags)
  processed = processed.replace(
    /(?<![<h3>])Subject:\s*([^\n<]+)(?=\n|<)/gi,
    (match, subject) => {
      // Only replace if not already in an h3
      if (!match.includes('<h3>')) {
        return `<h3>Subject: ${subject.trim()}</h3>`;
      }
      return match;
    }
  );
  
  return sanitizeGeneratedHTML(processed);
}

/**
 * Check if content appears to be an email sequence (multiple emails)
 * 
 * @param html - HTML content to check
 * @returns True if content contains multiple email markers
 */
export function isEmailSequence(html: string): boolean {
  if (!html) return false;
  
  // Check for email sequence markers (EMAIL 1, EMAIL 2, etc.)
  const emailMarkers = html.match(/EMAIL\s*\d+/gi);
  return emailMarkers !== null && emailMarkers.length > 1;
}

/**
 * Main entry point for formatting generated content
 * Routes to appropriate processor based on content type
 * 
 * @param html - HTML from Claude API
 * @param isEmail - Whether this is email content (single email)
 * @returns Sanitized and processed HTML
 */
export function formatGeneratedContent(html: string, isEmail: boolean = false): string {
  try {
    let processed: string;
    
    // Auto-detect email sequences (multiple emails in one generation)
    if (isEmailSequence(html)) {
      logger.log('üìß Detected email sequence, using sequence processor');
      processed = processEmailSequenceHTML(html);
    } else if (isEmail) {
      processed = processEmailHTML(html);
    } else {
      processed = sanitizeGeneratedHTML(html);
    }
    
    // Validate result
    if (!processed || processed.trim().length === 0) {
      throw new Error('Empty content after processing');
    }
    
    return processed;
    
  } catch (error) {
    logger.error('‚ùå Error processing generated content:', error);
    
    // Fallback: Basic paragraph wrapping
    const fallback = html
      .split(/\n\n+/)
      .map(para => para.trim())
      .filter(Boolean)
      .map(para => `<p>${para.replace(/\n/g, '<br>')}</p>`)
      .join('');
    
    return fallback || '<p>Error: Unable to process generated content</p>';
  }
}

/**
 * Strip HTML tags for plain text display
 * Useful for previews or character counting
 * 
 * @param html - HTML string
 * @returns Plain text without HTML tags
 */
export function stripHtml(html: string): string {
  return html.replace(/<[^>]*>/g, '');
}

/**
 * Count words in text (strips HTML first)
 * 
 * @param text - Text or HTML to count
 * @returns Word count
 */
export function countWords(text: string): number {
  const plain = stripHtml(text);
  return plain.trim().split(/\s+/).filter(Boolean).length;
}


=== FILE: lib/utils/daily-visit-tracker.ts ===

/**
 * @file lib/utils/daily-visit-tracker.ts
 * @description Utility for tracking first visit of the day and managing splash page redirects
 * 
 * Features:
 * - Tracks last visit date in localStorage
 * - Determines if current visit is first of the day
 * - Updates visit date when user interacts with splash page
 * - Prevents redirect loops by using session-based tracking
 * 
 * @example
 * ```ts
 * // Check if should redirect to splash
 * if (shouldRedirectToSplash()) {
 *   router.push('/home');
 * }
 * 
 * // After user clicks splash button, mark as visited
 * markDailyVisitComplete();
 * ```
 */

const LAST_VISIT_DATE_KEY = 'copyworx_last_visit_date';
const SPLASH_VIEWED_SESSION_KEY = 'copyworx_splash_viewed_session';

/**
 * Get today's date in YYYY-MM-DD format for consistent comparison
 */
function getTodayDateString(): string {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

/**
 * Check if the user should be redirected to the splash page
 * 
 * Returns true if:
 * - No last visit date exists (first time ever), OR
 * - Last visit date is not today, AND
 * - Splash has not been viewed in this session (prevents redirect loops)
 * 
 * @returns {boolean} True if user should see splash page
 */
export function shouldRedirectToSplash(): boolean {
  // Check if we're in a browser environment
  if (typeof window === 'undefined') {
    return false;
  }

  try {
    // Check if splash was already viewed in this session (prevents redirect loops)
    const splashViewedThisSession = sessionStorage.getItem(SPLASH_VIEWED_SESSION_KEY);
    if (splashViewedThisSession === 'true') {
      return false;
    }

    // Get last visit date from localStorage
    const lastVisitDate = localStorage.getItem(LAST_VISIT_DATE_KEY);
    const todayDate = getTodayDateString();

    // If no last visit date, or if last visit was not today, redirect to splash
    if (!lastVisitDate || lastVisitDate !== todayDate) {
      return true;
    }

    return false;
  } catch (error) {
    // If localStorage/sessionStorage is not available, don't redirect
    console.error('Error checking daily visit:', error);
    return false;
  }
}

/**
 * Mark that the user has completed their daily visit to the splash page
 * 
 * Call this when:
 * - User clicks any button on the splash page
 * - User navigates away from splash page
 * 
 * Updates both localStorage (persistent) and sessionStorage (prevents loops)
 */
export function markDailyVisitComplete(): void {
  // Check if we're in a browser environment
  if (typeof window === 'undefined') {
    return;
  }

  try {
    const todayDate = getTodayDateString();
    
    // Update last visit date in localStorage (persists across sessions)
    localStorage.setItem(LAST_VISIT_DATE_KEY, todayDate);
    
    // Mark splash as viewed in this session (prevents redirect loops)
    sessionStorage.setItem(SPLASH_VIEWED_SESSION_KEY, 'true');
    
    console.log('‚úÖ Daily visit marked complete:', todayDate);
  } catch (error) {
    console.error('Error marking daily visit complete:', error);
  }
}

/**
 * Mark that the user has viewed the splash page (without navigation)
 * This sets the session flag to prevent redirect loops while on /home
 */
export function markSplashViewed(): void {
  // Check if we're in a browser environment
  if (typeof window === 'undefined') {
    return;
  }

  try {
    // Mark splash as viewed in this session (prevents redirect loops)
    sessionStorage.setItem(SPLASH_VIEWED_SESSION_KEY, 'true');
    console.log('‚úÖ Splash page viewed (session marked)');
  } catch (error) {
    console.error('Error marking splash viewed:', error);
  }
}

/**
 * Get the last visit date for debugging/testing purposes
 * 
 * @returns {string | null} Last visit date in YYYY-MM-DD format, or null if never visited
 */
export function getLastVisitDate(): string | null {
  if (typeof window === 'undefined') {
    return null;
  }

  try {
    return localStorage.getItem(LAST_VISIT_DATE_KEY);
  } catch (error) {
    console.error('Error getting last visit date:', error);
    return null;
  }
}

/**
 * Clear visit tracking (useful for testing)
 * 
 * @example
 * ```ts
 * // Simulate "next day" by clearing the date
 * clearVisitTracking();
 * ```
 */
export function clearVisitTracking(): void {
  if (typeof window === 'undefined') {
    return;
  }

  try {
    localStorage.removeItem(LAST_VISIT_DATE_KEY);
    sessionStorage.removeItem(SPLASH_VIEWED_SESSION_KEY);
    console.log('üßπ Visit tracking cleared');
  } catch (error) {
    console.error('Error clearing visit tracking:', error);
  }
}

/**
 * Set a custom visit date (useful for testing "next day" scenarios)
 * 
 * @param {string} dateString - Date in YYYY-MM-DD format
 * 
 * @example
 * ```ts
 * // Simulate yesterday's visit
 * const yesterday = new Date();
 * yesterday.setDate(yesterday.getDate() - 1);
 * const dateStr = yesterday.toISOString().split('T')[0];
 * setCustomVisitDate(dateStr);
 * ```
 */
export function setCustomVisitDate(dateString: string): void {
  if (typeof window === 'undefined') {
    return;
  }

  try {
    localStorage.setItem(LAST_VISIT_DATE_KEY, dateString);
    // Clear session flag so redirect can happen
    sessionStorage.removeItem(SPLASH_VIEWED_SESSION_KEY);
    console.log('üîß Custom visit date set:', dateString);
  } catch (error) {
    console.error('Error setting custom visit date:', error);
  }
}


=== FILE: lib/utils/document-export.ts ===

/**
 * @file lib/utils/document-export.ts
 * @description Document export utilities for Plain Text, Markdown, and Word Document formats
 * 
 * Features:
 * - Export TipTap editor content to .txt (plain text)
 * - Export TipTap editor content to .md (Markdown)
 * - Export TipTap editor content to .docx (Word Document)
 * - Sanitized filenames with special character handling
 * - Browser download trigger functionality
 * 
 * Dependencies:
 * - turndown: HTML to Markdown conversion
 * - docshift: HTML to DOCX conversion (client-side)
 */

'use client';

import type { Editor } from '@tiptap/react';
import TurndownService from 'turndown';
import { logger } from './logger';

// ============================================================================
// Types
// ============================================================================

/**
 * Export format types supported by the application
 */
export type ExportFormat = 'txt' | 'md' | 'docx';

/**
 * Export result containing success status and optional error message
 */
export interface ExportResult {
  success: boolean;
  error?: string;
  filename?: string;
}

/**
 * Export options for customizing export behavior
 */
export interface ExportOptions {
  /** Custom filename (without extension) */
  filename?: string;
  /** Fallback filename if none provided */
  fallbackFilename?: string;
}

// ============================================================================
// Filename Utilities
// ============================================================================

/**
 * Sanitize a filename by removing or replacing invalid characters
 * 
 * Handles:
 * - Control characters
 * - File system reserved characters (/ \ : * ? " < > |)
 * - Leading/trailing whitespace and dots
 * - Empty strings (returns fallback)
 * 
 * @param filename - Raw filename string
 * @param fallback - Fallback name if sanitization results in empty string
 * @returns Sanitized filename safe for most file systems
 */
export function sanitizeFilename(
  filename: string,
  fallback: string = 'Untitled Document'
): string {
  if (!filename || typeof filename !== 'string') {
    return fallback;
  }

  // Remove control characters and file system reserved characters
  let sanitized = filename
    .replace(/[\x00-\x1f\x80-\x9f]/g, '') // Control characters
    .replace(/[/\\:*?"<>|]/g, '-')        // File system reserved
    .replace(/\s+/g, ' ')                  // Multiple spaces to single
    .trim();

  // Remove leading/trailing dots (invalid on Windows)
  sanitized = sanitized.replace(/^\.+|\.+$/g, '');

  // Limit length (most file systems have 255 char limit)
  if (sanitized.length > 200) {
    sanitized = sanitized.substring(0, 200).trim();
  }

  // Return fallback if empty after sanitization
  return sanitized || fallback;
}

/**
 * Generate a timestamped filename for exports
 * 
 * @param baseName - Base name for the file
 * @param extension - File extension (without dot)
 * @returns Formatted filename with timestamp
 */
export function generateExportFilename(
  baseName: string,
  extension: ExportFormat
): string {
  const sanitized = sanitizeFilename(baseName);
  return `${sanitized}.${extension}`;
}

// ============================================================================
// Browser Download Utilities
// ============================================================================

/**
 * Trigger a browser download for a Blob
 * 
 * @param blob - File content as Blob
 * @param filename - Filename for download
 */
export function downloadBlob(blob: Blob, filename: string): void {
  // Create object URL for the blob
  const url = URL.createObjectURL(blob);

  // Create temporary anchor element
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;

  // Append to body, click, and cleanup
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);

  // Revoke object URL to free memory
  setTimeout(() => {
    URL.revokeObjectURL(url);
  }, 100);
}

/**
 * Download text content as a file
 * 
 * @param content - Text content to download
 * @param filename - Filename for download
 * @param mimeType - MIME type for the file (default: text/plain)
 */
export function downloadTextFile(
  content: string,
  filename: string,
  mimeType: string = 'text/plain'
): void {
  const blob = new Blob([content], { type: `${mimeType};charset=utf-8` });
  downloadBlob(blob, filename);
}

// ============================================================================
// Content Extraction
// ============================================================================

/**
 * Get plain text content from TipTap editor
 * Preserves paragraph structure with double line breaks
 * 
 * @param editor - TipTap editor instance
 * @returns Plain text content with preserved paragraph structure
 */
export function getPlainTextFromEditor(editor: Editor): string {
  if (!editor) {
    return '';
  }

  // TipTap's getText method with block separator
  // This preserves paragraph breaks as double newlines
  const text = editor.getText({ blockSeparator: '\n\n' });
  
  // Clean up excessive whitespace while preserving paragraph breaks
  return text
    .split('\n\n')
    .map(paragraph => paragraph.trim())
    .filter(paragraph => paragraph.length > 0)
    .join('\n\n');
}

/**
 * Get HTML content from TipTap editor
 * 
 * @param editor - TipTap editor instance
 * @returns HTML content string
 */
export function getHTMLFromEditor(editor: Editor): string {
  if (!editor) {
    return '';
  }

  return editor.getHTML();
}

/**
 * Check if editor has meaningful content (not just empty paragraphs)
 * 
 * @param editor - TipTap editor instance
 * @returns True if editor has content
 */
export function hasEditorContent(editor: Editor): boolean {
  if (!editor) {
    return false;
  }

  const text = editor.getText().trim();
  return text.length > 0;
}

// ============================================================================
// Markdown Conversion
// ============================================================================

/**
 * Configure Turndown service with appropriate options for TipTap HTML
 */
function createTurndownService(): TurndownService {
  const turndownService = new TurndownService({
    headingStyle: 'atx',           // Use # for headings
    bulletListMarker: '-',          // Use - for bullet lists
    codeBlockStyle: 'fenced',       // Use ``` for code blocks
    emDelimiter: '*',               // Use * for italics
    strongDelimiter: '**',          // Use ** for bold
    linkStyle: 'inlined',           // Use inline links [text](url)
    hr: '---',                      // Use --- for horizontal rules
  });

  // Add rule for underline (TipTap uses <u> tag)
  // Markdown doesn't have native underline, use emphasis as fallback
  turndownService.addRule('underline', {
    filter: ['u'],
    replacement: function(content) {
      return `_${content}_`;
    }
  });

  // Add rule for text alignment (preserve as comment)
  turndownService.addRule('textAlign', {
    filter: function(node) {
      const style = node.getAttribute && node.getAttribute('style');
      return !!style && style.includes('text-align');
    },
    replacement: function(content, node) {
      // Just return content without alignment (Markdown doesn't support alignment)
      return content;
    }
  });

  // Add rule for highlight/mark
  turndownService.addRule('highlight', {
    filter: ['mark'],
    replacement: function(content) {
      return `==${content}==`;
    }
  });

  // Add rule for strikethrough
  turndownService.addRule('strikethrough', {
    filter: ['s', 'del'],
    replacement: function(content) {
      return `~~${content}~~`;
    }
  });

  return turndownService;
}

/**
 * Convert HTML content to Markdown format
 * 
 * Preserves:
 * - Headings (#, ##, ###)
 * - Bold (**text**)
 * - Italic (*text*)
 * - Strikethrough (~~text~~)
 * - Links [text](url)
 * - Lists (bullet and numbered)
 * - Code blocks
 * 
 * @param html - HTML content to convert
 * @returns Markdown formatted string
 */
export function htmlToMarkdown(html: string): string {
  if (!html || typeof html !== 'string') {
    return '';
  }

  const turndownService = createTurndownService();
  
  try {
    const markdown = turndownService.turndown(html);
    
    // Clean up excessive blank lines
    return markdown
      .replace(/\n{3,}/g, '\n\n')
      .trim();
  } catch (error) {
    logger.error('‚ùå Error converting HTML to Markdown:', error);
    throw new Error('Failed to convert document to Markdown format');
  }
}

// ============================================================================
// DOCX Conversion
// ============================================================================

/**
 * Convert HTML content to DOCX format using DocShift
 * 
 * Preserves:
 * - Fonts, colors, sizes
 * - Bold, italic, underline
 * - Headings (H1, H2, H3)
 * - Lists (bullet and numbered)
 * - Text alignment
 * 
 * @param html - HTML content to convert
 * @returns Promise<Blob> - DOCX file as Blob
 */
export async function htmlToDocx(html: string): Promise<Blob> {
  if (!html || typeof html !== 'string') {
    throw new Error('No content to export');
  }

  try {
    // Dynamically import DocShift to avoid SSR issues
    const { toDocx } = await import('docshift');

    // Wrap HTML in proper document structure for better conversion
    const fullHtml = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    body {
      font-family: Arial, sans-serif;
      font-size: 12pt;
      line-height: 1.5;
    }
    h1 { font-size: 24pt; font-weight: bold; margin-bottom: 12pt; }
    h2 { font-size: 18pt; font-weight: bold; margin-bottom: 10pt; }
    h3 { font-size: 14pt; font-weight: bold; margin-bottom: 8pt; }
    p { margin-bottom: 8pt; }
    ul, ol { margin-left: 20pt; margin-bottom: 8pt; }
    li { margin-bottom: 4pt; }
  </style>
</head>
<body>
${html}
</body>
</html>
    `.trim();

    // Convert to DOCX
    const docxBlob = await toDocx(fullHtml);
    
    return docxBlob;
  } catch (error) {
    logger.error('‚ùå Error converting HTML to DOCX:', error);
    throw new Error('Failed to create Word document. Please try again.');
  }
}

// ============================================================================
// Export Functions
// ============================================================================

/**
 * Export editor content as Plain Text (.txt)
 * 
 * @param editor - TipTap editor instance
 * @param documentTitle - Document title for filename
 * @returns ExportResult with success status
 */
export async function exportToPlainText(
  editor: Editor,
  documentTitle?: string
): Promise<ExportResult> {
  try {
    // Validate editor has content
    if (!hasEditorContent(editor)) {
      return {
        success: false,
        error: 'Document is empty. Add some content before exporting.',
      };
    }

    // Get plain text content
    const plainText = getPlainTextFromEditor(editor);

    // Generate filename
    const filename = generateExportFilename(
      documentTitle || 'Untitled Document',
      'txt'
    );

    // Download file
    downloadTextFile(plainText, filename, 'text/plain');

    logger.log('‚úÖ Exported to Plain Text:', filename);
    
    return {
      success: true,
      filename,
    };
  } catch (error) {
    const errorMessage = error instanceof Error 
      ? error.message 
      : 'Failed to export as Plain Text';
    
    logger.error('‚ùå Plain Text export error:', error);
    
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Export editor content as Markdown (.md)
 * 
 * @param editor - TipTap editor instance
 * @param documentTitle - Document title for filename
 * @returns ExportResult with success status
 */
export async function exportToMarkdown(
  editor: Editor,
  documentTitle?: string
): Promise<ExportResult> {
  try {
    // Validate editor has content
    if (!hasEditorContent(editor)) {
      return {
        success: false,
        error: 'Document is empty. Add some content before exporting.',
      };
    }

    // Get HTML and convert to Markdown
    const html = getHTMLFromEditor(editor);
    const markdown = htmlToMarkdown(html);

    // Generate filename
    const filename = generateExportFilename(
      documentTitle || 'Untitled Document',
      'md'
    );

    // Download file
    downloadTextFile(markdown, filename, 'text/markdown');

    logger.log('‚úÖ Exported to Markdown:', filename);
    
    return {
      success: true,
      filename,
    };
  } catch (error) {
    const errorMessage = error instanceof Error 
      ? error.message 
      : 'Failed to export as Markdown';
    
    logger.error('‚ùå Markdown export error:', error);
    
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Export editor content as Word Document (.docx)
 * 
 * @param editor - TipTap editor instance
 * @param documentTitle - Document title for filename
 * @returns ExportResult with success status
 */
export async function exportToDocx(
  editor: Editor,
  documentTitle?: string
): Promise<ExportResult> {
  try {
    // Validate editor has content
    if (!hasEditorContent(editor)) {
      return {
        success: false,
        error: 'Document is empty. Add some content before exporting.',
      };
    }

    // Get HTML content
    const html = getHTMLFromEditor(editor);

    // Convert to DOCX (async operation)
    const docxBlob = await htmlToDocx(html);

    // Generate filename
    const filename = generateExportFilename(
      documentTitle || 'Untitled Document',
      'docx'
    );

    // Download file
    downloadBlob(docxBlob, filename);

    logger.log('‚úÖ Exported to Word Document:', filename);
    
    return {
      success: true,
      filename,
    };
  } catch (error) {
    const errorMessage = error instanceof Error 
      ? error.message 
      : 'Failed to export as Word Document';
    
    logger.error('‚ùå DOCX export error:', error);
    
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Export document in specified format
 * Unified export function that dispatches to format-specific handlers
 * 
 * @param editor - TipTap editor instance
 * @param format - Export format ('txt', 'md', 'docx')
 * @param documentTitle - Document title for filename
 * @returns ExportResult with success status
 */
export async function exportDocument(
  editor: Editor,
  format: ExportFormat,
  documentTitle?: string
): Promise<ExportResult> {
  if (!editor) {
    return {
      success: false,
      error: 'No editor instance available',
    };
  }

  switch (format) {
    case 'txt':
      return exportToPlainText(editor, documentTitle);
    case 'md':
      return exportToMarkdown(editor, documentTitle);
    case 'docx':
      return exportToDocx(editor, documentTitle);
    default:
      return {
        success: false,
        error: `Unsupported export format: ${format}`,
      };
  }
}


=== FILE: lib/utils/document-import.ts ===

/**
 * @file lib/utils/document-import.ts
 * @description Document import utilities for Plain Text, Markdown, and Word Document formats
 * 
 * Features:
 * - Import .txt (plain text) files into TipTap editor with preserved line breaks
 * - Import .md (Markdown) files with full formatting conversion via markdown-it
 * - Import .docx (Word Document) files with formatting preservation via mammoth
 * - File validation and error handling
 * 
 * Dependencies:
 * - mammoth: DOCX to HTML conversion (for .docx files)
 * - markdown-it: Markdown to HTML parsing (for .md files)
 * 
 * Formatting Preserved:
 * - Headings (H1-H6)
 * - Bold, italic, underline, strikethrough
 * - Ordered and unordered lists (including nested)
 * - Links
 * - Code blocks and inline code
 * - Blockquotes
 * - Text alignment (from Word documents)
 * - Paragraph spacing and line breaks
 */

'use client';

import type { Editor } from '@tiptap/react';
import MarkdownIt from 'markdown-it';
import { logger } from './logger';

// ============================================================================
// Types
// ============================================================================

/**
 * Import format types supported by the application
 */
export type ImportFormat = 'txt' | 'md' | 'docx';

/**
 * Import result containing success status and optional error message
 */
export interface ImportResult {
  success: boolean;
  error?: string;
  format?: ImportFormat;
}

// ============================================================================
// File Reading Utilities
// ============================================================================

/**
 * Read a file as text
 * 
 * @param file - File object to read
 * @returns Promise<string> - File content as text
 */
export async function readFileAsText(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (event) => {
      const content = event.target?.result;
      if (typeof content === 'string') {
        resolve(content);
      } else {
        reject(new Error('Failed to read file as text'));
      }
    };
    
    reader.onerror = () => {
      reject(new Error('Failed to read file'));
    };
    
    reader.readAsText(file);
  });
}

/**
 * Read a file as ArrayBuffer (for binary files like .docx)
 * 
 * @param file - File object to read
 * @returns Promise<ArrayBuffer> - File content as ArrayBuffer
 */
export async function readFileAsArrayBuffer(file: File): Promise<ArrayBuffer> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (event) => {
      const content = event.target?.result;
      if (content instanceof ArrayBuffer) {
        resolve(content);
      } else {
        reject(new Error('Failed to read file as ArrayBuffer'));
      }
    };
    
    reader.onerror = () => {
      reject(new Error('Failed to read file'));
    };
    
    reader.readAsArrayBuffer(file);
  });
}

// ============================================================================
// File Validation
// ============================================================================

/**
 * Validate file type and size
 * 
 * @param file - File to validate
 * @param allowedTypes - Array of allowed MIME types or extensions
 * @param maxSizeMB - Maximum file size in megabytes (default: 10MB)
 * @returns Error message if invalid, null if valid
 */
export function validateFile(
  file: File,
  allowedTypes: string[],
  maxSizeMB: number = 10
): string | null {
  // Check file size
  const maxSizeBytes = maxSizeMB * 1024 * 1024;
  if (file.size > maxSizeBytes) {
    return `File size exceeds ${maxSizeMB}MB limit`;
  }

  // Check file type
  const fileName = file.name.toLowerCase();
  const fileExtension = fileName.substring(fileName.lastIndexOf('.'));
  
  const isValidType = allowedTypes.some(type => {
    if (type.startsWith('.')) {
      return fileExtension === type;
    }
    return file.type === type;
  });

  if (!isValidType) {
    return `Invalid file type. Allowed types: ${allowedTypes.join(', ')}`;
  }

  return null;
}

// ============================================================================
// Markdown Parser Instance
// ============================================================================

/**
 * Configured markdown-it instance for parsing Markdown to HTML
 * 
 * Configuration:
 * - html: true - Allow HTML tags in source (passthrough)
 * - breaks: true - Convert \n to <br> in paragraphs
 * - linkify: true - Auto-convert URL-like text to links
 */
const markdownParser = new MarkdownIt({
  html: true,
  breaks: true,
  linkify: true,
  typographer: true, // Smart quotes, dashes, etc.
});

// ============================================================================
// Markdown to HTML Conversion
// ============================================================================

/**
 * Convert Markdown to HTML using markdown-it parser
 * 
 * Supports all standard Markdown features:
 * - Headings (# ## ### etc.)
 * - Bold (**text** or __text__)
 * - Italic (*text* or _text_)
 * - Strikethrough (~~text~~)
 * - Links [text](url)
 * - Unordered lists (- or * or +)
 * - Ordered lists (1. 2. 3.)
 * - Nested lists
 * - Blockquotes (>)
 * - Code blocks (``` or indented)
 * - Inline code (`code`)
 * - Horizontal rules (--- or ***)
 * 
 * @param markdown - Markdown content
 * @returns HTML content compatible with TipTap editor
 */
export function markdownToHtml(markdown: string): string {
  if (!markdown || typeof markdown !== 'string') {
    return '';
  }

  // Normalize line endings (CRLF ‚Üí LF)
  const normalized = markdown.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

  // Parse markdown to HTML
  let html = markdownParser.render(normalized);

  // Post-process: Convert <del> to <s> for TipTap strikethrough compatibility
  // (markdown-it uses <del> by default, TipTap expects <s>)
  html = html.replace(/<del>/g, '<s>').replace(/<\/del>/g, '</s>');

  // Post-process: Ensure empty paragraphs are preserved
  html = html.replace(/<p><\/p>/g, '<p>&nbsp;</p>');

  return html.trim();
}

// ============================================================================
// Plain Text Conversion
// ============================================================================

/**
 * Convert plain text to HTML with preserved formatting
 * 
 * Preserves:
 * - Paragraph breaks (double newlines)
 * - Single line breaks (converted to <br>)
 * - Leading/trailing whitespace within paragraphs
 * 
 * Handles:
 * - Windows line endings (CRLF ‚Üí LF)
 * - Mac Classic line endings (CR ‚Üí LF)
 * - Multiple consecutive blank lines (collapsed to single paragraph break)
 * 
 * @param plainText - Plain text content
 * @returns HTML content with paragraphs
 */
export function plainTextToHtml(plainText: string): string {
  if (!plainText || typeof plainText !== 'string') {
    return '';
  }

  // Step 1: Normalize line endings (CRLF ‚Üí LF, CR ‚Üí LF)
  const normalized = plainText.replace(/\r\n/g, '\n').replace(/\r/g, '\n');

  // Step 2: Split by double line breaks (paragraphs)
  // Using \n\n+ to collapse multiple blank lines as requested
  const paragraphs = normalized.split(/\n\n+/);

  // Step 3: Convert each paragraph
  const htmlParagraphs = paragraphs.map(paragraph => {
    // Trim the paragraph but preserve internal formatting
    const trimmed = paragraph.trim();
    
    // Handle empty paragraphs (shouldn't happen after split, but safe guard)
    if (!trimmed) {
      return '';
    }

    // Escape HTML special characters for safety
    const escaped = escapeHtml(trimmed);

    // Convert single newlines within paragraph to <br>
    const withBreaks = escaped.replace(/\n/g, '<br>');

    return `<p>${withBreaks}</p>`;
  });

  // Filter out empty strings and join
  return htmlParagraphs.filter(p => p.length > 0).join('\n');
}

/**
 * Escape HTML special characters to prevent XSS and ensure proper rendering
 * 
 * @param text - Raw text to escape
 * @returns Text with HTML entities escaped
 */
function escapeHtml(text: string): string {
  const htmlEntities: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
  };
  
  return text.replace(/[&<>"']/g, (char) => htmlEntities[char] || char);
}

// ============================================================================
// DOCX Conversion
// ============================================================================

/**
 * Style mapping for mammoth DOCX conversion
 * Maps Word styles to HTML elements with proper formatting
 * 
 * Key mappings:
 * - Headings: Word heading styles ‚Üí HTML h1-h6
 * - Text formatting: bold, italic, underline, strikethrough
 * - Alignment: Center/Right aligned paragraphs get CSS classes
 */
const MAMMOTH_STYLE_MAP = [
  // Heading mappings (various Word style names)
  "p[style-name='Heading 1'] => h1:fresh",
  "p[style-name='Heading 2'] => h2:fresh",
  "p[style-name='Heading 3'] => h3:fresh",
  "p[style-name='Heading 4'] => h4:fresh",
  "p[style-name='Heading 5'] => h5:fresh",
  "p[style-name='Heading 6'] => h6:fresh",
  "p[style-name='Title'] => h1:fresh",
  "p[style-name='Subtitle'] => h2:fresh",
  
  // Text formatting (explicit run-level formatting)
  "b => strong",
  "i => em",
  "u => u",              // Preserve underline (mammoth ignores by default)
  "strike => s",         // Strikethrough
  
  // Alignment classes (used with transforms below)
  "p[style-name='Center'] => p.text-center:fresh",
  "p[style-name='Right'] => p.text-right:fresh",
  "p[style-name='Justify'] => p.text-justify:fresh",
];

/**
 * Convert DOCX to HTML using mammoth with full formatting preservation
 * 
 * Preserves:
 * - Headings (H1-H6)
 * - Bold, italic, underline, strikethrough
 * - Ordered and unordered lists
 * - Text alignment (center, right, justify)
 * - Links
 * - Tables
 * 
 * Does NOT preserve (by design):
 * - Images (as requested)
 * - Exact font sizes/colors (mammoth limitation)
 * - Page margins/layout
 * 
 * @param arrayBuffer - DOCX file content as ArrayBuffer
 * @returns Promise<string> - HTML content compatible with TipTap
 */
export async function docxToHtml(arrayBuffer: ArrayBuffer): Promise<string> {
  try {
    // Dynamically import mammoth to avoid SSR issues
    const mammoth = await import('mammoth');
    
    // Access transforms helper (not in TypeScript types but exists at runtime)
    // The transforms API exists at runtime but isn't in @types/mammoth
    const mammothWithTransforms = mammoth as unknown as MammothWithTransforms;
    
    // Build transform function if transforms helper is available
    let transformDocument: ((element: unknown) => unknown) | undefined;
    
    if (mammothWithTransforms.transforms?.paragraph) {
      // Use mammoth's transform helper to capture alignment
      transformDocument = mammothWithTransforms.transforms.paragraph(
        (paragraph: MammothParagraph) => {
          // Check paragraph alignment and assign style names for CSS class mapping
          if (paragraph.alignment === 'center' && !paragraph.styleName) {
            return { ...paragraph, styleName: 'Center' };
          }
          if (paragraph.alignment === 'right' && !paragraph.styleName) {
            return { ...paragraph, styleName: 'Right' };
          }
          if (paragraph.alignment === 'both' && !paragraph.styleName) {
            // 'both' is justify in Word
            return { ...paragraph, styleName: 'Justify' };
          }
          return paragraph;
        }
      );
    }
    
    // Configure mammoth options for maximum formatting preservation
    const options: Parameters<typeof mammoth.convertToHtml>[1] = {
      styleMap: MAMMOTH_STYLE_MAP,
      
      // Transform document for alignment (if available)
      ...(transformDocument && { transformDocument }),
      
      // Ignore images as requested
      convertImage: mammoth.images.imgElement(() => {
        // Return empty to skip images
        return Promise.resolve({ src: '' });
      }),
    };
    
    // Convert DOCX to HTML
    const result = await mammoth.convertToHtml({ arrayBuffer }, options);
    
    if (result.messages && result.messages.length > 0) {
      // Log warnings but don't fail (e.g., unsupported features)
      logger.warn('‚ö†Ô∏è DOCX conversion warnings:', result.messages);
    }
    
    // Post-process: Convert alignment classes to TipTap-compatible format
    let html = result.value;
    
    // TipTap's TextAlign extension uses data attributes, but inline styles work too
    // Convert our classes to inline styles for TipTap compatibility
    html = html.replace(/class="text-center"/g, 'style="text-align: center"');
    html = html.replace(/class="text-right"/g, 'style="text-align: right"');
    html = html.replace(/class="text-justify"/g, 'style="text-align: justify"');
    
    // Remove empty image tags that were skipped
    html = html.replace(/<img[^>]*src=""[^>]*>/g, '');
    
    return html;
  } catch (error) {
    logger.error('‚ùå Error converting DOCX to HTML:', error);
    throw new Error('Failed to convert Word document. The file may be corrupted or in an unsupported format.');
  }
}

/**
 * Extended mammoth type that includes the transforms helper
 * The transforms API exists at runtime but isn't in @types/mammoth
 */
interface MammothWithTransforms {
  transforms?: {
    paragraph: (fn: (p: MammothParagraph) => MammothParagraph) => (element: unknown) => unknown;
  };
}

/**
 * Mammoth paragraph type for transform function
 * Simplified type for the paragraph properties we use
 */
interface MammothParagraph {
  alignment?: 'left' | 'center' | 'right' | 'both';
  styleName?: string;
  [key: string]: unknown;
}

// ============================================================================
// Import Functions
// ============================================================================

/**
 * Import plain text file into editor
 * 
 * @param editor - TipTap editor instance
 * @param file - File object to import
 * @returns ImportResult with success status
 */
export async function importPlainText(
  editor: Editor,
  file: File
): Promise<ImportResult> {
  try {
    // Validate file
    const validationError = validateFile(file, ['.txt', 'text/plain']);
    if (validationError) {
      return {
        success: false,
        error: validationError,
      };
    }

    // Read file content
    const plainText = await readFileAsText(file);

    if (!plainText.trim()) {
      return {
        success: false,
        error: 'File is empty',
      };
    }

    // Convert to HTML
    const html = plainTextToHtml(plainText);

    // Insert into editor (replaces current content)
    editor.commands.setContent(html);

    logger.log('‚úÖ Imported plain text file:', file.name);

    return {
      success: true,
      format: 'txt',
    };
  } catch (error) {
    const errorMessage = error instanceof Error 
      ? error.message 
      : 'Failed to import plain text file';
    
    logger.error('‚ùå Plain text import error:', error);
    
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Import Markdown file into editor
 * 
 * @param editor - TipTap editor instance
 * @param file - File object to import
 * @returns ImportResult with success status
 */
export async function importMarkdown(
  editor: Editor,
  file: File
): Promise<ImportResult> {
  try {
    // Validate file
    const validationError = validateFile(file, ['.md', 'text/markdown', 'text/x-markdown']);
    if (validationError) {
      return {
        success: false,
        error: validationError,
      };
    }

    // Read file content
    const markdown = await readFileAsText(file);

    if (!markdown.trim()) {
      return {
        success: false,
        error: 'File is empty',
      };
    }

    // Convert Markdown to HTML
    const html = markdownToHtml(markdown);

    // Insert into editor (replaces current content)
    editor.commands.setContent(html);

    logger.log('‚úÖ Imported Markdown file:', file.name);

    return {
      success: true,
      format: 'md',
    };
  } catch (error) {
    const errorMessage = error instanceof Error 
      ? error.message 
      : 'Failed to import Markdown file';
    
    logger.error('‚ùå Markdown import error:', error);
    
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Import Word Document (.docx) into editor
 * 
 * @param editor - TipTap editor instance
 * @param file - File object to import
 * @returns ImportResult with success status
 */
export async function importDocx(
  editor: Editor,
  file: File
): Promise<ImportResult> {
  try {
    // Validate file
    const validationError = validateFile(file, [
      '.docx',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ]);
    if (validationError) {
      return {
        success: false,
        error: validationError,
      };
    }

    // Read file as ArrayBuffer
    const arrayBuffer = await readFileAsArrayBuffer(file);

    // Convert DOCX to HTML
    const html = await docxToHtml(arrayBuffer);

    if (!html.trim()) {
      return {
        success: false,
        error: 'File appears to be empty',
      };
    }

    // Insert into editor (replaces current content)
    editor.commands.setContent(html);

    logger.log('‚úÖ Imported Word Document:', file.name);

    return {
      success: true,
      format: 'docx',
    };
  } catch (error) {
    const errorMessage = error instanceof Error 
      ? error.message 
      : 'Failed to import Word Document';
    
    logger.error('‚ùå DOCX import error:', error);
    
    return {
      success: false,
      error: errorMessage,
    };
  }
}

/**
 * Import document in any supported format
 * Unified import function that dispatches to format-specific handlers
 * 
 * @param editor - TipTap editor instance
 * @param file - File object to import
 * @returns ImportResult with success status
 */
export async function importDocument(
  editor: Editor,
  file: File
): Promise<ImportResult> {
  if (!editor) {
    return {
      success: false,
      error: 'No editor instance available',
    };
  }

  if (!file) {
    return {
      success: false,
      error: 'No file selected',
    };
  }

  // Determine file type by extension
  const fileName = file.name.toLowerCase();
  
  if (fileName.endsWith('.txt')) {
    return importPlainText(editor, file);
  } else if (fileName.endsWith('.md')) {
    return importMarkdown(editor, file);
  } else if (fileName.endsWith('.docx')) {
    return importDocx(editor, file);
  } else {
    return {
      success: false,
      error: 'Unsupported file type. Please use .txt, .md, or .docx files.',
    };
  }
}


=== FILE: lib/utils/error-handling.ts ===

/**
 * @file lib/utils/error-handling.ts
 * @description Centralized error handling utilities for consistent error management
 * 
 * Provides:
 * - User-friendly error message formatting
 * - Error logging
 * - Error type classification
 * - Retry logic
 */

// ============================================================================
// Constants
// ============================================================================

/** Maximum text length for API requests (10,000 characters) */
export const MAX_TEXT_LENGTH = 10000;

/** Maximum persona photo size (2MB) */
export const MAX_PHOTO_SIZE = 2 * 1024 * 1024;

/** Allowed image formats for persona photos */
export const ALLOWED_IMAGE_FORMATS = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];

/** API request timeout in milliseconds (30 seconds) */
export const API_TIMEOUT = 30000;

/** localStorage quota warning threshold (80%) */
export const STORAGE_WARNING_THRESHOLD = 0.8;

// ============================================================================
// Error Types
// ============================================================================

export type ErrorType = 
  | 'validation'
  | 'network'
  | 'timeout'
  | 'storage'
  | 'api'
  | 'unknown';

export interface AppError {
  type: ErrorType;
  message: string;
  userMessage: string;
  details?: unknown;
  retryable: boolean;
}

// ============================================================================
// Error Classification
// ============================================================================

/**
 * Classify error type based on error object
 */
export function classifyError(error: unknown): ErrorType {
  if (error instanceof TypeError && error.message.includes('fetch')) {
    return 'network';
  }
  
  if (error instanceof Error) {
    if (error.message.includes('timeout') || error.message.includes('timed out')) {
      return 'timeout';
    }
    if (error.message.includes('quota') || error.message.includes('storage')) {
      return 'storage';
    }
    if (error.message.includes('validation') || error.message.includes('invalid')) {
      return 'validation';
    }
    if (error.message.includes('API') || error.message.includes('Claude')) {
      return 'api';
    }
  }
  
  return 'unknown';
}

/**
 * Create a standardized AppError from any error
 */
export function createAppError(error: unknown, context?: string): AppError {
  const errorType = classifyError(error);
  const errorMessage = error instanceof Error ? error.message : String(error);
  
  // Generate user-friendly message
  let userMessage: string;
  let retryable = false;
  
  switch (errorType) {
    case 'network':
      userMessage = 'Network error. Please check your connection and try again.';
      retryable = true;
      break;
      
    case 'timeout':
      userMessage = 'Request timed out. Please try again with shorter text or check your connection.';
      retryable = true;
      break;
      
    case 'storage':
      userMessage = 'Storage limit reached. Please clear some data or use a different browser.';
      retryable = false;
      break;
      
    case 'api':
      userMessage = 'AI service error. Please try again in a moment.';
      retryable = true;
      break;
      
    case 'validation':
      userMessage = errorMessage; // Validation errors are already user-friendly
      retryable = false;
      break;
      
    default:
      userMessage = 'An unexpected error occurred. Please try again.';
      retryable = true;
  }
  
  // Add context if provided
  if (context) {
    userMessage = `${context}: ${userMessage}`;
  }
  
  return {
    type: errorType,
    message: errorMessage,
    userMessage,
    details: error,
    retryable,
  };
}

// ============================================================================
// Validation Functions
// ============================================================================

/**
 * Validate text length for API requests
 * @throws Error if text exceeds maximum length
 */
export function validateTextLength(text: string, fieldName: string = 'Text'): void {
  if (text.length > MAX_TEXT_LENGTH) {
    throw new Error(
      `${fieldName} exceeds maximum length of ${MAX_TEXT_LENGTH.toLocaleString()} characters. ` +
      `Current length: ${text.length.toLocaleString()} characters. ` +
      `Please shorten your text and try again.`
    );
  }
}

/**
 * Validate text is not empty
 * @throws Error if text is empty
 */
export function validateNotEmpty(text: string, fieldName: string = 'Text'): void {
  if (!text || text.trim().length === 0) {
    throw new Error(`${fieldName} cannot be empty.`);
  }
}

/**
 * Validate image file for persona photo
 * @throws Error if image is invalid
 */
export function validateImage(file: File): void {
  // Check file size
  if (file.size > MAX_PHOTO_SIZE) {
    throw new Error(
      `Image size (${(file.size / 1024 / 1024).toFixed(2)}MB) exceeds maximum of 2MB. ` +
      `Please choose a smaller image.`
    );
  }
  
  // Check file format
  if (!ALLOWED_IMAGE_FORMATS.includes(file.type)) {
    throw new Error(
      `Invalid image format (${file.type}). ` +
      `Allowed formats: JPEG, PNG, WebP.`
    );
  }
}

/**
 * Validate project name
 * @throws Error if name is invalid
 */
export function validateProjectName(name: string): void {
  validateNotEmpty(name, 'Project name');
  
  if (name.length > 100) {
    throw new Error('Project name cannot exceed 100 characters.');
  }
  
  // Check for invalid characters
  const invalidChars = /[<>:"/\\|?*]/;
  if (invalidChars.test(name)) {
    throw new Error('Project name contains invalid characters.');
  }
}

/**
 * Validate brand voice data
 * @throws Error if brand voice is invalid
 */
export function validateBrandVoice(brandName: string): void {
  validateNotEmpty(brandName, 'Brand name');
  
  if (brandName.length > 100) {
    throw new Error('Brand name cannot exceed 100 characters.');
  }
}

/**
 * Validate persona data
 * @throws Error if persona is invalid
 */
export function validatePersona(name: string): void {
  validateNotEmpty(name, 'Persona name');
  
  if (name.length > 100) {
    throw new Error('Persona name cannot exceed 100 characters.');
  }
}

// ============================================================================
// Storage Functions
// ============================================================================

/**
 * Check localStorage quota and return usage percentage
 * @returns Usage percentage (0-100)
 */
export function checkStorageQuota(): number {
  if (typeof window === 'undefined') return 0;
  
  try {
    // Estimate localStorage usage
    let totalSize = 0;
    for (const key in localStorage) {
      if (localStorage.hasOwnProperty(key)) {
        totalSize += localStorage[key].length + key.length;
      }
    }
    
    // Typical localStorage limit is 5-10MB
    // We'll use 5MB as conservative estimate
    const limitBytes = 5 * 1024 * 1024;
    const usagePercent = (totalSize / limitBytes) * 100;
    
    if (usagePercent > STORAGE_WARNING_THRESHOLD * 100) {
      logWarning(
        `localStorage is ${usagePercent.toFixed(1)}% full (${(totalSize / 1024).toFixed(0)}KB used)`
      );
    }
    
    return usagePercent;
  } catch (error) {
    logError(error, 'checkStorageQuota');
    return 0;
  }
}

/**
 * Check if localStorage is available and has space
 * @throws Error if storage is not available or full
 */
export function ensureStorageAvailable(): void {
  if (typeof window === 'undefined') {
    throw new Error('Storage not available in non-browser environment');
  }
  
  try {
    // Test write capability
    const testKey = '__storage_test__';
    localStorage.setItem(testKey, 'test');
    localStorage.removeItem(testKey);
  } catch (error) {
    if (error instanceof DOMException && error.code === 22) {
      throw new Error(
        'Storage quota exceeded. Please clear some data or use a different browser.'
      );
    }
    throw new Error('Storage not available. Please enable localStorage in your browser.');
  }
  
  // Check quota
  const usage = checkStorageQuota();
  if (usage > 95) {
    throw new Error(
      'Storage is nearly full (95% used). Please clear some data before continuing.'
    );
  }
}

// ============================================================================
// API Helper Functions
// ============================================================================

/**
 * Fetch with timeout
 * @param url - URL to fetch
 * @param options - Fetch options
 * @param timeout - Timeout in milliseconds
 * @returns Response promise
 */
export async function fetchWithTimeout(
  url: string,
  options: RequestInit = {},
  timeout: number = API_TIMEOUT
): Promise<Response> {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeout);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal,
    });
    
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    
    if (error instanceof Error && error.name === 'AbortError') {
      throw new Error(
        `Request timed out after ${timeout / 1000} seconds. ` +
        `Please try again with shorter text or check your connection.`
      );
    }
    
    throw error;
  }
}

/**
 * Retry function with exponential backoff
 * @param fn - Function to retry
 * @param maxRetries - Maximum number of retries
 * @param baseDelay - Base delay in milliseconds
 * @returns Result of function
 */
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error | unknown;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      
      // Don't retry on validation errors
      if (classifyError(error) === 'validation') {
        throw error;
      }
      
      // Don't retry on last attempt
      if (attempt === maxRetries) {
        break;
      }
      
      // Calculate delay with exponential backoff
      const delay = baseDelay * Math.pow(2, attempt);
      logWarning(`Retry attempt ${attempt + 1}/${maxRetries} in ${delay}ms...`);
      
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
  
  throw lastError;
}

// ============================================================================
// Error Logging
// ============================================================================

/**
 * Log error to console with context
 */
export function logError(error: unknown, context: string): void {
  const appError = createAppError(error, context);
  
  console.error('‚ùå Error:', {
    context,
    type: appError.type,
    message: appError.message,
    userMessage: appError.userMessage,
    retryable: appError.retryable,
    details: appError.details,
  });
}

/**
 * Log warning to console
 */
export function logWarning(message: string, details?: unknown): void {
  if (process.env.NODE_ENV === 'development') {
    console.warn('‚ö†Ô∏è Warning:', message, details);
  }
}

// ============================================================================
// User Message Formatting
// ============================================================================

/**
 * Format error message for display to user
 */
export function formatErrorForUser(error: unknown, context?: string): string {
  const appError = createAppError(error, context);
  return appError.userMessage;
}

/**
 * Get retry suggestion based on error
 */
export function getRetrySuggestion(error: unknown): string | null {
  const appError = createAppError(error);
  
  if (!appError.retryable) {
    return null;
  }
  
  switch (appError.type) {
    case 'network':
      return 'Check your connection and try again';
    case 'timeout':
      return 'Try with shorter text or try again later';
    case 'api':
      return 'Try again in a moment';
    default:
      return 'Try again';
  }
}


=== FILE: lib/utils/image-utils.ts ===

/**
 * @file lib/utils/image-utils.ts
 * @description Image handling utilities for persona photos
 * 
 * Provides functions for:
 * - Converting files to base64
 * - Validating image files
 * - Resizing images to save localStorage space
 */

'use client';

import { logger } from './logger';

/**
 * Maximum file size in bytes (2MB)
 */
const MAX_FILE_SIZE = 2 * 1024 * 1024;

/**
 * Allowed image MIME types
 */
const ALLOWED_TYPES = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];

/**
 * Validation result
 */
export interface ValidationResult {
  valid: boolean;
  error?: string;
}

/**
 * Validate image file type and size
 */
export function validateImageFile(file: File): ValidationResult {
  // Check file type
  if (!ALLOWED_TYPES.includes(file.type)) {
    return {
      valid: false,
      error: 'Invalid file type. Please upload a JPG, PNG, or WebP image.',
    };
  }

  // Check file size
  if (file.size > MAX_FILE_SIZE) {
    return {
      valid: false,
      error: `File is too large. Maximum size is ${MAX_FILE_SIZE / 1024 / 1024}MB.`,
    };
  }

  return { valid: true };
}

/**
 * Convert File to base64 string
 * Returns a promise that resolves with the base64 data URL
 */
export function fileToBase64(file: File): Promise<string> {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = () => {
      if (typeof reader.result === 'string') {
        resolve(reader.result);
      } else {
        reject(new Error('Failed to read file as string'));
      }
    };

    reader.onerror = () => {
      reject(new Error('Failed to read file'));
    };

    reader.readAsDataURL(file);
  });
}

/**
 * Resize image to fit within max dimensions
 * Returns a promise that resolves with resized base64 data URL
 */
export function resizeImage(base64: string, maxWidth: number = 400): Promise<string> {
  return new Promise((resolve, reject) => {
    const img = new Image();

    img.onload = () => {
      // Calculate new dimensions
      let width = img.width;
      let height = img.height;

      if (width > maxWidth) {
        height = (height * maxWidth) / width;
        width = maxWidth;
      }

      // Create canvas
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;

      const ctx = canvas.getContext('2d');
      if (!ctx) {
        reject(new Error('Failed to get canvas context'));
        return;
      }

      // Draw resized image
      ctx.drawImage(img, 0, 0, width, height);

      // Convert to base64
      try {
        const resizedBase64 = canvas.toDataURL('image/jpeg', 0.85);
        resolve(resizedBase64);
      } catch (error) {
        reject(error);
      }
    };

    img.onerror = () => {
      reject(new Error('Failed to load image'));
    };

    img.src = base64;
  });
}

/**
 * Process uploaded image file
 * - Validates file
 * - Converts to base64
 * - Resizes if needed
 * Returns base64 data URL or throws error
 */
export async function processImageFile(file: File): Promise<string> {
  // Validate file
  const validation = validateImageFile(file);
  if (!validation.valid) {
    throw new Error(validation.error);
  }

  // Convert to base64
  const base64 = await fileToBase64(file);

  // Resize if image is large
  const resized = await resizeImage(base64, 400);

  logger.log('‚úÖ Image processed:', {
    originalSize: `${(file.size / 1024).toFixed(1)}KB`,
    resizedSize: `${(resized.length / 1024).toFixed(1)}KB`,
  });

  return resized;
}

/**
 * Get placeholder image data URL for personas without photos
 * Returns a simple SVG as data URL
 */
export function getPlaceholderImage(): string {
  const svg = `
    <svg width="400" height="400" xmlns="http://www.w3.org/2000/svg">
      <rect width="400" height="400" fill="#E5E7EB"/>
      <circle cx="200" cy="160" r="60" fill="#9CA3AF"/>
      <path d="M 100 320 Q 200 260 300 320" fill="#9CA3AF"/>
    </svg>
  `;

  return `data:image/svg+xml;base64,${btoa(svg)}`;
}


=== FILE: lib/utils/logger.ts ===

/**
 * @file lib/utils/logger.ts
 * @description Development-only logging utility
 * 
 * Provides console logging that only runs in development mode.
 * All log statements are stripped in production builds for performance.
 */

const isDev = process.env.NODE_ENV === 'development';

/**
 * Development-only logger
 * All methods are no-ops in production
 */
export const logger = {
  /**
   * Log informational message (development only)
   */
  log: (...args: unknown[]): void => {
    if (isDev) {
      console.log(...args);
    }
  },

  /**
   * Log warning message (development only)
   */
  warn: (...args: unknown[]): void => {
    if (isDev) {
      console.warn(...args);
    }
  },

  /**
   * Log error message (always logs - errors should be visible)
   */
  error: (...args: unknown[]): void => {
    console.error(...args);
  },

  /**
   * Log info message (development only)
   */
  info: (...args: unknown[]): void => {
    if (isDev) {
      console.info(...args);
    }
  },

  /**
   * Log debug message (development only)
   */
  debug: (...args: unknown[]): void => {
    if (isDev) {
      console.debug(...args);
    }
  },
};

/**
 * Conditional log that executes callback only in development
 * Useful for complex log formatting
 */
export function devOnly(callback: () => void): void {
  if (isDev) {
    callback();
  }
}

export default logger;


=== FILE: lib/utils/pdf-export.ts ===

/**
 * @file lib/utils/pdf-export.ts
 * @description PDF export utilities for setting document title and filename
 * 
 * When window.print() is called, browsers use the HTML <title> tag
 * as the default filename for "Save as PDF". This utility helps
 * set the title dynamically based on document name.
 */

/**
 * Sanitize a string for use as a filename
 * - Removes or replaces invalid filename characters
 * - Limits length to reasonable size
 * - Handles edge cases
 * 
 * @param title - The document title to sanitize
 * @returns Sanitized filename (without extension)
 * 
 * @example
 * sanitizeFilename("CoffeeWorx Coffee Brochure") => "CoffeeWorx-Coffee-Brochure"
 * sanitizeFilename("My Doc (v2)") => "My-Doc-v2"
 * sanitizeFilename("") => "untitled"
 */
export function sanitizeFilename(title: string): string {
  if (!title || title.trim() === '') {
    return 'untitled';
  }

  return title
    .trim()
    // Replace special characters with hyphens
    .replace(/[^a-zA-Z0-9\s-]/g, '-')
    // Replace multiple spaces with single hyphen
    .replace(/\s+/g, '-')
    // Replace multiple hyphens with single hyphen
    .replace(/-+/g, '-')
    // Remove leading/trailing hyphens
    .replace(/^-+|-+$/g, '')
    // Limit length to 50 characters
    .substring(0, 50)
    // Remove trailing hyphen if truncation created one
    .replace(/-+$/, '')
    // If empty after sanitization, use fallback
    || 'untitled';
}

/**
 * Set document title for PDF export
 * Temporarily changes the HTML <title> tag to control PDF filename
 * 
 * @param documentTitle - The document title to use for PDF filename
 * @returns Cleanup function to restore original title
 * 
 * @example
 * const restore = setDocumentTitleForPDF("My Document");
 * window.print();
 * restore(); // Call after print dialog opens
 */
export function setDocumentTitleForPDF(documentTitle?: string): () => void {
  // Save original title
  const originalTitle = document.title;
  
  // Set new title (sanitized)
  const newTitle = documentTitle 
    ? sanitizeFilename(documentTitle)
    : 'document';
  
  document.title = newTitle;
  
  // Return cleanup function to restore original title
  return () => {
    document.title = originalTitle;
  };
}

/**
 * Execute window.print() with proper document title
 * Sets the document title, opens print dialog, then restores original title
 * 
 * @param documentTitle - Optional document title for PDF filename
 * 
 * @example
 * printWithTitle("CoffeeWorx Brochure");
 * // Opens print dialog with filename "CoffeeWorx-Brochure.pdf"
 */
export function printWithTitle(documentTitle?: string): void {
  // Set document title
  const restore = setDocumentTitleForPDF(documentTitle);
  
  // Open print dialog
  window.print();
  
  // Restore original title after a short delay
  // This allows the browser to capture the new title for the PDF
  setTimeout(restore, 100);
}


=== FILE: lib/utils/project-utils.ts ===

/**
 * @file lib/utils/project-utils.ts
 * @description Project utility functions and system initialization
 * 
 * Provides high-level functions for:
 * - Project system initialization
 * - Data migration from legacy brand voice storage
 * - Common project operations
 */

'use client';

import type { Project } from '@/lib/types/project';
import type { BrandVoice } from '@/lib/types/brand';
import {
  getAllProjects,
  getActiveProjectId,
  setActiveProjectId,
  createProject,
  saveBrandVoiceToProject,
} from '@/lib/storage/unified-storage';
// Use local storage for sync initialization
import * as localProjectStorage from '@/lib/storage/project-storage';
import { logger } from './logger';

/** Legacy brand voice localStorage key */
const LEGACY_BRAND_VOICE_KEY = 'copyworx-brand-voice';

/** Migration flag to ensure migration only runs once */
const MIGRATION_COMPLETE_KEY = 'copyworx_project_migration_complete';

/**
 * Check if migration has already been completed
 */
function isMigrationComplete(): boolean {
  if (typeof window === 'undefined') return true;
  
  try {
    return localStorage.getItem(MIGRATION_COMPLETE_KEY) === 'true';
  } catch {
    return false;
  }
}

/**
 * Mark migration as complete
 */
function markMigrationComplete(): void {
  if (typeof window === 'undefined') return;
  
  try {
    localStorage.setItem(MIGRATION_COMPLETE_KEY, 'true');
  } catch (error) {
    logger.error('‚ùå Failed to mark migration complete:', error);
  }
}

/**
 * Migrate legacy brand voice data to project system
 * Uses local storage directly for sync operation during initialization
 * 
 * This function:
 * 1. Checks for old brand voice in localStorage
 * 2. Creates default project if needed
 * 3. Moves brand voice to that project
 * 4. Removes old localStorage key
 */
function migrateLegacyBrandVoice(): void {
  if (typeof window === 'undefined') return;
  
  // Skip if migration already complete
  if (isMigrationComplete()) {
    logger.log('‚úÖ Migration already complete');
    return;
  }
  
  logger.log('üîÑ Checking for legacy brand voice data...');
  
  try {
    // Check for legacy brand voice
    const legacyBrandVoiceJson = localStorage.getItem(LEGACY_BRAND_VOICE_KEY);
    
    if (!legacyBrandVoiceJson) {
      logger.log('‚ÑπÔ∏è No legacy brand voice found');
      markMigrationComplete();
      return;
    }
    
    // Parse legacy brand voice
    const legacyBrandVoice: BrandVoice = JSON.parse(legacyBrandVoiceJson);
    logger.log('üì¶ Found legacy brand voice:', legacyBrandVoice.brandName);
    
    // Get current projects (use local storage for sync operation)
    const projects = localProjectStorage.getAllProjects();
    
    if (projects.length === 0) {
      // No projects exist - create default project with brand voice
      logger.log('üÜï Creating default project with legacy brand voice...');
      const defaultProject = localProjectStorage.createProject('My First Project');
      localProjectStorage.saveBrandVoiceToProject(defaultProject.id, legacyBrandVoice);
      localProjectStorage.setActiveProjectId(defaultProject.id);
      logger.log('‚úÖ Legacy brand voice migrated to new project');
    } else {
      // Projects exist - add to active project (or first project if no active)
      const activeId = localProjectStorage.getActiveProjectId();
      const targetProject = activeId 
        ? projects.find(p => p.id === activeId) || projects[0]
        : projects[0];
      
      logger.log(`üîÑ Migrating brand voice to project: ${targetProject.name}`);
      localProjectStorage.saveBrandVoiceToProject(targetProject.id, legacyBrandVoice);
      logger.log('‚úÖ Legacy brand voice migrated to existing project');
    }
    
    // Remove legacy key
    localStorage.removeItem(LEGACY_BRAND_VOICE_KEY);
    logger.log('üóëÔ∏è Removed legacy brand voice key');
    
    // Mark migration as complete
    markMigrationComplete();
    logger.log('‚úÖ Migration complete');
    
  } catch (error) {
    logger.error('‚ùå Migration failed:', error);
    // Mark as complete anyway to prevent infinite retry loops
    markMigrationComplete();
  }
}

/**
 * Initialize project system
 * Uses local storage directly for sync initialization
 * 
 * This function should be called once when the app loads.
 * It:
 * 1. Ensures at least one project exists
 * 2. Migrates legacy brand voice data
 * 3. Verifies active project is valid
 */
export function initializeProjectSystem(): void {
  if (typeof window === 'undefined') {
    logger.warn('‚ö†Ô∏è Cannot initialize project system on server');
    return;
  }
  
  logger.log('üöÄ Initializing project system...');
  
  try {
    // Ensure at least one project exists (use local storage for sync operation)
    localProjectStorage.ensureDefaultProject();
    
    // Migrate legacy data
    migrateLegacyBrandVoice();
    
    // Verify active project (use local storage for sync operation)
    const activeId = localProjectStorage.getActiveProjectId();
    const projects = localProjectStorage.getAllProjects();
    
    if (!activeId && projects.length > 0) {
      // No active project set - set first project as active
      localProjectStorage.setActiveProjectId(projects[0].id);
      logger.log('‚úÖ Set first project as active');
    } else if (activeId) {
      // Verify active project exists
      const activeProject = projects.find(p => p.id === activeId);
      if (!activeProject && projects.length > 0) {
        // Active project doesn't exist - set first project as active
        localProjectStorage.setActiveProjectId(projects[0].id);
        logger.warn('‚ö†Ô∏è Active project not found. Switched to first project.');
      }
    }
    
    logger.log('‚úÖ Project system initialized');
    
  } catch (error) {
    logger.error('‚ùå Failed to initialize project system:', error);
  }
}

/**
 * Get current active project (sync - uses local storage)
 * Returns null if no active project exists
 */
export function getCurrentProject(): Project | null {
  return localProjectStorage.getCurrentProject();
}

/**
 * Create new project and set as active
 * Returns the created project (async for cloud support)
 */
export async function createAndActivateProject(name: string): Promise<Project> {
  if (typeof window === 'undefined') {
    throw new Error('Cannot create project in non-browser environment');
  }
  
  // Create project
  const newProject = await createProject(name);
  
  // Set as active
  await setActiveProjectId(newProject.id);
  
  logger.log('‚úÖ Created and activated project:', {
    id: newProject.id,
    name: newProject.name,
  });
  
  return newProject;
}

/**
 * Re-export unified storage functions for convenience
 */
export { getAllProjects, getActiveProjectId, setActiveProjectId } from '@/lib/storage/unified-storage';


=== FILE: lib/utils/readability.ts ===

/**
 * @file lib/utils/readability.ts
 * @description Readability analysis utilities using Flesch-Kincaid formulas
 * 
 * Provides text analysis without requiring any API calls:
 * - Word count
 * - Character count
 * - Sentence count
 * - Syllable count
 * - Reading time estimation
 * - Flesch Reading Ease score
 * - Flesch-Kincaid Grade Level
 */

// ============================================================================
// Constants
// ============================================================================

/** Average reading speed in words per minute */
const WORDS_PER_MINUTE = 200;

/** Vowels used for syllable counting */
const VOWELS = ['a', 'e', 'i', 'o', 'u', 'y'];

/** Silent endings that don't add syllables */
const SILENT_ENDINGS = ['es', 'ed', 'e'];

/** Special suffixes that count as additional syllables */
const SYLLABLE_SUFFIXES = ['le', 'les', 'tion', 'sion'];

// ============================================================================
// Type Definitions
// ============================================================================

/**
 * Basic text metrics (no API required)
 */
export interface BasicMetrics {
  /** Total word count */
  wordCount: number;
  
  /** Total character count (including spaces) */
  characterCount: number;
  
  /** Total character count (excluding spaces) */
  characterCountNoSpaces: number;
  
  /** Total sentence count */
  sentenceCount: number;
  
  /** Estimated reading time in seconds */
  readingTimeSeconds: number;
  
  /** Formatted reading time string */
  readingTimeFormatted: string;
}

/**
 * Readability metrics
 */
export interface ReadabilityMetrics {
  /** Flesch Reading Ease score (0-100) */
  fleschReadingEase: number;
  
  /** Flesch-Kincaid Grade Level */
  gradeLevel: number;
  
  /** Human-readable grade level string */
  gradeLevelLabel: string;
  
  /** Readability label (Very Easy, Easy, etc.) */
  readabilityLabel: string;
  
  /** Normalized score (1-10 scale) */
  normalizedScore: number;
}

/**
 * Complete document metrics
 */
export interface DocumentMetrics extends BasicMetrics, ReadabilityMetrics {}

// ============================================================================
// Text Extraction
// ============================================================================

/**
 * Strip HTML tags and convert to plain text
 * @param html - HTML content string
 * @returns Plain text with HTML removed
 */
export function stripHtml(html: string): string {
  if (!html) return '';
  
  // Replace block-level elements with newlines for proper sentence detection
  const blockElements = /<\/(p|div|h[1-6]|li|br|blockquote)>/gi;
  let text = html.replace(blockElements, '. ');
  
  // Remove all remaining HTML tags
  text = text.replace(/<[^>]*>/g, ' ');
  
  // Decode common HTML entities
  text = text
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&mdash;/g, '‚Äî')
    .replace(/&ndash;/g, '‚Äì');
  
  // Normalize whitespace
  text = text.replace(/\s+/g, ' ').trim();
  
  // Clean up multiple periods
  text = text.replace(/\.+/g, '.');
  
  return text;
}

// ============================================================================
// Basic Counting Functions
// ============================================================================

/**
 * Count words in text
 * @param text - Plain text string
 * @returns Number of words
 */
export function countWords(text: string): number {
  if (!text || !text.trim()) return 0;
  
  // Split on whitespace and filter empty strings
  const words = text.trim().split(/\s+/).filter(word => word.length > 0);
  return words.length;
}

/**
 * Count sentences in text
 * Uses sentence-ending punctuation as delimiters
 * @param text - Plain text string
 * @returns Number of sentences
 */
export function countSentences(text: string): number {
  if (!text || !text.trim()) return 0;
  
  // Match sentence-ending punctuation followed by space or end of string
  // Also handles abbreviations by requiring at least 2 characters before period
  const sentenceEndings = text.match(/[.!?]+(?:\s|$)/g);
  
  // If no sentence endings found, treat as one sentence if there's content
  if (!sentenceEndings) {
    return text.trim().length > 0 ? 1 : 0;
  }
  
  return sentenceEndings.length;
}

/**
 * Count syllables in a single word
 * Uses heuristic approach for English words
 * @param word - Single word
 * @returns Number of syllables (minimum 1)
 */
export function countSyllables(word: string): number {
  if (!word) return 0;
  
  // Normalize to lowercase, remove non-alphabetic characters
  const cleanWord = word.toLowerCase().replace(/[^a-z]/g, '');
  
  if (cleanWord.length === 0) return 0;
  if (cleanWord.length <= 2) return 1;
  
  let syllableCount = 0;
  let previousWasVowel = false;
  
  // Count vowel groups
  for (let i = 0; i < cleanWord.length; i++) {
    const char = cleanWord[i];
    const isVowel = VOWELS.includes(char);
    
    if (isVowel && !previousWasVowel) {
      syllableCount++;
    }
    
    previousWasVowel = isVowel;
  }
  
  // Handle silent 'e' at end
  if (cleanWord.endsWith('e') && !cleanWord.endsWith('le')) {
    syllableCount--;
  }
  
  // Handle special endings
  if (cleanWord.endsWith('le') && cleanWord.length > 2) {
    const charBeforeLe = cleanWord[cleanWord.length - 3];
    // 'le' adds syllable if preceded by consonant
    if (!VOWELS.includes(charBeforeLe)) {
      // Already counted in vowel groups for some words, skip
    }
  }
  
  // Handle -ed ending
  if (cleanWord.endsWith('ed') && cleanWord.length > 2) {
    const charBeforeEd = cleanWord[cleanWord.length - 3];
    // -ed is usually silent except after t or d
    if (charBeforeEd !== 't' && charBeforeEd !== 'd') {
      syllableCount--;
    }
  }
  
  // Ensure at least one syllable
  return Math.max(1, syllableCount);
}

/**
 * Count total syllables in text
 * @param text - Plain text string
 * @returns Total syllable count
 */
export function countTotalSyllables(text: string): number {
  if (!text || !text.trim()) return 0;
  
  const words = text.trim().split(/\s+/).filter(word => word.length > 0);
  return words.reduce((total, word) => total + countSyllables(word), 0);
}

// ============================================================================
// Reading Time
// ============================================================================

/**
 * Calculate estimated reading time
 * @param wordCount - Number of words
 * @returns Reading time in seconds
 */
export function calculateReadingTime(wordCount: number): number {
  if (wordCount <= 0) return 0;
  return Math.ceil((wordCount / WORDS_PER_MINUTE) * 60);
}

/**
 * Format reading time as human-readable string
 * @param seconds - Reading time in seconds
 * @returns Formatted string (e.g., "~2 min 30 sec")
 */
export function formatReadingTime(seconds: number): string {
  if (seconds <= 0) return '< 1 sec';
  
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;
  
  if (minutes === 0) {
    return `~${remainingSeconds} sec`;
  }
  
  if (remainingSeconds === 0) {
    return `~${minutes} min`;
  }
  
  return `~${minutes} min ${remainingSeconds} sec`;
}

// ============================================================================
// Readability Calculations
// ============================================================================

/**
 * Calculate Flesch Reading Ease score
 * Formula: 206.835 - 1.015 √ó (words/sentences) - 84.6 √ó (syllables/words)
 * 
 * Score interpretation:
 * - 90-100: Very Easy (5th grade)
 * - 80-89: Easy (6th grade)
 * - 70-79: Fairly Easy (7th grade)
 * - 60-69: Standard (8th-9th grade)
 * - 50-59: Fairly Difficult (10th-12th grade)
 * - 30-49: Difficult (College)
 * - 0-29: Very Difficult (College graduate)
 * 
 * @param wordCount - Total words
 * @param sentenceCount - Total sentences
 * @param syllableCount - Total syllables
 * @returns Flesch Reading Ease score (clamped to 0-100)
 */
export function calculateFleschReadingEase(
  wordCount: number,
  sentenceCount: number,
  syllableCount: number
): number {
  if (wordCount === 0 || sentenceCount === 0) return 0;
  
  const avgSentenceLength = wordCount / sentenceCount;
  const avgSyllablesPerWord = syllableCount / wordCount;
  
  const score = 206.835 - (1.015 * avgSentenceLength) - (84.6 * avgSyllablesPerWord);
  
  // Clamp to 0-100 range
  return Math.max(0, Math.min(100, Math.round(score * 10) / 10));
}

/**
 * Calculate Flesch-Kincaid Grade Level
 * Formula: 0.39 √ó (words/sentences) + 11.8 √ó (syllables/words) - 15.59
 * 
 * @param wordCount - Total words
 * @param sentenceCount - Total sentences
 * @param syllableCount - Total syllables
 * @returns Grade level (minimum 1)
 */
export function calculateGradeLevel(
  wordCount: number,
  sentenceCount: number,
  syllableCount: number
): number {
  if (wordCount === 0 || sentenceCount === 0) return 0;
  
  const avgSentenceLength = wordCount / sentenceCount;
  const avgSyllablesPerWord = syllableCount / wordCount;
  
  const gradeLevel = (0.39 * avgSentenceLength) + (11.8 * avgSyllablesPerWord) - 15.59;
  
  // Clamp to reasonable range (1-20)
  return Math.max(1, Math.min(20, Math.round(gradeLevel * 10) / 10));
}

/**
 * Get readability label from Flesch Reading Ease score
 * @param score - Flesch Reading Ease score (0-100)
 * @returns Human-readable label
 */
export function getReadabilityLabel(score: number): string {
  if (score >= 90) return 'Very Easy';
  if (score >= 80) return 'Easy';
  if (score >= 70) return 'Fairly Easy';
  if (score >= 60) return 'Standard';
  if (score >= 50) return 'Fairly Difficult';
  if (score >= 30) return 'Difficult';
  return 'Very Difficult';
}

/**
 * Get grade level label from numeric grade
 * @param grade - Numeric grade level
 * @returns Human-readable grade string
 */
export function getGradeLevelLabel(grade: number): string {
  const roundedGrade = Math.round(grade);
  
  if (roundedGrade <= 5) return '5th grade';
  if (roundedGrade === 6) return '6th grade';
  if (roundedGrade === 7) return '7th grade';
  if (roundedGrade === 8) return '8th grade';
  if (roundedGrade === 9) return '9th grade';
  if (roundedGrade === 10) return '10th grade';
  if (roundedGrade === 11) return '11th grade';
  if (roundedGrade === 12) return '12th grade';
  if (roundedGrade <= 16) return 'College';
  return 'Graduate';
}

/**
 * Convert Flesch Reading Ease to 1-10 normalized score
 * Higher is better (easier to read)
 * @param fleschScore - Flesch Reading Ease score (0-100)
 * @returns Normalized score (1-10)
 */
export function normalizeReadabilityScore(fleschScore: number): number {
  // Map 0-100 to 1-10 scale
  const normalized = (fleschScore / 100) * 9 + 1;
  return Math.max(1, Math.min(10, Math.round(normalized * 10) / 10));
}

// ============================================================================
// Main Analysis Functions
// ============================================================================

/**
 * Calculate basic text metrics
 * @param text - Plain text (or HTML that will be stripped)
 * @returns Basic metrics object
 */
export function calculateBasicMetrics(text: string): BasicMetrics {
  // Strip HTML if present
  const plainText = stripHtml(text);
  
  const wordCount = countWords(plainText);
  const characterCount = plainText.length;
  const characterCountNoSpaces = plainText.replace(/\s/g, '').length;
  const sentenceCount = countSentences(plainText);
  const readingTimeSeconds = calculateReadingTime(wordCount);
  const readingTimeFormatted = formatReadingTime(readingTimeSeconds);
  
  return {
    wordCount,
    characterCount,
    characterCountNoSpaces,
    sentenceCount,
    readingTimeSeconds,
    readingTimeFormatted,
  };
}

/**
 * Calculate readability metrics
 * @param text - Plain text (or HTML that will be stripped)
 * @returns Readability metrics object
 */
export function calculateReadabilityMetrics(text: string): ReadabilityMetrics {
  // Strip HTML if present
  const plainText = stripHtml(text);
  
  const wordCount = countWords(plainText);
  const sentenceCount = countSentences(plainText);
  const syllableCount = countTotalSyllables(plainText);
  
  const fleschReadingEase = calculateFleschReadingEase(wordCount, sentenceCount, syllableCount);
  const gradeLevel = calculateGradeLevel(wordCount, sentenceCount, syllableCount);
  const gradeLevelLabel = getGradeLevelLabel(gradeLevel);
  const readabilityLabel = getReadabilityLabel(fleschReadingEase);
  const normalizedScore = normalizeReadabilityScore(fleschReadingEase);
  
  return {
    fleschReadingEase,
    gradeLevel,
    gradeLevelLabel,
    readabilityLabel,
    normalizedScore,
  };
}

/**
 * Calculate all document metrics
 * @param text - Plain text (or HTML that will be stripped)
 * @returns Complete metrics object
 */
export function analyzeDocument(text: string): DocumentMetrics {
  // Strip HTML if present
  const plainText = stripHtml(text);
  
  // Basic counts
  const wordCount = countWords(plainText);
  const characterCount = plainText.length;
  const characterCountNoSpaces = plainText.replace(/\s/g, '').length;
  const sentenceCount = countSentences(plainText);
  const syllableCount = countTotalSyllables(plainText);
  
  // Reading time
  const readingTimeSeconds = calculateReadingTime(wordCount);
  const readingTimeFormatted = formatReadingTime(readingTimeSeconds);
  
  // Readability
  const fleschReadingEase = calculateFleschReadingEase(wordCount, sentenceCount, syllableCount);
  const gradeLevel = calculateGradeLevel(wordCount, sentenceCount, syllableCount);
  const gradeLevelLabel = getGradeLevelLabel(gradeLevel);
  const readabilityLabel = getReadabilityLabel(fleschReadingEase);
  const normalizedScore = normalizeReadabilityScore(fleschReadingEase);
  
  return {
    wordCount,
    characterCount,
    characterCountNoSpaces,
    sentenceCount,
    readingTimeSeconds,
    readingTimeFormatted,
    fleschReadingEase,
    gradeLevel,
    gradeLevelLabel,
    readabilityLabel,
    normalizedScore,
  };
}


=== FILE: middleware.ts ===

/**
 * @file middleware.ts
 * @description Clerk authentication middleware for route protection (Clerk 5.x)
 * 
 * Protects all routes under /worxspace, /templates, /projects
 * Keeps marketing pages, auth pages, and API routes public
 */

import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server';

/**
 * Define public routes that don't require authentication
 * 
 * Public routes:
 * - / (redirects to /home)
 * - /home (splash page)
 * - /about
 * - /pricing
 * - /sign-in, /sign-up (auth pages)
 * - /api/* (API routes - handle their own auth)
 */
const isPublicRoute = createRouteMatcher([
  '/',
  '/home',
  '/about',
  '/pricing',
  '/sign-in(.*)',
  '/sign-up(.*)',
  '/api(.*)',
]);

/**
 * Clerk middleware configuration
 * 
 * Uses clerkMiddleware with createRouteMatcher pattern (Clerk 5.x)
 * Protects all routes except those defined in isPublicRoute
 */
export default clerkMiddleware((auth, request) => {
  // If it's not a public route, require authentication
  if (!isPublicRoute(request)) {
    auth().protect();
  }
});

/**
 * Middleware matcher configuration
 * Specifies which routes the middleware should run on
 */
export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
};


=== FILE: next-env.d.ts ===

/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.


=== FILE: next.config.js ===

/**
 * @file next.config.js
 * @description Next.js configuration for CopyWorx application
 */

/** @type {import('next').NextConfig} */
const nextConfig = {
  // Enable React Strict Mode for better development experience
  reactStrictMode: true,
  
  // Disable ESLint during production builds to avoid blocking deployment
  eslint: {
    ignoreDuringBuilds: true,
  },
  
  // Image optimization configuration
  images: {
    formats: ['image/avif', 'image/webp'],
    unoptimized: false,
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'img.clerk.com',
        port: '',
        pathname: '/**',
      },
    ],
  },
  
  // Experimental features for App Router optimization
  experimental: {
    // Enable server actions
    serverActions: {
      bodySizeLimit: '2mb',
    },
  },
};

module.exports = nextConfig;



=== FILE: postcss.config.js ===

/**
 * @file postcss.config.js
 * @description PostCSS configuration for Tailwind CSS processing
 */

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};



=== FILE: tailwind.config.ts ===

/**
 * @file tailwind.config.ts
 * @description Tailwind CSS configuration with custom CopyWorx theme
 * 
 * Design System:
 * - Primary: Deep ink/navy tones for professional writing aesthetic
 * - Accent: Warm amber/gold for CTAs and highlights
 * - Neutrals: Warm grays for text and backgrounds
 */

import type { Config } from 'tailwindcss';

const config: Config = {
  darkMode: ['class'],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  prefix: '',
  theme: {
    container: {
      center: true,
      padding: '2rem',
      screens: {
        '2xl': '1400px',
      },
    },
    extend: {
      colors: {
        // Custom CopyWorx palette
        ink: {
          50: '#f6f7f9',
          100: '#eceef2',
          200: '#d5d9e2',
          300: '#b0b8c9',
          400: '#8592ab',
          500: '#667591',
          600: '#515d77',
          700: '#434c61',
          800: '#3a4152',
          900: '#1e2433',
          950: '#0f1219',
        },
        amber: {
          50: '#fffdf0',
          100: '#fef9d9',
          200: '#fef3b3',
          300: '#fded8c',
          400: '#fde166',
          500: '#EFBF04',
          600: '#d9aa04',
          700: '#b38c03',
          800: '#8c6d03',
          900: '#665002',
          950: '#403301',
        },
        // Apple aesthetic - CopyWorx v2
        'apple-blue': {
          DEFAULT: '#0071E3',
          dark: '#0062CC',
          light: '#0077ED',
        },
        'apple-gray': {
          DEFAULT: '#86868B',
          light: '#D2D2D7',
          bg: '#F5F5F7',
        },
        'apple-text': {
          dark: '#1D1D1F',
          light: '#6E6E73',
        },
        'apple-editor': {
          bg: '#2F3542',
          paper: '#FFFFFF',
        },
        // shadcn/ui compatible colors
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
      },
      fontFamily: {
        sans: ['var(--font-inter)', 'Inter', 'system-ui', '-apple-system', 'BlinkMacSystemFont', 'sans-serif'],
        mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', 'monospace'],
      },
      fontSize: {
        '2xs': ['0.625rem', { lineHeight: '0.875rem' }],
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
      keyframes: {
        'accordion-down': {
          from: { height: '0' },
          to: { height: 'var(--radix-accordion-content-height)' },
        },
        'accordion-up': {
          from: { height: 'var(--radix-accordion-content-height)' },
          to: { height: '0' },
        },
        'fade-in': {
          from: { opacity: '0', transform: 'translateY(10px)' },
          to: { opacity: '1', transform: 'translateY(0)' },
        },
        'fade-in-up': {
          from: { opacity: '0', transform: 'translateY(20px)' },
          to: { opacity: '1', transform: 'translateY(0)' },
        },
        'slide-in-right': {
          from: { opacity: '0', transform: 'translateX(20px)' },
          to: { opacity: '1', transform: 'translateX(0)' },
        },
        shimmer: {
          '0%': { opacity: '0.5', transform: 'scale(1)' },
          '50%': { opacity: '1', transform: 'scale(1.1)' },
          '100%': { opacity: '0.5', transform: 'scale(1)' },
        },
        pulse: {
          '0%, 100%': { opacity: '1' },
          '50%': { opacity: '0.5' },
        },
        'gradient-flow': {
          '0%, 100%': { 
            backgroundPosition: '0% 50%',
          },
          '50%': { 
            backgroundPosition: '100% 50%',
          },
        },
      },
      animation: {
        'accordion-down': 'accordion-down 0.2s ease-out',
        'accordion-up': 'accordion-up 0.2s ease-out',
        'fade-in': 'fade-in 0.5s ease-out forwards',
        'fade-in-up': 'fade-in-up 0.6s ease-out forwards',
        'slide-in-right': 'slide-in-right 0.4s ease-out forwards',
        shimmer: 'shimmer 2s ease-in-out infinite',
        pulse: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
        'gradient-flow': 'gradient-flow 3s ease-in-out infinite',
      },
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'hero-pattern': 'url("/patterns/grid.svg")',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
};

export default config;



=== FILE: test-tone-shift.js ===

/**
 * Simple test script for the tone-shift API endpoint
 * Run with: node test-tone-shift.js
 */

const API_URL = 'http://localhost:3001/api/tone-shift';

// Test cases covering all four tones
const tests = [
  {
    name: 'Test 1: Professional Tone',
    body: {
      text: "Hey! Our sale ends soon so grab it while you can! It's seriously awesome!",
      tone: 'professional'
    }
  },
  {
    name: 'Test 2: Casual Tone',
    body: {
      text: 'We cordially invite you to attend our annual corporate symposium. Your presence would be greatly appreciated.',
      tone: 'casual'
    }
  },
  {
    name: 'Test 3: Urgent Tone',
    body: {
      text: 'Our new service is now available for your consideration at your earliest convenience.',
      tone: 'urgent'
    }
  },
  {
    name: 'Test 4: Friendly Tone',
    body: {
      text: 'Submit your application through our online portal. Processing times may vary.',
      tone: 'friendly'
    }
  },
  {
    name: 'Test 5: Error - Missing Text',
    body: {
      tone: 'professional'
    },
    expectError: true
  },
  {
    name: 'Test 6: Error - Invalid Tone',
    body: {
      text: 'Some copy here',
      tone: 'sarcastic'
    },
    expectError: true
  }
];

async function runTest(test) {
  console.log(`\n${'='.repeat(60)}`);
  console.log(`Running: ${test.name}`);
  console.log(`${'='.repeat(60)}`);
  console.log('Request body:', JSON.stringify(test.body, null, 2));
  
  try {
    const response = await fetch(API_URL, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(test.body),
    });

    const data = await response.json();
    
    console.log(`\nStatus: ${response.status} ${response.statusText}`);
    
    if (test.expectError) {
      if (!response.ok) {
        console.log('‚úÖ Error test passed');
        console.log('Error response:', JSON.stringify(data, null, 2));
      } else {
        console.log('‚ùå Expected error but got success');
      }
    } else {
      if (response.ok) {
        console.log('‚úÖ Test passed');
        console.log(`\nOriginal (${data.originalLength} chars):`);
        console.log(test.body.text);
        console.log(`\nRewritten (${data.newLength} chars):`);
        console.log(data.rewrittenText);
        console.log(`\nLength change: ${((data.newLength - data.originalLength) / data.originalLength * 100).toFixed(1)}%`);
      } else {
        console.log('‚ùå Test failed');
        console.log('Error response:', JSON.stringify(data, null, 2));
      }
    }
  } catch (error) {
    console.log('‚ùå Request failed:', error.message);
  }
}

async function runAllTests() {
  console.log('üöÄ Starting Tone Shift API Tests');
  console.log(`Testing endpoint: ${API_URL}\n`);
  
  for (const test of tests) {
    await runTest(test);
    // Add a small delay between tests
    await new Promise(resolve => setTimeout(resolve, 1000));
  }
  
  console.log(`\n${'='.repeat(60)}`);
  console.log('All tests completed!');
  console.log(`${'='.repeat(60)}\n`);
}

// Run tests
runAllTests().catch(console.error);

